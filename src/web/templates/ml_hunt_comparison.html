{% extends "base.html" %}

{% block title %}ML vs Hunt Scoring Comparison - Huntable CTI Scraper{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <div class="mb-8">
        <h1 class="text-3xl font-bold text-gray-900 dark:text-white mb-2">üìä ML vs Hunt Scoring Comparison</h1>
        <p class="text-gray-600 dark:text-gray-400">Compare ML model predictions with Hunt scoring system for articles with hunt_score > 50</p>
    </div>
    
    <!-- Stats Grid -->
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-medium text-gray-900 dark:text-white mb-2">Total Model Versions</h3>
            <div class="text-3xl font-bold text-blue-600" id="totalModelVersions">-</div>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-medium text-gray-900 dark:text-white mb-2">Total Chunk Analyses</h3>
            <div class="text-3xl font-bold text-blue-600" id="totalChunkAnalyses">-</div>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-medium text-gray-900 dark:text-white mb-2">Average Accuracy</h3>
            <div class="text-3xl font-bold text-blue-600" id="averageAccuracy">-</div>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-medium text-gray-900 dark:text-white mb-2">Last Updated</h3>
            <div class="text-3xl font-bold text-blue-600" id="lastUpdated">-</div>
        </div>
    </div>

    <!-- Model Retraining Section -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-4">üîÑ Model Retraining</h2>
        <p class="text-gray-600 dark:text-gray-400 mb-4">Retrain the ML model with user feedback from chunk debugging to improve performance</p>
        
        <div class="flex justify-between items-center">
            <div class="text-lg font-medium text-gray-900 dark:text-white">
                <div>Current model: <span id="retrainingStatus">v24 (79.4% accuracy)</span></div>
                <div class="text-sm text-gray-500 dark:text-gray-400 mt-1">
                    Available feedback: <span id="feedbackCount">-</span> user corrections
                </div>
            </div>
            <div class="flex gap-3">
                <button id="retrainModelBtn" 
                        class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2">
                    Retrain Model
                </button>
                <button id="refreshRetrainBtn" 
                        class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                    Refresh Status
                </button>
            </div>
        </div>
        
        <!-- Retraining Progress Bar -->
        <div id="retrainProgressSection" class="hidden mt-4">
            <div class="w-full bg-gray-200 rounded-full h-2">
                <div id="retrainProgressBar" class="bg-purple-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <div id="retrainProgressText" class="text-sm text-gray-600 mt-2">Retraining...</div>
        </div>
        
        <!-- Retraining Results -->
        <div id="retrainResultsSection" class="hidden mt-4 p-4 bg-gray-50 dark:bg-gray-700 rounded-md">
            <div id="retrainResultsContent"></div>
        </div>
    </div>

    <!-- Backfill Section -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-4">üîÑ Backfill Chunk Analysis</h2>
        <p class="text-gray-600 dark:text-gray-400 mb-4">Process articles with hunt_score > 50 to populate comparison data</p>
        
        <div class="flex justify-between items-center">
            <div class="text-lg font-medium text-gray-900 dark:text-white">
                <span id="eligibleCount">-</span> articles eligible for processing
            </div>
            <div class="flex gap-3">
                <button id="processAllBtn" 
                        class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    Process All Eligible Articles
                </button>
                <button id="refreshCountBtn" 
                        class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                    Refresh Count
                </button>
            </div>
        </div>
        
        <!-- Progress Bar -->
        <div id="progressSection" class="hidden mt-4">
            <div class="w-full bg-gray-200 rounded-full h-2">
                <div id="progressBar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <div id="progressText" class="text-sm text-gray-600 mt-2">Processing...</div>
        </div>
        
        <!-- Results -->
        <div id="resultsSection" class="hidden mt-4 p-4 bg-gray-50 dark:bg-gray-700 rounded-md">
            <div id="resultsContent"></div>
        </div>
    </div>
    
    <!-- Model Evaluation Section -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-4">üß™ Model Evaluation on Test Set</h2>
        <p class="text-gray-600 dark:text-gray-400 mb-4">Evaluate current model performance on 160 annotated chunks from article_annotations table</p>
        
        <div class="flex justify-between items-center">
            <div class="text-lg font-medium text-gray-900 dark:text-white">
                <span id="evalStatus">Ready to evaluate current model</span>
            </div>
            <div class="flex gap-3">
                <button id="evaluateModelBtn" 
                        class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                    Evaluate Current Model
                </button>
                <button id="refreshEvalStatusBtn" 
                        class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                    Refresh Status
                </button>
            </div>
        </div>
        
        <!-- Evaluation Progress -->
        <div id="evalProgressSection" class="hidden mt-4">
            <div class="w-full bg-gray-200 rounded-full h-2">
                <div id="evalProgressBar" class="bg-green-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <div id="evalProgressText" class="text-sm text-gray-600 mt-2">Evaluating model...</div>
        </div>
        
        <!-- Evaluation Results -->
        <div id="evalResultsSection" class="hidden mt-4 p-4 bg-gray-50 dark:bg-gray-700 rounded-md">
            <div id="evalResultsContent"></div>
        </div>
    </div>
    
    <!-- Charts Section -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">üìà Classification Trends</h3>
            <canvas id="distributionChart" width="400" height="200"></canvas>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">üìä Model Performance Summary</h3>
            <div id="modelPerformanceSummary" class="text-center text-gray-500 dark:text-gray-400">
                <p>Run model evaluation to see performance metrics</p>
            </div>
        </div>
    </div>
    
    <!-- Evaluation Metrics Charts -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">üß™ Evaluation Accuracy Over Time</h3>
            <canvas id="evalAccuracyChart" width="400" height="200"></canvas>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">üìä Evaluation Metrics Comparison</h3>
            <canvas id="evalMetricsChart" width="400" height="200"></canvas>
        </div>
    </div>
    
    <!-- Detailed Results Table -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow">
        <div class="px-6 py-4 border-b border-gray-200 dark:border-gray-700">
            <h3 class="text-lg font-semibold text-gray-900 dark:text-white">üìã Detailed Comparison Results</h3>
        </div>
        <div class="overflow-x-auto">
            <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                <thead class="bg-gray-50 dark:bg-gray-700">
                    <tr>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Article</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Hunt Score</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">ML Prediction</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Match</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Confidence</th>
                    </tr>
                </thead>
                <tbody id="resultsTableBody" class="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                    <!-- Results will be populated by JavaScript -->
                </tbody>
            </table>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let currentData = {
            stats: [],
            results: [],
        summary: null,
        modelVersions: []
        };

        // Load initial data
        async function loadInitialData() {
            try {
                // Load summary
                const summaryResponse = await fetch('/api/ml-hunt-comparison/summary');
                const summaryData = await summaryResponse.json();
                if (summaryData.success) {
                    currentData.summary = summaryData.summary;
                    updateSummaryStats();
                }

                // Load stats
                const statsResponse = await fetch('/api/ml-hunt-comparison/stats');
                const statsData = await statsResponse.json();
                if (statsData.success) {
                    currentData.stats = statsData.stats;
            }
            
            // Load model versions for evaluation metrics
            const versionsResponse = await fetch('/api/model/versions');
            const versionsData = await versionsResponse.json();
            if (versionsData.success) {
                currentData.modelVersions = versionsData.versions;
            }

            // Load classification timeline
            const timelineResponse = await fetch('/api/model/classification-timeline');
            const timelineData = await timelineResponse.json();
            if (timelineData.success) {
                currentData.timeline = timelineData.timeline;
            }
            
                    updateCharts();
            } catch (error) {
                console.error('Error loading initial data:', error);
                showError('Failed to load initial data');
            }
        }

        function updateSummaryStats() {
            const summary = currentData.summary;
        document.getElementById('totalModelVersions').textContent = summary.total_model_versions;
        document.getElementById('totalChunkAnalyses').textContent = summary.total_chunk_analyses.toLocaleString();
            
        if (summary.overall_stats && summary.overall_stats.length > 0) {
                const avgAccuracy = summary.overall_stats.reduce((sum, stat) => sum + stat.accuracy, 0) / summary.overall_stats.length;
            document.getElementById('averageAccuracy').textContent = (avgAccuracy * 100).toFixed(1) + '%';
            }
            
            if (summary.last_updated) {
                const date = new Date(summary.last_updated);
                document.getElementById('lastUpdated').textContent = date.toLocaleDateString();
            }
        }

        function updateCharts() {
        updateDistributionChart();
        updateModelPerformanceSummary();
        updateEvaluationCharts();
    }

    function updateModelPerformanceSummary() {
        const summaryElement = document.getElementById('modelPerformanceSummary');
        
        // Get the latest evaluated version
        const latestEvaluated = currentData.modelVersions
            .filter(v => v.has_evaluation)
            .sort((a, b) => b.version_number - a.version_number)[0];
        
        if (!latestEvaluated) {
            summaryElement.innerHTML = '<p class="text-gray-500 dark:text-gray-400">Run model evaluation to see performance metrics</p>';
            return;
        }
        
        const evalDate = new Date(latestEvaluated.evaluated_at).toLocaleDateString();
        summaryElement.innerHTML = `
            <div class="space-y-2">
                <div class="text-lg font-semibold text-gray-900 dark:text-white">
                    Model v${latestEvaluated.version_number}
                </div>
                <div class="text-2xl font-bold text-blue-600">
                    ${(latestEvaluated.eval_accuracy * 100).toFixed(1)}%
                </div>
                <div class="text-sm text-gray-600 dark:text-gray-400">
                    Test Accuracy (160 chunks)
                </div>
                <div class="text-xs text-gray-500 dark:text-gray-500">
                    Evaluated: ${evalDate}
                </div>
                <div class="grid grid-cols-2 gap-2 text-xs mt-2">
                    <div>Precision (H): ${((latestEvaluated.eval_precision_huntable || 0) * 100).toFixed(1)}%</div>
                    <div>Recall (H): ${((latestEvaluated.eval_recall_huntable || 0) * 100).toFixed(1)}%</div>
                    <div>Precision (NH): ${((latestEvaluated.eval_precision_not_huntable || 0) * 100).toFixed(1)}%</div>
                    <div>Recall (NH): ${((latestEvaluated.eval_recall_not_huntable || 0) * 100).toFixed(1)}%</div>
                </div>
            </div>
        `;
    }

    function updateDistributionChart() {
        const ctx = document.getElementById('distributionChart').getContext('2d');
        
        if (!currentData.timeline || currentData.timeline.length === 0) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillText('No timeline data available', 10, 50);
            return;
        }
        
        // Prepare data for time series chart
        const labels = currentData.timeline.map(item => `v${item.version_number}`);
        const agreementData = currentData.timeline.map(item => item.agreement);
        const mlOnlyData = currentData.timeline.map(item => item.ml_only);
        const huntOnlyData = currentData.timeline.map(item => item.hunt_only);
        const neitherData = currentData.timeline.map(item => item.neither);
            
            new Chart(ctx, {
            type: 'line',
                data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Agreement (Both Huntable)',
                        data: agreementData,
                        borderColor: 'rgba(75, 192, 192, 1)',
                        backgroundColor: 'rgba(75, 192, 192, 0.1)',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'ML Only (ML Huntable)',
                        data: mlOnlyData,
                        borderColor: 'rgba(54, 162, 235, 1)',
                        backgroundColor: 'rgba(54, 162, 235, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Hunt Only (Hunt Huntable)',
                        data: huntOnlyData,
                        borderColor: 'rgba(255, 205, 86, 1)',
                        backgroundColor: 'rgba(255, 205, 86, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Neither (Not Huntable)',
                        data: neitherData,
                        borderColor: 'rgba(255, 99, 132, 1)',
                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    }
                ]
                },
                options: {
                    responsive: true,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                scales: {
                    y: {
                        type: 'logarithmic',
                        beginAtZero: false,
                        min: 1,
                        title: {
                            display: true,
                            text: 'Number of Chunks (Log Scale)'
                        },
                        ticks: {
                            callback: function(value) {
                                return value.toLocaleString();
                            }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Model Version'
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Classification Trends Across Model Versions'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            afterBody: function(context) {
                                const dataIndex = context[0].dataIndex;
                                const item = currentData.timeline[dataIndex];
                                return [
                                    `Total Chunks: ${item.total_chunks}`,
                                    `Accuracy: ${(item.accuracy * 100).toFixed(1)}%`,
                                    `Trained: ${new Date(item.trained_at).toLocaleDateString()}`
                                ];
                            }
                        }
                        }
                    }
                }
            });
    }

    function updateEvaluationCharts() {
        updateEvalAccuracyChart();
        updateEvalMetricsChart();
    }

    function updateEvalAccuracyChart() {
        const ctx = document.getElementById('evalAccuracyChart').getContext('2d');
        
        // Filter versions that have evaluation data
        const evaluatedVersions = currentData.modelVersions.filter(v => v.has_evaluation);
        
        if (evaluatedVersions.length === 0) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillText('No evaluation data available', 10, 50);
            return;
        }
        
        // Sort by version number
        evaluatedVersions.sort((a, b) => a.version_number - b.version_number);
        
            new Chart(ctx, {
            type: 'line',
                data: {
                labels: evaluatedVersions.map(v => `v${v.version_number}`),
                    datasets: [{
                    label: 'Evaluation Accuracy %',
                    data: evaluatedVersions.map(v => (v.eval_accuracy * 100)),
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Model Performance on Test Set (160 chunks)'
                    }
                }
                }
            });
        }

    function updateEvalMetricsChart() {
        const ctx = document.getElementById('evalMetricsChart').getContext('2d');
        
        // Get the latest evaluated version
        const latestEvaluated = currentData.modelVersions
            .filter(v => v.has_evaluation)
            .sort((a, b) => b.version_number - a.version_number)[0];
        
        if (!latestEvaluated) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillText('No evaluation data available', 10, 50);
            return;
        }
            
            new Chart(ctx, {
            type: 'radar',
                data: {
                labels: ['Accuracy', 'Precision (Huntable)', 'Precision (Not Huntable)', 
                        'Recall (Huntable)', 'Recall (Not Huntable)', 
                        'F1 (Huntable)', 'F1 (Not Huntable)'],
                    datasets: [{
                    label: `Model v${latestEvaluated.version_number}`,
                    data: [
                        latestEvaluated.eval_accuracy * 100,
                        (latestEvaluated.eval_precision_huntable || 0) * 100,
                        (latestEvaluated.eval_precision_not_huntable || 0) * 100,
                        (latestEvaluated.eval_recall_huntable || 0) * 100,
                        (latestEvaluated.eval_recall_not_huntable || 0) * 100,
                        (latestEvaluated.eval_f1_score_huntable || 0) * 100,
                        (latestEvaluated.eval_f1_score_not_huntable || 0) * 100
                    ],
                    borderColor: 'rgba(54, 162, 235, 1)',
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                    r: {
                        beginAtZero: true,
                        max: 100,
                        grid: {
                            color: 'rgba(156, 163, 175, 0.3)', // Lighter gray grid lines
                        },
                        angleLines: {
                            color: 'rgba(156, 163, 175, 0.3)', // Lighter gray angle lines
                        },
                        pointLabels: {
                            color: 'rgba(156, 163, 175, 0.8)', // Lighter gray labels
                        },
                        ticks: {
                            color: 'rgba(156, 163, 175, 0.6)', // Lighter gray tick labels
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: `Latest Model Performance (v${latestEvaluated.version_number})`
                        }
                    }
                }
            });
        }

    function showError(message) {
        console.error(message);
        // Could add a toast notification here
    }

        // Backfill functions
        async function checkEligibleCount() {
            const countElement = document.getElementById('eligibleCount');
            
            try {
                countElement.textContent = 'Checking...';
                
                const response = await fetch('/api/ml-hunt-comparison/eligible-count');
                const data = await response.json();
                
                if (data.success) {
                    const countText = data.count === 0 
                        ? 'No eligible articles found' 
                        : `${data.count} article${data.count === 1 ? '' : 's'} eligible for processing`;
                    countElement.textContent = countText;
                } else {
                    countElement.textContent = 'Error checking eligible articles';
                }
            } catch (error) {
                console.error('Error checking eligible count:', error);
                countElement.textContent = 'Error checking eligible articles';
        }
        }

        async function startBackfill() {
        const btn = document.getElementById('processAllBtn');
        const progressSection = document.getElementById('progressSection');
        const resultsSection = document.getElementById('resultsSection');
        const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
        const resultsContent = document.getElementById('resultsContent');
            
            // Disable button and show progress
            btn.disabled = true;
            btn.textContent = 'Processing...';
        progressSection.classList.remove('hidden');
        resultsSection.classList.add('hidden');
        progressBar.style.width = '0%';
            progressText.textContent = 'Starting backfill...';
            
            try {
                const response = await fetch('/api/ml-hunt-comparison/backfill', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        min_hunt_score: 50.0,
                        min_confidence: 0.7
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.results) {
                    const results = data.results;
                    
                    // Update progress to 100%
                progressBar.style.width = '100%';
                    progressText.textContent = 'Complete!';
                    
                    // Show results
                resultsSection.classList.remove('hidden');
                resultsContent.innerHTML = `
                    <div class="text-green-600 font-semibold">‚úÖ Backfill Complete</div>
                    <div class="mt-2">
                        <p><strong>Total Eligible:</strong> ${results.total_eligible}</p>
                        <p><strong>Processed:</strong> ${results.processed}</p>
                        <p><strong>Successful:</strong> ${results.successful}</p>
                        <p><strong>Failed:</strong> ${results.failed}</p>
                    </div>
                    `;
                    
                    // Reload data
                    setTimeout(() => {
                        loadInitialData();
                        checkEligibleCount();
                    }, 1000);
                    
                } else {
                    throw new Error(data.error || 'Backfill failed');
                }
                
            } catch (error) {
                console.error('Error during backfill:', error);
            resultsSection.classList.remove('hidden');
            resultsContent.innerHTML = `
                <div class="text-red-600 font-semibold">‚ùå Backfill Failed</div>
                <div class="mt-2 text-red-600">${error.message}</div>
                `;
            } finally {
                // Re-enable button
                btn.disabled = false;
                btn.textContent = 'Process All Eligible Articles';
                setTimeout(() => {
                progressSection.classList.add('hidden');
            }, 3000);
        }
    }

    // Evaluation functions
    async function runEvaluation() {
        const btn = document.getElementById('evaluateModelBtn');
        const progressSection = document.getElementById('evalProgressSection');
        const resultsSection = document.getElementById('evalResultsSection');
        const progressBar = document.getElementById('evalProgressBar');
        const progressText = document.getElementById('evalProgressText');
        const resultsContent = document.getElementById('evalResultsContent');
        const statusElement = document.getElementById('evalStatus');
        
        // Disable button and show progress
        btn.disabled = true;
        btn.textContent = 'Evaluating...';
        progressSection.classList.remove('hidden');
        resultsSection.classList.add('hidden');
        progressBar.style.width = '0%';
        progressText.textContent = 'Starting evaluation...';
        statusElement.textContent = 'Evaluating model on test set...';
        
        try {
            // Simulate progress
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += Math.random() * 20;
                if (progress > 90) progress = 90;
                progressBar.style.width = progress + '%';
            }, 200);
            
            const response = await fetch('/api/model/evaluate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            clearInterval(progressInterval);
            progressBar.style.width = '100%';
            progressText.textContent = 'Complete!';
            
            const data = await response.json();
            
            if (data.success) {
                // Show results
                resultsSection.classList.remove('hidden');
                resultsContent.innerHTML = generateEvaluationResults(data);
                
                statusElement.textContent = `Evaluation complete - Accuracy: ${(data.metrics.accuracy * 100).toFixed(1)}%`;
                
                // Reload data to update charts
                setTimeout(() => {
                    loadInitialData();
                }, 1000);
                
            } else {
                throw new Error(data.message || 'Evaluation failed');
            }
            
        } catch (error) {
            console.error('Error during evaluation:', error);
            resultsSection.classList.remove('hidden');
            resultsContent.innerHTML = `
                <div class="text-red-600 font-semibold">‚ùå Evaluation Failed</div>
                <div class="mt-2 text-red-600">${error.message}</div>
            `;
            statusElement.textContent = 'Evaluation failed';
        } finally {
            // Re-enable button
            btn.disabled = false;
            btn.textContent = 'Evaluate Current Model';
            setTimeout(() => {
                progressSection.classList.add('hidden');
            }, 3000);
        }
    }

    function generateEvaluationResults(data) {
        const metrics = data.metrics;
        const misclassified = data.misclassified_chunks || [];
        const summary = data.eval_summary || {};
        
        return `
            <div class="space-y-4">
                <div class="text-green-600 font-semibold text-lg">‚úÖ Evaluation Complete</div>
                
                <!-- Overall Metrics -->
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">Accuracy</div>
                        <div class="text-2xl font-bold text-blue-600">${(metrics.accuracy * 100).toFixed(1)}%</div>
                    </div>
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">Avg Confidence</div>
                        <div class="text-2xl font-bold text-green-600">${(metrics.avg_confidence * 100).toFixed(1)}%</div>
                    </div>
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">Total Chunks</div>
                        <div class="text-2xl font-bold text-purple-600">${metrics.total_chunks}</div>
                    </div>
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">Misclassified</div>
                        <div class="text-2xl font-bold text-red-600">${metrics.misclassified_count}</div>
                    </div>
                </div>
                
                <!-- Per-Class Metrics -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="bg-white dark:bg-gray-600 p-4 rounded">
                        <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Huntable Class</h4>
                        <div class="space-y-1 text-sm">
                            <div>Precision: <span class="font-mono">${(metrics.precision_huntable * 100).toFixed(1)}%</span></div>
                            <div>Recall: <span class="font-mono">${(metrics.recall_huntable * 100).toFixed(1)}%</span></div>
                            <div>F1 Score: <span class="font-mono">${(metrics.f1_score_huntable * 100).toFixed(1)}%</span></div>
                        </div>
                    </div>
                    <div class="bg-white dark:bg-gray-600 p-4 rounded">
                        <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Not Huntable Class</h4>
                        <div class="space-y-1 text-sm">
                            <div>Precision: <span class="font-mono">${(metrics.precision_not_huntable * 100).toFixed(1)}%</span></div>
                            <div>Recall: <span class="font-mono">${(metrics.recall_not_huntable * 100).toFixed(1)}%</span></div>
                            <div>F1 Score: <span class="font-mono">${(metrics.f1_score_not_huntable * 100).toFixed(1)}%</span></div>
                        </div>
                    </div>
                </div>
                
                <!-- Confusion Matrix -->
                ${metrics.confusion_matrix ? `
                <div class="bg-white dark:bg-gray-600 p-4 rounded">
                    <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Confusion Matrix</h4>
                    <div class="grid grid-cols-3 gap-2 text-sm">
                        <div></div>
                        <div class="text-center font-semibold">Predicted Not Huntable</div>
                        <div class="text-center font-semibold">Predicted Huntable</div>
                        <div class="font-semibold">Actual Not Huntable</div>
                        <div class="text-center bg-green-100 dark:bg-green-800 p-2 rounded">${metrics.confusion_matrix.true_negative}</div>
                        <div class="text-center bg-red-100 dark:bg-red-800 p-2 rounded">${metrics.confusion_matrix.false_positive}</div>
                        <div class="font-semibold">Actual Huntable</div>
                        <div class="text-center bg-red-100 dark:bg-red-800 p-2 rounded">${metrics.confusion_matrix.false_negative}</div>
                        <div class="text-center bg-green-100 dark:bg-green-800 p-2 rounded">${metrics.confusion_matrix.true_positive}</div>
                    </div>
                </div>
                ` : ''}
                
                <!-- Misclassified Chunks -->
                ${misclassified.length > 0 ? `
                <div class="bg-white dark:bg-gray-600 p-4 rounded">
                    <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Sample Misclassified Chunks (${misclassified.length} shown)</h4>
                    <div class="space-y-2 max-h-40 overflow-y-auto">
                        ${misclassified.slice(0, 5).map(chunk => `
                            <div class="text-xs bg-gray-100 dark:bg-gray-700 p-2 rounded">
                                <div class="font-semibold">ID ${chunk.annotation_id}: ${chunk.true_label} ‚Üí ${chunk.predicted_label} (${(chunk.confidence * 100).toFixed(1)}%)</div>
                                <div class="text-gray-600 dark:text-gray-300 mt-1">${chunk.chunk_preview}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}
            </div>
        `;
    }

    async function checkEvaluationStatus() {
        const statusElement = document.getElementById('evalStatus');
        
        try {
            statusElement.textContent = 'Checking evaluation status...';
            
            const response = await fetch('/api/model/versions');
            const data = await response.json();
            
            if (data.success && data.versions.length > 0) {
                const latestVersion = data.versions[0];
                if (latestVersion.has_evaluation) {
                    const evalDate = new Date(latestVersion.evaluated_at).toLocaleDateString();
                    statusElement.textContent = `Last evaluated: ${evalDate} - Accuracy: ${(latestVersion.eval_accuracy * 100).toFixed(1)}%`;
                } else {
                    statusElement.textContent = 'Model not yet evaluated on test set';
                }
            } else {
                statusElement.textContent = 'No model versions found';
            }
        } catch (error) {
            console.error('Error checking evaluation status:', error);
            statusElement.textContent = 'Error checking status';
        }
    }

    // Model Retraining functions
    async function retrainModel() {
        const btn = document.getElementById('retrainModelBtn');
        const progressSection = document.getElementById('retrainProgressSection');
        const resultsSection = document.getElementById('retrainResultsSection');
        const progressBar = document.getElementById('retrainProgressBar');
        const progressText = document.getElementById('retrainProgressText');
        const resultsContent = document.getElementById('retrainResultsContent');
        
        // Disable button and show progress
        btn.disabled = true;
        btn.textContent = 'Retraining...';
        progressSection.classList.remove('hidden');
        resultsSection.classList.add('hidden');
        progressBar.style.width = '0%';
        progressText.textContent = 'Starting retraining...';
        
        try {
            const response = await fetch('/api/model/retrain', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Update progress to 100%
                progressBar.style.width = '100%';
                progressText.textContent = 'Complete!';
                
                // Show results
                resultsSection.classList.remove('hidden');
                resultsContent.innerHTML = `
                    <div class="text-green-600 font-semibold">‚úÖ Retraining Complete</div>
                    <div class="mt-2">
                        <p><strong>New Model Version:</strong> v${data.new_version}</p>
                        <p><strong>Training Accuracy:</strong> ${(data.training_accuracy * 100).toFixed(1)}%</p>
                        <p><strong>Validation Accuracy:</strong> ${(data.validation_accuracy * 100).toFixed(1)}%</p>
                        <p><strong>Training Duration:</strong> ${data.training_duration}</p>
                        <p><strong>Training Samples:</strong> ${data.training_samples}</p>
                    </div>
                `;
                
                // Update status
                document.getElementById('retrainingStatus').textContent = 
                    `Current model: v${data.new_version} (${(data.validation_accuracy * 100).toFixed(1)}% accuracy)`;
                
                // Reload data
                setTimeout(() => {
                    loadInitialData();
                }, 1000);
                
            } else {
                throw new Error(data.message || 'Retraining failed');
            }
            
        } catch (error) {
            console.error('Error during retraining:', error);
            resultsSection.classList.remove('hidden');
            resultsContent.innerHTML = `
                <div class="text-red-600 font-semibold">‚ùå Retraining Failed</div>
                <div class="mt-2 text-red-600">${error.message}</div>
            `;
        } finally {
            // Re-enable button
            btn.disabled = false;
            btn.textContent = 'Retrain Model';
            setTimeout(() => {
                progressSection.classList.add('hidden');
            }, 3000);
        }
    }

    async function refreshRetrainingStatus() {
        const statusElement = document.getElementById('retrainingStatus');
        const feedbackElement = document.getElementById('feedbackCount');
        
        try {
            statusElement.textContent = 'Checking...';
            feedbackElement.textContent = 'Loading...';
            
            // Get latest model version and feedback count
            const [versionsResponse, feedbackResponse] = await Promise.all([
                fetch('/api/model/versions'),
                fetch('/api/model/feedback-count')
            ]);
            
            const versionsData = await versionsResponse.json();
            const feedbackData = await feedbackResponse.json();
            
            if (versionsData.success && versionsData.versions.length > 0) {
                const latest = versionsData.versions[0]; // Already sorted by version number
                const accuracy = latest.eval_accuracy ? (latest.eval_accuracy * 100).toFixed(1) : 'N/A';
                statusElement.textContent = `v${latest.version_number} (${accuracy}% accuracy)`;
            } else {
                statusElement.textContent = 'None';
            }
            
            if (feedbackData.success) {
                feedbackElement.textContent = feedbackData.count.toLocaleString();
            } else {
                feedbackElement.textContent = 'Error';
            }
            
        } catch (error) {
            console.error('Error refreshing retraining status:', error);
            statusElement.textContent = 'Error';
            feedbackElement.textContent = 'Error';
        }
    }

    // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            loadInitialData();
            checkEligibleCount();
        checkEvaluationStatus();
        refreshRetrainingStatus();
        
        // Add event listeners
        document.getElementById('processAllBtn').addEventListener('click', startBackfill);
        document.getElementById('refreshCountBtn').addEventListener('click', checkEligibleCount);
        document.getElementById('evaluateModelBtn').addEventListener('click', runEvaluation);
        document.getElementById('refreshEvalBtn').addEventListener('click', checkEvaluationStatus);
        document.getElementById('retrainModelBtn').addEventListener('click', retrainModel);
        document.getElementById('refreshRetrainBtn').addEventListener('click', refreshRetrainingStatus);
        });
    </script>
{% endblock %}
