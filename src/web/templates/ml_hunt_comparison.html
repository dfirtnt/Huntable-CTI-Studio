{% extends "base.html" %}

{% block title %}ML vs Hunt Scoring Comparison - Huntable CTI Scraper{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <div class="mb-8">
        <h1 class="text-3xl font-bold text-gray-900 dark:text-white mb-2">üìä ML vs Hunt Scoring Comparison</h1>
        <p class="text-gray-600 dark:text-gray-400">Compare ML model predictions with Hunt scoring system for articles with hunt_score > 50</p>
    </div>
    
    <!-- Stats Grid -->
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-medium text-gray-900 dark:text-white mb-2">Total Model Versions</h3>
            <div class="text-3xl font-bold text-blue-600" id="totalModelVersions">-</div>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-medium text-gray-900 dark:text-white mb-2">Total Chunk Analyses</h3>
            <div class="text-3xl font-bold text-blue-600" id="totalChunkAnalyses">-</div>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-medium text-gray-900 dark:text-white mb-2">Average Accuracy</h3>
            <div class="text-3xl font-bold text-blue-600" id="averageAccuracy">-</div>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-medium text-gray-900 dark:text-white mb-2">Last Updated</h3>
            <div class="text-3xl font-bold text-blue-600" id="lastUpdated">-</div>
        </div>
    </div>

    <!-- Model Retraining Section -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-4">üîÑ Model Retraining</h2>
        <p class="text-gray-600 dark:text-gray-400 mb-4">Retrain the ML model with user feedback from chunk debugging to improve performance</p>
        
        <div class="flex justify-between items-center">
            <div class="text-lg font-medium text-gray-900 dark:text-white">
                <div>Current model: <span id="retrainingStatus">v24 (79.4% accuracy)</span></div>
                <div class="text-sm text-gray-500 dark:text-gray-400 mt-1">
                    Available feedback: <span id="feedbackCount">-</span> user classifications and/or corrections
                </div>
            </div>
            <div class="flex gap-3">
                <button id="retrainModelBtn" 
                        class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2">
                    Retrain Model
                </button>
                <button id="refreshRetrainBtn" 
                        class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                    Refresh Status
                </button>
            </div>
        </div>
        
        <!-- Retraining Progress Bar -->
        <div id="retrainProgressSection" class="hidden mt-4">
            <div class="w-full bg-gray-200 rounded-full h-2">
                <div id="retrainProgressBar" class="bg-purple-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <div id="retrainProgressText" class="text-sm text-gray-600 mt-2">Retraining...</div>
        </div>
        
        <!-- Retraining Results -->
        <div id="retrainResultsSection" class="hidden mt-4 p-4 bg-gray-50 dark:bg-gray-700 rounded-md">
            <div id="retrainResultsContent"></div>
        </div>
    </div>

    
    <!-- Model Evaluation Section -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-4">üß™ Model Evaluation on Test Set</h2>
        <p class="text-gray-600 dark:text-gray-400 mb-4">Evaluate current model performance on annotated chunks from article_annotations table</p>
        
        <div class="flex justify-between items-center">
            <div class="text-lg font-medium text-gray-900 dark:text-white">
                <div><span id="evalStatus">Ready to evaluate current model</span></div>
                <div class="text-sm text-gray-500 dark:text-gray-400 mt-1">
                    Test set: <span id="evalChunkCount">Loading...</span> annotated chunks
                </div>
            </div>
            <div class="flex gap-3">
                <button id="evaluateModelBtn" 
                        class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                    Evaluate Current Model
                </button>
                <button id="refreshEvalStatusBtn" 
                        class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                    Refresh Status
                </button>
            </div>
        </div>
        
        <!-- Evaluation Progress -->
        <div id="evalProgressSection" class="hidden mt-4">
            <div class="w-full bg-gray-200 rounded-full h-2">
                <div id="evalProgressBar" class="bg-green-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <div id="evalProgressText" class="text-sm text-gray-600 mt-2">Evaluating model...</div>
        </div>
        
        <!-- Evaluation Results -->
        <div id="evalResultsSection" class="hidden mt-4 p-4 bg-gray-50 dark:bg-gray-700 rounded-md">
            <div id="evalResultsContent"></div>
        </div>
    </div>
    
    <!-- Charts Section -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">üìà Classification Trends</h3>
            <canvas id="distributionChart" width="400" height="200"></canvas>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">üìä Model Performance Summary</h3>
            <div id="modelPerformanceSummary" class="text-center text-gray-500 dark:text-gray-400">
                <p>Run model evaluation to see performance metrics</p>
            </div>
        </div>
    </div>
    
    <!-- Evaluation Metrics Charts -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">üß™ Evaluation Accuracy Over Time</h3>
            <canvas id="evalAccuracyChart" width="400" height="200"></canvas>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">üìä Evaluation Metrics Comparison</h3>
            <canvas id="evalMetricsChart" width="400" height="200"></canvas>
        </div>
    </div>
    
    <!-- Detailed Results Table -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow">
        <div class="px-6 py-4 border-b border-gray-200 dark:border-gray-700">
            <h3 class="text-lg font-semibold text-gray-900 dark:text-white">üìã Detailed Comparison Results</h3>
        </div>
        <div class="overflow-x-auto">
            <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                <thead class="bg-gray-50 dark:bg-gray-700">
                    <tr>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Article</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Hunt Score</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">ML Prediction</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Match</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Confidence</th>
                    </tr>
                </thead>
                <tbody id="resultsTableBody" class="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                    <!-- Results will be populated by JavaScript -->
                </tbody>
            </table>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let currentData = {
            stats: [],
            results: [],
        summary: null,
        modelVersions: []
        };

        function getAlignedVersionNumbers() {
            const classificationVersions = (currentData.timeline || [])
                .map(item => item.version_number);
            const evaluatedVersions = currentData.modelVersions
                .filter(v => v.has_evaluation)
                .map(v => v.version_number);
            const combinedSet = new Set([...classificationVersions, ...evaluatedVersions]);
            const combined = Array.from(combinedSet).sort((a, b) => a - b);
            if (combined.length <= 9) {
                return combined;
            }
            return combined.slice(-9);
        }

        // Chart instances for proper cleanup
        let distributionChart = null;
        let evalAccuracyChart = null;
        let evalMetricsChart = null;

        // Load initial data
        async function loadInitialData() {
            try {
                // Load summary
                const summaryResponse = await fetch('/api/ml-hunt-comparison/summary');
                const summaryData = await summaryResponse.json();
                if (summaryData.success) {
                    currentData.summary = summaryData.summary;
                    updateSummaryStats();
                }

                // Load stats
                const statsResponse = await fetch('/api/ml-hunt-comparison/stats');
                const statsData = await statsResponse.json();
                if (statsData.success) {
                    currentData.stats = statsData.stats;
            }
            
            // Load model versions for evaluation metrics
            const versionsResponse = await fetch('/api/model/versions');
            const versionsData = await versionsResponse.json();
            if (versionsData.success) {
                currentData.modelVersions = versionsData.versions;
            }

            // Load classification timeline
            const timelineResponse = await fetch('/api/model/classification-timeline');
            const timelineData = await timelineResponse.json();
            if (timelineData.success) {
                currentData.timeline = timelineData.timeline;
            }
            
            // Load evaluation chunk count
            const evalCountResponse = await fetch('/api/model/eval-chunk-count');
            const evalCountData = await evalCountResponse.json();
            if (evalCountData.success) {
                document.getElementById('evalChunkCount').textContent = evalCountData.count.toLocaleString();
            } else {
                document.getElementById('evalChunkCount').textContent = 'Unknown';
            }
            
            // Check feedback count and disable retrain button if no feedback available
            const feedbackResponse = await fetch('/api/model/feedback-count');
            const feedbackData = await feedbackResponse.json();
            if (feedbackData.success && feedbackData.count === 0) {
                const retrainBtn = document.getElementById('retrainModelBtn');
                retrainBtn.disabled = true;
                retrainBtn.classList.add('opacity-50', 'cursor-not-allowed');
                retrainBtn.title = 'No feedback available for retraining';
            }
            
                    updateCharts();
            } catch (error) {
                console.error('Error loading initial data:', error);
                showError('Failed to load initial data');
            }
        }

        function updateSummaryStats() {
            const summary = currentData.summary;
        document.getElementById('totalModelVersions').textContent = summary.total_model_versions;
        document.getElementById('totalChunkAnalyses').textContent = summary.total_chunk_analyses.toLocaleString();
            
        if (summary.overall_stats && summary.overall_stats.length > 0) {
                const avgAccuracy = summary.overall_stats.reduce((sum, stat) => sum + stat.accuracy, 0) / summary.overall_stats.length;
            document.getElementById('averageAccuracy').textContent = (avgAccuracy * 100).toFixed(1) + '%';
            }
            
            if (summary.last_updated) {
                const date = new Date(summary.last_updated);
                document.getElementById('lastUpdated').textContent = date.toLocaleDateString();
            }
        }

        function updateCharts() {
        updateDistributionChart();
        updateModelPerformanceSummary();
        updateEvaluationCharts();
    }

    function updateModelPerformanceSummary() {
        const summaryElement = document.getElementById('modelPerformanceSummary');
        
        const versionNumbers = getAlignedVersionNumbers();

        // Get the latest aligned evaluated version
        const evaluatedVersionMap = new Map(
            currentData.modelVersions
                .filter(v => v.has_evaluation)
                .map(v => [v.version_number, v])
        );

        const latestVersionNumber = versionNumbers[versionNumbers.length - 1];
        const latestEvaluated = evaluatedVersionMap.get(latestVersionNumber);
        
        if (!latestEvaluated) {
            summaryElement.innerHTML = '<p class="text-gray-500 dark:text-gray-400">Run model evaluation to see performance metrics</p>';
            return;
        }
        
        const evalDate = new Date(latestEvaluated.evaluated_at).toLocaleDateString();
        summaryElement.innerHTML = `
            <div class="space-y-2">
                <div class="text-lg font-semibold text-gray-900 dark:text-white">
                    Model v${latestEvaluated.version_number}
                </div>
                <div class="text-2xl font-bold text-blue-600">
                    ${(latestEvaluated.eval_accuracy * 100).toFixed(1)}%
                </div>
                <div class="text-sm text-gray-600 dark:text-gray-400">
                    Test Accuracy (160 chunks)
                </div>
                <div class="text-xs text-gray-500 dark:text-gray-500">
                    Evaluated: ${evalDate}
                </div>
                <div class="grid grid-cols-2 gap-2 text-xs mt-2">
                    <div>Precision (H): ${((latestEvaluated.eval_precision_huntable || 0) * 100).toFixed(1)}%</div>
                    <div>Recall (H): ${((latestEvaluated.eval_recall_huntable || 0) * 100).toFixed(1)}%</div>
                    <div>Precision (NH): ${((latestEvaluated.eval_precision_not_huntable || 0) * 100).toFixed(1)}%</div>
                    <div>Recall (NH): ${((latestEvaluated.eval_recall_not_huntable || 0) * 100).toFixed(1)}%</div>
                </div>
            </div>
        `;
    }

    function updateDistributionChart() {
        const ctx = document.getElementById('distributionChart').getContext('2d');
        
        // Destroy existing chart if it exists
        if (distributionChart) {
            distributionChart.destroy();
            distributionChart = null;
        }
        
        const selectedVersions = getAlignedVersionNumbers();

        if (selectedVersions.length === 0) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillText('No evaluation data available', 10, 50);
            return;
        }

        const timelineMap = new Map();
        (currentData.timeline || []).forEach(item => {
            timelineMap.set(item.version_number, item);
        });
        const labels = selectedVersions.map(v => `v${v}`);

        const missingClassification = new Set();

        const getPercentage = (versionNumber, key) => {
            const timelineEntry = timelineMap.get(versionNumber);
            if (!timelineEntry) {
                missingClassification.add(versionNumber);
                return 0;
            }
            const value = timelineEntry[key];
            return value != null ? value : 0;
        };

        const agreementData = selectedVersions.map(v => getPercentage(v, 'agreement'));
        const mlOnlyData = selectedVersions.map(v => getPercentage(v, 'ml_only'));
        const huntOnlyData = selectedVersions.map(v => getPercentage(v, 'hunt_only'));
        const neitherData = selectedVersions.map(v => getPercentage(v, 'neither'));
            
            distributionChart = new Chart(ctx, {
            type: 'line',
                data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Agreement (Both Huntable)',
                        data: agreementData,
                        borderColor: 'rgba(75, 192, 192, 1)',
                        backgroundColor: 'rgba(75, 192, 192, 0.1)',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'ML Only (ML Huntable)',
                        data: mlOnlyData,
                        borderColor: 'rgba(54, 162, 235, 1)',
                        backgroundColor: 'rgba(54, 162, 235, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Hunt Only (Hunt Huntable)',
                        data: huntOnlyData,
                        borderColor: 'rgba(255, 205, 86, 1)',
                        backgroundColor: 'rgba(255, 205, 86, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Neither (Not Huntable)',
                        data: neitherData,
                        borderColor: 'rgba(255, 99, 132, 1)',
                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    }
                ]
                },
                options: {
                    responsive: true,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        title: {
                            display: true,
                            text: 'Percentage of Chunks'
                        },
                        ticks: {
                            callback: function(value) {
                                return value.toFixed(1) + '%';
                            }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Model Version'
                        }
                }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Classification Trends Across Model Versions'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            afterBody: function(context) {
                                const dataIndex = context[0].dataIndex;
                                const versionNumber = selectedVersions[dataIndex];
                                const item = timelineMap.get(versionNumber);
                                if (!item || missingClassification.has(versionNumber)) {
                                    return [`v${versionNumber}: No classification data`];
                                }
                                return [
                                    `Total Chunks: ${item.total_chunks.toLocaleString()}`,
                                    `Accuracy: ${(item.accuracy * 100).toFixed(1)}%`,
                                    `Trained: ${new Date(item.trained_at).toLocaleDateString()}`
                                ];
                            }
                        }
                        }
                    }
                }
            });
    }

    function updateEvaluationCharts() {
        updateEvalAccuracyChart();
        updateEvalMetricsChart();
    }

    function updateEvalAccuracyChart() {
        const ctx = document.getElementById('evalAccuracyChart').getContext('2d');
        
        // Destroy existing chart if it exists
        if (evalAccuracyChart) {
            evalAccuracyChart.destroy();
            evalAccuracyChart = null;
        }
        
        const timelineVersions = getAlignedVersionNumbers();
        const evaluatedVersionMap = new Map(
            currentData.modelVersions
                .filter(v => v.has_evaluation)
                .map(v => [v.version_number, v])
        );

        if (timelineVersions.length === 0) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillText('No timeline data available', 10, 50);
            return;
        }
        
        const accuracyPoints = timelineVersions.map(versionNumber => {
            const version = evaluatedVersionMap.get(versionNumber);
            return version && version.eval_accuracy != null
                ? (version.eval_accuracy * 100)
                : null;
        });

        const evaluatedCount = accuracyPoints.filter(value => value !== null).length;

        if (evaluatedCount === 0) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillText('No evaluation data available', 10, 50);
            return;
        }
        
            evalAccuracyChart = new Chart(ctx, {
            type: 'line',
                data: {
                labels: timelineVersions.map(v => `v${v}`),
                    datasets: [{
                    label: 'Evaluation Accuracy %',
                    data: accuracyPoints,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.1,
                    spanGaps: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Model Performance on Test Set (160 chunks)'
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const labelVersion = timelineVersions[context.dataIndex];
                                if (context.parsed.y === null) {
                                    return `v${labelVersion}: No evaluation data`;
                                }
                                return `v${labelVersion}: ${context.parsed.y.toFixed(1)}%`;
                            }
                        }
                    }
                }
                }
            });
        }

    function updateEvalMetricsChart() {
        const ctx = document.getElementById('evalMetricsChart').getContext('2d');
        
        // Destroy existing chart if it exists
        if (evalMetricsChart) {
            evalMetricsChart.destroy();
            evalMetricsChart = null;
        }
        
        // Get the latest evaluated version
        const latestEvaluated = currentData.modelVersions
            .filter(v => v.has_evaluation)
            .sort((a, b) => b.version_number - a.version_number)[0];
        
        if (!latestEvaluated) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillText('No evaluation data available', 10, 50);
            return;
        }
            
            evalMetricsChart = new Chart(ctx, {
            type: 'radar',
                data: {
                labels: ['Accuracy', 'Precision (Huntable)', 'Recall (Huntable)', 'F1 (Huntable)'],
                    datasets: [{
                    label: `Model v${latestEvaluated.version_number}`,
                    data: [
                        latestEvaluated.eval_accuracy * 100,
                        (latestEvaluated.eval_precision_huntable || 0) * 100,
                        (latestEvaluated.eval_recall_huntable || 0) * 100,
                        (latestEvaluated.eval_f1_score_huntable || 0) * 100
                    ],
                    borderColor: 'rgba(54, 162, 235, 1)',
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                    r: {
                        beginAtZero: true,
                        max: 100,
                        grid: {
                            color: 'rgba(156, 163, 175, 0.3)', // Lighter gray grid lines
                        },
                        angleLines: {
                            color: 'rgba(156, 163, 175, 0.3)', // Lighter gray angle lines
                        },
                        pointLabels: {
                            color: 'rgba(156, 163, 175, 0.8)', // Lighter gray labels
                        },
                        ticks: {
                            color: 'rgba(156, 163, 175, 0.6)', // Lighter gray tick labels
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: `Latest Model Performance (v${latestEvaluated.version_number})`
                        }
                    }
                }
            });
        }

    function showError(message) {
        console.error(message);
        // Could add a toast notification here
    }

        // Backfill functions
        async function checkEligibleCount() {
            const countElement = document.getElementById('eligibleCount');
            
            try {
                countElement.textContent = 'Checking...';
                
                const response = await fetch('/api/ml-hunt-comparison/eligible-count');
                const data = await response.json();
                
                if (data.success) {
                    const countText = data.count === 0 
                        ? 'No eligible articles found' 
                        : `${data.count} article${data.count === 1 ? '' : 's'} eligible for processing`;
                    countElement.textContent = countText;
                } else {
                    countElement.textContent = 'Error checking eligible articles';
                }
            } catch (error) {
                console.error('Error checking eligible count:', error);
                countElement.textContent = 'Error checking eligible articles';
        }
        }


    // Evaluation functions
    async function runEvaluation() {
        const btn = document.getElementById('evaluateModelBtn');
        const progressSection = document.getElementById('evalProgressSection');
        const resultsSection = document.getElementById('evalResultsSection');
        const progressBar = document.getElementById('evalProgressBar');
        const progressText = document.getElementById('evalProgressText');
        const resultsContent = document.getElementById('evalResultsContent');
        const statusElement = document.getElementById('evalStatus');
        
        // Disable button and show progress
        btn.disabled = true;
        btn.textContent = 'Evaluating...';
        progressSection.classList.remove('hidden');
        resultsSection.classList.add('hidden');
        progressBar.style.width = '0%';
        progressText.textContent = 'Starting evaluation...';
        statusElement.textContent = 'Evaluating model on test set...';
        
        try {
            // Simulate progress
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += Math.random() * 20;
                if (progress > 90) progress = 90;
                progressBar.style.width = progress + '%';
            }, 200);
            
            const response = await fetch('/api/model/evaluate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            clearInterval(progressInterval);
            progressBar.style.width = '100%';
            progressText.textContent = 'Complete!';
            
            const data = await response.json();
            
            if (data.success) {
                // Show results
                resultsSection.classList.remove('hidden');
                resultsContent.innerHTML = generateEvaluationResults(data);
                
                statusElement.textContent = `Evaluation complete - Accuracy: ${(data.metrics.accuracy * 100).toFixed(1)}%`;
                
                // Reload data to update charts
                setTimeout(() => {
                    loadInitialData();
                }, 1000);
                
            } else {
                throw new Error(data.message || 'Evaluation failed');
            }
            
        } catch (error) {
            console.error('Error during evaluation:', error);
            resultsSection.classList.remove('hidden');
            resultsContent.innerHTML = `
                <div class="text-red-600 font-semibold">‚ùå Evaluation Failed</div>
                <div class="mt-2 text-red-600">${error.message}</div>
            `;
            statusElement.textContent = 'Evaluation failed';
        } finally {
            // Re-enable button
            btn.disabled = false;
            btn.textContent = 'Evaluate Current Model';
            setTimeout(() => {
                progressSection.classList.add('hidden');
            }, 3000);
        }
    }

    function generateEvaluationResults(data) {
        const metrics = data.metrics;
        const misclassified = data.misclassified_chunks || [];
        const summary = data.eval_summary || {};
        
        return `
            <div class="space-y-4">
                <div class="text-green-600 font-semibold text-lg">‚úÖ Evaluation Complete</div>
                
                <!-- Overall Metrics -->
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">Accuracy</div>
                        <div class="text-2xl font-bold text-blue-600">${(metrics.accuracy * 100).toFixed(1)}%</div>
                    </div>
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">Avg Confidence</div>
                        <div class="text-2xl font-bold text-green-600">${(metrics.avg_confidence * 100).toFixed(1)}%</div>
                    </div>
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">Total Chunks</div>
                        <div class="text-2xl font-bold text-purple-600">${metrics.total_chunks}</div>
                    </div>
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">Misclassified</div>
                        <div class="text-2xl font-bold text-red-600">${metrics.misclassified_count}</div>
                    </div>
                </div>
                
                <!-- Per-Class Metrics -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="bg-white dark:bg-gray-600 p-4 rounded">
                        <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Huntable Class</h4>
                        <div class="space-y-1 text-sm">
                            <div>Precision: <span class="font-mono">${(metrics.precision_huntable * 100).toFixed(1)}%</span></div>
                            <div>Recall: <span class="font-mono">${(metrics.recall_huntable * 100).toFixed(1)}%</span></div>
                            <div>F1 Score: <span class="font-mono">${(metrics.f1_score_huntable * 100).toFixed(1)}%</span></div>
                        </div>
                    </div>
                    <div class="bg-white dark:bg-gray-600 p-4 rounded">
                        <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Not Huntable Class</h4>
                        <div class="space-y-1 text-sm">
                            <div>Precision: <span class="font-mono">${(metrics.precision_not_huntable * 100).toFixed(1)}%</span></div>
                            <div>Recall: <span class="font-mono">${(metrics.recall_not_huntable * 100).toFixed(1)}%</span></div>
                            <div>F1 Score: <span class="font-mono">${(metrics.f1_score_not_huntable * 100).toFixed(1)}%</span></div>
                        </div>
                    </div>
                </div>
                
                <!-- Confusion Matrix -->
                ${metrics.confusion_matrix ? `
                <div class="bg-white dark:bg-gray-600 p-4 rounded">
                    <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Confusion Matrix</h4>
                    <div class="grid grid-cols-3 gap-2 text-sm">
                        <div></div>
                        <div class="text-center font-semibold">Predicted Not Huntable</div>
                        <div class="text-center font-semibold">Predicted Huntable</div>
                        <div class="font-semibold">Actual Not Huntable</div>
                        <div class="text-center bg-green-100 dark:bg-green-800 p-2 rounded">${metrics.confusion_matrix.true_negative}</div>
                        <div class="text-center bg-red-100 dark:bg-red-800 p-2 rounded">${metrics.confusion_matrix.false_positive}</div>
                        <div class="font-semibold">Actual Huntable</div>
                        <div class="text-center bg-red-100 dark:bg-red-800 p-2 rounded">${metrics.confusion_matrix.false_negative}</div>
                        <div class="text-center bg-green-100 dark:bg-green-800 p-2 rounded">${metrics.confusion_matrix.true_positive}</div>
                    </div>
                </div>
                ` : ''}
                
                <!-- Misclassified Chunks -->
                ${misclassified.length > 0 ? `
                <div class="bg-white dark:bg-gray-600 p-4 rounded">
                    <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Sample Misclassified Chunks (${misclassified.length} shown)</h4>
                    <div class="space-y-2 max-h-40 overflow-y-auto">
                        ${misclassified.slice(0, 5).map(chunk => `
                            <div class="text-xs bg-gray-100 dark:bg-gray-700 p-2 rounded">
                                <div class="font-semibold">ID ${chunk.annotation_id}: ${chunk.true_label} ‚Üí ${chunk.predicted_label} (${(chunk.confidence * 100).toFixed(1)}%)</div>
                                <div class="text-gray-600 dark:text-gray-300 mt-1">${chunk.chunk_preview}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}
            </div>
        `;
    }

    async function checkEvaluationStatus() {
        const statusElement = document.getElementById('evalStatus');
        
        try {
            statusElement.textContent = 'Checking evaluation status...';
            
            const response = await fetch('/api/model/versions');
            const data = await response.json();
            
            if (data.success && data.versions.length > 0) {
                const latestVersion = data.versions[0];
                if (latestVersion.has_evaluation) {
                    const evalDate = new Date(latestVersion.evaluated_at).toLocaleDateString();
                    statusElement.textContent = `Last evaluated: ${evalDate} - Accuracy: ${(latestVersion.eval_accuracy * 100).toFixed(1)}%`;
                } else {
                    statusElement.textContent = 'Model not yet evaluated on test set';
                }
            } else {
                statusElement.textContent = 'No model versions found';
            }
        } catch (error) {
            console.error('Error checking evaluation status:', error);
            statusElement.textContent = 'Error checking status';
        }
    }

    // Model Retraining functions
    async function retrainModel() {
        const btn = document.getElementById('retrainModelBtn');
        const progressSection = document.getElementById('retrainProgressSection');
        const resultsSection = document.getElementById('retrainResultsSection');
        const progressBar = document.getElementById('retrainProgressBar');
        const progressText = document.getElementById('retrainProgressText');
        const resultsContent = document.getElementById('retrainResultsContent');
        
        // Disable button and show progress
        btn.disabled = true;
        btn.textContent = 'Retraining...';
        progressSection.classList.remove('hidden');
        resultsSection.classList.add('hidden');
        progressBar.style.width = '0%';
        progressText.textContent = 'Starting retraining...';
        
        try {
            const response = await fetch('/api/model/retrain', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Update progress to 100%
                progressBar.style.width = '100%';
                progressText.textContent = 'Complete!';
                
                // Show results
                resultsSection.classList.remove('hidden');
                let backfillInfo = '';
                if (data.backfill_results && data.backfill_results.successful !== undefined) {
                    backfillInfo = `
                        <div class="mt-4 p-3 bg-blue-50 dark:bg-blue-900 rounded-md">
                            <div class="text-blue-600 font-semibold">üîÑ Automatic Backfill Complete</div>
                            <div class="mt-1 text-sm">
                                <p><strong>Articles Processed:</strong> ${data.backfill_results.processed || 0}</p>
                                <p><strong>Successful:</strong> ${data.backfill_results.successful || 0}</p>
                                <p><strong>Failed:</strong> ${data.backfill_results.failed || 0}</p>
                            </div>
                        </div>
                    `;
                }
                
                resultsContent.innerHTML = `
                    <div class="text-green-600 font-semibold">‚úÖ Retraining Complete</div>
                    <div class="mt-2">
                        <p><strong>New Model Version:</strong> v${data.new_version || 'Unknown'}</p>
                        <p><strong>Training Samples:</strong> ${data.training_samples || 'Unknown'}</p>
                    </div>
                    ${backfillInfo}
                `;
                
                // Update status
                const statusElement = document.getElementById('retrainingStatus');
                const accuracy = data.training_accuracy ? (data.training_accuracy * 100).toFixed(1) : 'N/A';
                statusElement.textContent = `v${data.new_version || 'Unknown'} (${accuracy}% accuracy)`;
                statusElement.classList.remove('cursor-help');
                statusElement.removeAttribute('title');
                
                // Reload data
                setTimeout(() => {
                    loadInitialData();
                }, 1000);
                
            } else {
                throw new Error(data.message || 'Retraining failed');
            }
            
        } catch (error) {
            console.error('Error during retraining:', error);
            resultsSection.classList.remove('hidden');
            resultsContent.innerHTML = `
                <div class="text-red-600 font-semibold">‚ùå Retraining Failed</div>
                <div class="mt-2 text-red-600">${error.message}</div>
            `;
        } finally {
            // Re-enable button
            btn.disabled = false;
            btn.textContent = 'Retrain Model';
            setTimeout(() => {
                progressSection.classList.add('hidden');
            }, 3000);
        }
    }

    async function refreshRetrainingStatus() {
        const statusElement = document.getElementById('retrainingStatus');
        const feedbackElement = document.getElementById('feedbackCount');
        const retrainBtn = document.getElementById('retrainModelBtn');
        const refreshBtn = document.getElementById('refreshRetrainBtn');
        
        try {
            // Show loading state on refresh button
            refreshBtn.disabled = true;
            refreshBtn.textContent = 'Refreshing...';
            
            statusElement.textContent = 'Checking...';
            feedbackElement.textContent = 'Loading...';
            
            // Get latest model version and feedback count
            const [versionsResponse, feedbackResponse] = await Promise.all([
                fetch('/api/model/versions'),
                fetch('/api/model/feedback-count')
            ]);
            
            const versionsData = await versionsResponse.json();
            const feedbackData = await feedbackResponse.json();
            
            if (versionsData.success && versionsData.versions.length > 0) {
                const latest = versionsData.versions[0]; // Already sorted by version number
                if (latest.accuracy) {
                    const accuracyPercent = (latest.accuracy * 100).toFixed(1);
                    statusElement.textContent = `v${latest.version_number} (${accuracyPercent}% accuracy)`;
                    statusElement.classList.remove('cursor-help');
                    statusElement.removeAttribute('title');
                } else {
                    statusElement.textContent = `v${latest.version_number}`;
                    statusElement.classList.remove('cursor-help');
                    statusElement.removeAttribute('title');
                }
            } else {
                statusElement.textContent = 'None';
                statusElement.classList.remove('cursor-help');
                statusElement.removeAttribute('title');
            }
            
            if (feedbackData.success) {
                const feedbackCount = feedbackData.count;
                feedbackElement.textContent = feedbackCount.toLocaleString();
                
                // Enable/disable retrain button based on feedback availability
                if (feedbackCount === 0) {
                    retrainBtn.disabled = true;
                    retrainBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    retrainBtn.title = 'No feedback available for retraining';
                } else {
                    retrainBtn.disabled = false;
                    retrainBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    retrainBtn.title = '';
                }
            } else {
                feedbackElement.textContent = 'Error';
                retrainBtn.disabled = true;
                retrainBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
            
        } catch (error) {
            console.error('Error refreshing retraining status:', error);
            statusElement.textContent = 'Error';
            feedbackElement.textContent = 'Error';
            retrainBtn.disabled = true;
            retrainBtn.classList.add('opacity-50', 'cursor-not-allowed');
        } finally {
            // Re-enable refresh button
            refreshBtn.disabled = false;
            refreshBtn.textContent = 'Refresh Status';
        }
    }

    // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            loadInitialData();
            checkEligibleCount();
        checkEvaluationStatus();
        refreshRetrainingStatus();
        
        // Add event listeners
        document.getElementById('evaluateModelBtn').addEventListener('click', runEvaluation);
        document.getElementById('refreshEvalStatusBtn').addEventListener('click', checkEvaluationStatus);
        document.getElementById('retrainModelBtn').addEventListener('click', retrainModel);
        document.getElementById('refreshRetrainBtn').addEventListener('click', refreshRetrainingStatus);
        });
    </script>
{% endblock %}
