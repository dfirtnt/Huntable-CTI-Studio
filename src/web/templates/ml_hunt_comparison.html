{% extends "base.html" %}

{% block title %}ML vs Hunt Scoring Comparison - Huntable CTI Scraper{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <div class="mb-8">
        <h1 class="text-3xl font-bold text-gray-900 dark:text-white mb-2">üìä ML vs Hunt Scoring Comparison</h1>
        <p class="text-gray-600 dark:text-gray-400">Compare ML model predictions with Hunt scoring system for articles with hunt_score > 50</p>
    </div>
    
    <!-- Stats Grid -->
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-4 mb-8">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
            <h3 class="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2">Total Model Versions</h3>
            <div class="text-2xl font-bold text-blue-600" id="totalModelVersions">-</div>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
            <h3 class="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2">Total Chunk Analyses</h3>
            <div class="text-2xl font-bold text-blue-600" id="totalChunkAnalyses">-</div>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
            <h3 class="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2">Average Accuracy</h3>
            <div class="text-2xl font-bold text-blue-600" id="averageAccuracy">-</div>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
            <h3 class="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2">Last Updated</h3>
            <div class="text-2xl font-bold text-blue-600" id="lastUpdated">-</div>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
            <h3 class="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2">Eligible Articles</h3>
            <div class="text-sm font-bold text-green-600" id="eligibleCount">Loading...</div>
        </div>
    </div>

    <!-- Model Retraining Section -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <div class="flex items-center justify-between mb-4">
            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">üîÑ Model Retraining</h2>
            <div class="relative group">
                <button class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors" aria-label="Help">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"></path>
                    </svg>
                </button>
                <div class="absolute right-0 top-8 w-80 bg-white dark:bg-gray-700 rounded-lg shadow-lg border border-gray-200 dark:border-gray-600 p-4 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-10">
                    <div class="text-sm text-gray-700 dark:text-gray-300">
                        <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Retraining Best Practices</h4>
                        <p class="mb-3">For optimal model performance, collect <strong>20-50 user classifications</strong> before retraining. The system uses <strong>cumulative learning</strong> - each retraining builds on ALL previous data plus new feedback.</p>
                        
                        <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Cumulative Learning Benefits</h4>
                        <ul class="list-disc list-inside space-y-1 mb-3">
                            <li>No data loss - all previous feedback is preserved</li>
                            <li>Progressive improvement with each retraining</li>
                            <li>Small batches still improve the model</li>
                            <li>No catastrophic forgetting of previous knowledge</li>
                        </ul>
                        
                        <p class="text-xs text-gray-500 dark:text-gray-400">Note: Retraining with too few samples may result in unstable model performance.</p>
                    </div>
                </div>
            </div>
        </div>
        <p class="text-gray-600 dark:text-gray-400 mb-4">Retrain the ML model with user feedback from chunk debugging to improve performance</p>
        
        <div class="flex justify-between items-center">
            <div class="text-lg font-medium text-gray-900 dark:text-white">
                <div>Current model: <span id="retrainingStatus">v24 (79.4% accuracy)</span></div>
                <div class="text-sm text-gray-500 dark:text-gray-400 mt-1">
                    Available feedback: <span id="feedbackCount">-</span> user classifications and/or corrections
                </div>
            </div>
            <div class="flex gap-3">
                <button id="retrainModelBtn" 
                        class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2">
                    Retrain Model
                </button>
                <button id="refreshRetrainBtn" 
                        class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                    Refresh Status
                </button>
            </div>
        </div>
        
        <!-- Retraining Progress Bar -->
        <div id="retrainProgressSection" class="hidden mt-4">
            <div class="w-full bg-gray-200 rounded-full h-2">
                <div id="retrainProgressBar" class="bg-purple-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <div id="retrainProgressText" class="text-sm text-gray-600 mt-2">Retraining...</div>
        </div>
        
        <!-- Retraining Results -->
        <div id="retrainResultsSection" class="hidden mt-4 p-4 bg-gray-50 dark:bg-gray-700 rounded-md">
            <div id="retrainResultsContent"></div>
        </div>
    </div>

    
    <!-- Model Evaluation Section -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-4">üß™ Model Evaluation on Test Set</h2>
        <p class="text-gray-600 dark:text-gray-400 mb-4">Evaluate current model performance on annotated chunks from article_annotations table</p>
        
        <div class="flex justify-between items-center">
            <div class="text-lg font-medium text-gray-900 dark:text-white">
                <div><span id="evalStatus">Ready to evaluate current model</span></div>
                <div class="text-sm text-gray-500 dark:text-gray-400 mt-1">
                    Test set: <span id="evalChunkCount">Loading...</span> annotated chunks
                </div>
            </div>
            <div class="flex gap-3">
                <button id="evaluateModelBtn" 
                        class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                    Evaluate Current Model
                </button>
                <button id="refreshEvalStatusBtn" 
                        class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                    Refresh Status
                </button>
            </div>
        </div>
        
        <!-- Evaluation Progress -->
        <div id="evalProgressSection" class="hidden mt-4">
            <div class="w-full bg-gray-200 rounded-full h-2">
                <div id="evalProgressBar" class="bg-green-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <div id="evalProgressText" class="text-sm text-gray-600 mt-2">Evaluating model...</div>
        </div>
        
        <!-- Collapsible Evaluation Results -->
        <div id="evalResultsSection" class="hidden mt-4">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-semibold text-gray-900 dark:text-white">üìä Evaluation Results</h3>
                <button id="toggleEvaluationResults" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors" aria-label="Toggle evaluation results">
                    <svg class="w-5 h-5 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </button>
            </div>
            <div id="evalResultsContent" class="p-4 bg-gray-50 dark:bg-gray-700 rounded-md"></div>
        </div>
    </div>
    
    <!-- Evaluation Metrics Charts -->
    <div class="mb-8">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-semibold text-gray-900 dark:text-white">üß™ Evaluation Metrics Over Time</h3>
                <div class="relative group">
                    <button class="text-gray-400 hover:text-gray-600 focus:outline-none" onclick="showMetricsHelp()">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"></path>
                        </svg>
                    </button>
                    <div id="metricsHelpTooltip" class="absolute right-0 top-8 w-80 p-4 bg-gray-800 text-white text-sm rounded-lg shadow-lg opacity-0 invisible transition-all duration-200 z-50">
                        <div class="absolute -top-1 right-4 w-2 h-2 bg-gray-800 transform rotate-45"></div>
                        <div class="space-y-2">
                            <div><strong>F1</strong> ‚Äì Most balanced and widely used for classification benchmarks.</div>
                            <div><strong>Recall</strong> ‚Äì Prioritized when missing positives is costly (e.g., fraud, cancer detection).</div>
                            <div><strong>Precision</strong> ‚Äì Prioritized when false alarms are costly (e.g., spam filters, alerts).</div>
                            <div><strong>Accuracy</strong> ‚Äì Lowest priority; often misleading with imbalanced data.</div>
                            <div class="pt-2 border-t border-gray-600"><strong>Priority:</strong> F1 > Recall ‚âà Precision > Accuracy</div>
                        </div>
                    </div>
                </div>
            </div>
            <canvas id="evalAccuracyChart" width="400" height="200"></canvas>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let currentData = {
            stats: [],
            results: [],
        summary: null,
        modelVersions: []
        };

        function getAlignedVersionNumbers() {
            const classificationVersions = (currentData.timeline || [])
                .map(item => item.version_number);
            const evaluatedVersions = currentData.modelVersions
                .filter(v => v.has_evaluation)
                .map(v => v.version_number);
            const combinedSet = new Set([...classificationVersions, ...evaluatedVersions]);
            const combined = Array.from(combinedSet).sort((a, b) => a - b);
            if (combined.length <= 9) {
                return combined;
            }
            return combined.slice(-9);
        }

        // Chart instances for proper cleanup
        let distributionChart = null;
        let evalAccuracyChart = null;
        let evalMetricsChart = null;

        // Load initial data
        async function loadInitialData() {
            try {
                // Load summary
                const summaryResponse = await fetch('/api/ml-hunt-comparison/summary');
                const summaryData = await summaryResponse.json();
                if (summaryData.success) {
                    currentData.summary = summaryData.summary;
                    updateSummaryStats();
                }

                // Load stats
                const statsResponse = await fetch('/api/ml-hunt-comparison/stats');
                const statsData = await statsResponse.json();
                if (statsData.success) {
                    currentData.stats = statsData.stats;
            }
            
            // Load model versions for evaluation metrics
            const versionsResponse = await fetch('/api/model/versions');
            const versionsData = await versionsResponse.json();
            if (versionsData.success) {
                currentData.modelVersions = versionsData.versions;
            }

            // Load classification timeline
            const timelineResponse = await fetch('/api/model/classification-timeline');
            const timelineData = await timelineResponse.json();
            if (timelineData.success) {
                currentData.timeline = timelineData.timeline;
            }
            
            // Load evaluation chunk count
            const evalCountResponse = await fetch('/api/model/eval-chunk-count');
            const evalCountData = await evalCountResponse.json();
            if (evalCountData.success) {
                document.getElementById('evalChunkCount').textContent = evalCountData.count.toLocaleString();
            } else {
                document.getElementById('evalChunkCount').textContent = 'Unknown';
            }
            
            
            // Check feedback count and disable retrain button if no feedback available
            const feedbackResponse = await fetch('/api/model/feedback-count');
            const feedbackData = await feedbackResponse.json();
            if (feedbackData.success && feedbackData.count === 0) {
                const retrainBtn = document.getElementById('retrainModelBtn');
                retrainBtn.disabled = true;
                retrainBtn.classList.add('opacity-50', 'cursor-not-allowed');
                retrainBtn.title = 'No feedback available for retraining';
            }
            
                    updateCharts();
            } catch (error) {
                console.error('Error loading initial data:', error);
                showError('Failed to load initial data');
            }
        }

        function updateSummaryStats() {
            const summary = currentData.summary;
        document.getElementById('totalModelVersions').textContent = summary.total_model_versions;
        document.getElementById('totalChunkAnalyses').textContent = summary.total_chunk_analyses.toLocaleString();
            
        if (summary.overall_stats && summary.overall_stats.length > 0) {
                const avgAccuracy = summary.overall_stats.reduce((sum, stat) => sum + stat.accuracy, 0) / summary.overall_stats.length;
            document.getElementById('averageAccuracy').textContent = (avgAccuracy * 100).toFixed(1) + '%';
            }
            
            if (summary.last_updated) {
                const date = new Date(summary.last_updated);
                document.getElementById('lastUpdated').textContent = date.toLocaleDateString();
            }
        }

        function updateCharts() {
        updateEvaluationCharts();
    }



    function updateEvaluationCharts() {
        updateEvalAccuracyChart();
    }

    function updateEvalAccuracyChart() {
        const ctx = document.getElementById('evalAccuracyChart').getContext('2d');
        
        // Destroy existing chart if it exists
        if (evalAccuracyChart) {
            evalAccuracyChart.destroy();
            evalAccuracyChart = null;
        }
        
        const timelineVersions = getAlignedVersionNumbers();
        const evaluatedVersionMap = new Map(
            currentData.modelVersions
                .filter(v => v.has_evaluation)
                .map(v => [v.version_number, v])
        );

        if (timelineVersions.length === 0) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillText('No timeline data available', 10, 50);
            return;
        }
        
        const accuracyPoints = timelineVersions.map(versionNumber => {
            const version = evaluatedVersionMap.get(versionNumber);
            return version && version.eval_accuracy != null
                ? (version.eval_accuracy * 100)
                : null;
        });

        const precisionPoints = timelineVersions.map(versionNumber => {
            const version = evaluatedVersionMap.get(versionNumber);
            return version && version.eval_precision_huntable != null
                ? (version.eval_precision_huntable * 100)
                : null;
        });

        const recallPoints = timelineVersions.map(versionNumber => {
            const version = evaluatedVersionMap.get(versionNumber);
            return version && version.eval_recall_huntable != null
                ? (version.eval_recall_huntable * 100)
                : null;
        });

        const f1Points = timelineVersions.map(versionNumber => {
            const version = evaluatedVersionMap.get(versionNumber);
            return version && version.eval_f1_score_huntable != null
                ? (version.eval_f1_score_huntable * 100)
                : null;
        });

        const evaluatedCount = accuracyPoints.filter(value => value !== null).length;

        if (evaluatedCount === 0) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillText('No evaluation data available', 10, 50);
            return;
        }
        
            evalAccuracyChart = new Chart(ctx, {
            type: 'line',
                data: {
                labels: timelineVersions.map(v => `v${v}`),
                    datasets: [{
                    label: 'Accuracy %',
                    data: accuracyPoints,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1,
                    spanGaps: true
                    }, {
                    label: 'Precision %',
                    data: precisionPoints,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1,
                    spanGaps: true
                    }, {
                    label: 'Recall %',
                    data: recallPoints,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1,
                    spanGaps: true
                    }, {
                    label: 'F1 Score %',
                    data: f1Points,
                    borderColor: 'rgba(255, 206, 86, 1)',
                    backgroundColor: 'rgba(255, 206, 86, 0.2)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1,
                    spanGaps: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Model Performance on Test Set (160 chunks)'
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const labelVersion = timelineVersions[context.dataIndex];
                                if (context.parsed.y === null) {
                                    return `v${labelVersion}: No evaluation data`;
                                }
                                return `v${labelVersion}: ${context.parsed.y.toFixed(1)}%`;
                            }
                        }
                    }
                }
                }
            });
        }


    function showError(message) {
        console.error(message);
        // Could add a toast notification here
    }

        // Backfill functions
        async function checkEligibleCount() {
            const countElement = document.getElementById('eligibleCount');
            
            if (!countElement) {
                console.error('eligibleCount element not found in DOM');
                return;
            }
            
            try {
                countElement.textContent = 'Checking...';
                
                const response = await fetch('/api/ml-hunt-comparison/eligible-count');
                const data = await response.json();
                
                if (data.success) {
                    const countText = data.count === 0 
                        ? 'No eligible articles found' 
                        : `${data.count} article${data.count === 1 ? '' : 's'} eligible for processing`;
                    countElement.textContent = countText;
                } else {
                    countElement.textContent = 'Error checking eligible articles';
                }
            } catch (error) {
                console.error('Error checking eligible count:', error);
                countElement.textContent = 'Error checking eligible articles';
            }
        }


    // Evaluation functions
    async function runEvaluation() {
        const btn = document.getElementById('evaluateModelBtn');
        const progressSection = document.getElementById('evalProgressSection');
        const resultsSection = document.getElementById('evalResultsSection');
        const progressBar = document.getElementById('evalProgressBar');
        const progressText = document.getElementById('evalProgressText');
        const resultsContent = document.getElementById('evalResultsContent');
        const statusElement = document.getElementById('evalStatus');
        
        // Disable button and show progress
        btn.disabled = true;
        btn.textContent = 'Evaluating...';
        progressSection.classList.remove('hidden');
        resultsSection.classList.add('hidden');
        progressBar.style.width = '0%';
        progressText.textContent = 'Starting evaluation...';
        statusElement.textContent = 'Evaluating model on test set...';
        
        try {
            // Simulate progress
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += Math.random() * 20;
                if (progress > 90) progress = 90;
                progressBar.style.width = progress + '%';
            }, 200);
            
            const response = await fetch('/api/model/evaluate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            clearInterval(progressInterval);
            progressBar.style.width = '100%';
            progressText.textContent = 'Complete!';
            
            const data = await response.json();
            
            if (data.success) {
                // Show results
                resultsSection.classList.remove('hidden');
                resultsContent.innerHTML = generateEvaluationResults(data);
                
                // Make results content collapsible by default (expanded)
                resultsContent.classList.remove('hidden');
                
                statusElement.textContent = `Evaluation complete - F1 Score: ${(data.metrics.f1_score_huntable * 100).toFixed(1)}%`;
                
                // Reload data to update charts
                setTimeout(() => {
                    loadInitialData();
                }, 1000);
                
            } else {
                throw new Error(data.message || 'Evaluation failed');
            }
            
        } catch (error) {
            console.error('Error during evaluation:', error);
            resultsSection.classList.remove('hidden');
            resultsContent.innerHTML = `
                <div class="text-red-600 font-semibold">‚ùå Evaluation Failed</div>
                <div class="mt-2 text-red-600">${error.message}</div>
            `;
            statusElement.textContent = 'Evaluation failed';
        } finally {
            // Re-enable button
            btn.disabled = false;
            btn.textContent = 'Evaluate Current Model';
            setTimeout(() => {
                progressSection.classList.add('hidden');
            }, 3000);
        }
    }

    function generateEvaluationResults(data) {
        const metrics = data.metrics;
        const summary = data.eval_summary || {};
        
        return `
            <div class="space-y-4">
                <div class="text-green-600 font-semibold text-lg">‚úÖ Evaluation Complete</div>
                
                <!-- Overall Metrics -->
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">Accuracy</div>
                        <div class="text-2xl font-bold text-blue-600">${(metrics.accuracy * 100).toFixed(1)}%</div>
                    </div>
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">Avg Confidence</div>
                        <div class="text-2xl font-bold text-green-600">${(metrics.avg_confidence * 100).toFixed(1)}%</div>
                    </div>
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">Total Chunks</div>
                        <div class="text-2xl font-bold text-purple-600">${metrics.total_chunks}</div>
                    </div>
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">Misclassified</div>
                        <div class="text-2xl font-bold text-red-600">${metrics.misclassified_count}</div>
                    </div>
                </div>
                
                <!-- Per-Class Metrics -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="bg-white dark:bg-gray-600 p-4 rounded">
                        <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Huntable Class</h4>
                        <div class="space-y-1 text-sm">
                            <div>Precision: <span class="font-mono">${(metrics.precision_huntable * 100).toFixed(1)}%</span></div>
                            <div>Recall: <span class="font-mono">${(metrics.recall_huntable * 100).toFixed(1)}%</span></div>
                            <div>F1 Score: <span class="font-mono">${(metrics.f1_score_huntable * 100).toFixed(1)}%</span></div>
                        </div>
                    </div>
                    <div class="bg-white dark:bg-gray-600 p-4 rounded">
                        <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Not Huntable Class</h4>
                        <div class="space-y-1 text-sm">
                            <div>Precision: <span class="font-mono">${(metrics.precision_not_huntable * 100).toFixed(1)}%</span></div>
                            <div>Recall: <span class="font-mono">${(metrics.recall_not_huntable * 100).toFixed(1)}%</span></div>
                            <div>F1 Score: <span class="font-mono">${(metrics.f1_score_not_huntable * 100).toFixed(1)}%</span></div>
                        </div>
                    </div>
                </div>
                
                <!-- Confusion Matrix -->
                ${metrics.confusion_matrix ? `
                <div class="bg-white dark:bg-gray-600 p-4 rounded">
                    <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Confusion Matrix</h4>
                    <div class="grid grid-cols-3 gap-2 text-sm">
                        <div></div>
                        <div class="text-center font-semibold">Predicted Not Huntable</div>
                        <div class="text-center font-semibold">Predicted Huntable</div>
                        <div class="font-semibold">Actual Not Huntable</div>
                        <div class="text-center bg-green-100 dark:bg-green-800 p-2 rounded">${metrics.confusion_matrix.true_negative}</div>
                        <div class="text-center bg-red-100 dark:bg-red-800 p-2 rounded">${metrics.confusion_matrix.false_positive}</div>
                        <div class="font-semibold">Actual Huntable</div>
                        <div class="text-center bg-red-100 dark:bg-red-800 p-2 rounded">${metrics.confusion_matrix.false_negative}</div>
                        <div class="text-center bg-green-100 dark:bg-green-800 p-2 rounded">${metrics.confusion_matrix.true_positive}</div>
                    </div>
                </div>
                ` : ''}
                
            </div>
        `;
    }

    function showMetricsHelp() {
        const tooltip = document.getElementById('metricsHelpTooltip');
        if (tooltip) {
            tooltip.classList.toggle('opacity-0');
            tooltip.classList.toggle('invisible');
            tooltip.classList.toggle('opacity-100');
            tooltip.classList.toggle('visible');
        }
    }

    async function checkEvaluationStatus() {
        const statusElement = document.getElementById('evalStatus');
        
        try {
            statusElement.textContent = 'Checking evaluation status...';
            
            const response = await fetch('/api/model/versions');
            const data = await response.json();
            
            if (data.success && data.versions.length > 0) {
                const latestVersion = data.versions[0];
                if (latestVersion.has_evaluation) {
                    const evalDate = new Date(latestVersion.evaluated_at).toLocaleDateString();
                    statusElement.textContent = `Last evaluated: ${evalDate} - Accuracy: ${(latestVersion.eval_accuracy * 100).toFixed(1)}%`;
                } else {
                    statusElement.textContent = 'Model not yet evaluated on test set';
                }
            } else {
                statusElement.textContent = 'No model versions found';
            }
        } catch (error) {
            console.error('Error checking evaluation status:', error);
            statusElement.textContent = 'Error checking status';
        }
    }

    // Model Retraining functions
    async function retrainModel() {
        const btn = document.getElementById('retrainModelBtn');
        const progressSection = document.getElementById('retrainProgressSection');
        const resultsSection = document.getElementById('retrainResultsSection');
        const progressBar = document.getElementById('retrainProgressBar');
        const progressText = document.getElementById('retrainProgressText');
        const resultsContent = document.getElementById('retrainResultsContent');
        
        // Disable button and show progress
        btn.disabled = true;
        btn.textContent = 'Retraining...';
        progressSection.classList.remove('hidden');
        resultsSection.classList.add('hidden');
        progressBar.style.width = '0%';
        progressText.textContent = 'Starting retraining...';
        
        try {
            // Start retraining
            const response = await fetch('/api/model/retrain', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Start polling for status updates
                pollRetrainingStatus();
            } else {
                throw new Error(data.message || 'Retraining failed');
            }
            
        } catch (error) {
            console.error('Error during retraining:', error);
            resultsSection.classList.remove('hidden');
            resultsContent.innerHTML = `
                <div class="text-red-600 font-semibold">‚ùå Retraining Failed</div>
                <div class="mt-2 text-red-600">${error.message}</div>
            `;
        } finally {
            // Re-enable button
            btn.disabled = false;
            btn.textContent = 'Retrain Model';
            setTimeout(() => {
                progressSection.classList.add('hidden');
            }, 3000);
        }
    }
    
    async function pollRetrainingStatus() {
        const progressBar = document.getElementById('retrainProgressBar');
        const progressText = document.getElementById('retrainProgressText');
        const resultsSection = document.getElementById('retrainResultsSection');
        const resultsContent = document.getElementById('retrainResultsContent');
        const btn = document.getElementById('retrainModelBtn');
        
        const pollInterval = setInterval(async () => {
            try {
                const response = await fetch('/api/model/retrain-status');
                const status = await response.json();
                
                // Update progress
                progressBar.style.width = `${status.progress || 0}%`;
                progressText.textContent = status.message || 'Retraining...';
                
                if (status.status === 'complete') {
                    clearInterval(pollInterval);
                    
                    // Show results
                    resultsSection.classList.remove('hidden');
                    resultsContent.innerHTML = `
                        <div class="text-green-600 font-semibold">‚úÖ Retraining Complete</div>
                        <div class="mt-2">
                            <p><strong>New Model Version:</strong> v${status.new_version || 'Unknown'}</p>
                            <p><strong>Training Samples:</strong> ${status.training_samples || 'Unknown'}</p>
                            <p><strong>Training Accuracy:</strong> ${status.training_accuracy ? (status.training_accuracy * 100).toFixed(1) + '%' : 'N/A'}</p>
                            <p><strong>Duration:</strong> ${status.training_duration || 'Unknown'}</p>
                        </div>
                    `;
                    
                    // Update status
                    const statusElement = document.getElementById('retrainingStatus');
                    const accuracy = status.training_accuracy ? (status.training_accuracy * 100).toFixed(1) : 'N/A';
                    statusElement.textContent = `v${status.new_version || 'Unknown'} (${accuracy}% accuracy)`;
                    statusElement.classList.remove('cursor-help');
                    statusElement.removeAttribute('title');
                    
                    // Re-enable button
                    btn.disabled = false;
                    btn.textContent = 'Retrain Model';
                    
                    // Reload data
                    setTimeout(() => {
                        loadInitialData();
                    }, 1000);
                    
                } else if (status.status === 'error') {
                    clearInterval(pollInterval);
                    
                    // Show error
                    resultsSection.classList.remove('hidden');
                    resultsContent.innerHTML = `
                        <div class="text-red-600 font-semibold">‚ùå Retraining Failed</div>
                        <div class="mt-2">
                            <p>${status.message || 'Unknown error occurred'}</p>
                        </div>
                    `;
                    
                    // Re-enable button
                    btn.disabled = false;
                    btn.textContent = 'Retrain Model';
                }
                
            } catch (error) {
                console.error('Error polling retraining status:', error);
                clearInterval(pollInterval);
                
                // Show error
                resultsSection.classList.remove('hidden');
                resultsContent.innerHTML = `
                    <div class="text-red-600 font-semibold">‚ùå Error Checking Status</div>
                    <div class="mt-2">
                        <p>Failed to check retraining status: ${error.message}</p>
                    </div>
                `;
                
                // Re-enable button
                btn.disabled = false;
                btn.textContent = 'Retrain Model';
            }
        }, 2000); // Poll every 2 seconds
    }
    
    async function refreshRetrainingStatus() {
        const statusElement = document.getElementById('retrainingStatus');
        const feedbackElement = document.getElementById('feedbackCount');
        const retrainBtn = document.getElementById('retrainModelBtn');
        const refreshBtn = document.getElementById('refreshRetrainBtn');
        
        try {
            // Show loading state on refresh button
            refreshBtn.disabled = true;
            refreshBtn.textContent = 'Refreshing...';
            
            statusElement.textContent = 'Checking...';
            feedbackElement.textContent = 'Loading...';
            
            // Get latest model version and feedback count
            const [versionsResponse, feedbackResponse] = await Promise.all([
                fetch('/api/model/versions'),
                fetch('/api/model/feedback-count')
            ]);
            
            const versionsData = await versionsResponse.json();
            const feedbackData = await feedbackResponse.json();
            
            if (versionsData.success && versionsData.versions.length > 0) {
                const latest = versionsData.versions[0]; // Already sorted by version number
                if (latest.accuracy) {
                    const accuracyPercent = (latest.accuracy * 100).toFixed(1);
                    statusElement.textContent = `v${latest.version_number} (${accuracyPercent}% accuracy)`;
                    statusElement.classList.remove('cursor-help');
                    statusElement.removeAttribute('title');
                } else {
                    statusElement.textContent = `v${latest.version_number}`;
                    statusElement.classList.remove('cursor-help');
                    statusElement.removeAttribute('title');
                }
            } else {
                statusElement.textContent = 'None';
                statusElement.classList.remove('cursor-help');
                statusElement.removeAttribute('title');
            }
            
            if (feedbackData.success) {
                const feedbackCount = feedbackData.count;
                feedbackElement.textContent = feedbackCount.toLocaleString();
                
                // Enable/disable retrain button based on feedback availability
                if (feedbackCount === 0) {
                    retrainBtn.disabled = true;
                    retrainBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    retrainBtn.title = 'No feedback available for retraining';
                } else {
                    retrainBtn.disabled = false;
                    retrainBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    retrainBtn.title = '';
                }
            } else {
                feedbackElement.textContent = 'Error';
                retrainBtn.disabled = true;
                retrainBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
            
        } catch (error) {
            console.error('Error refreshing retraining status:', error);
            statusElement.textContent = 'Error';
            feedbackElement.textContent = 'Error';
            retrainBtn.disabled = true;
            retrainBtn.classList.add('opacity-50', 'cursor-not-allowed');
        } finally {
            // Re-enable refresh button
            refreshBtn.disabled = false;
            refreshBtn.textContent = 'Refresh Status';
        }
    }

    // Toggle evaluation results content
    function toggleEvaluationResults() {
        const content = document.getElementById('evalResultsContent');
        const toggleBtn = document.getElementById('toggleEvaluationResults');
        const icon = toggleBtn.querySelector('svg');
        
        if (content.classList.contains('hidden')) {
            content.classList.remove('hidden');
            icon.classList.add('rotate-180');
        } else {
            content.classList.add('hidden');
            icon.classList.remove('rotate-180');
        }
    }

    // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            loadInitialData();
            checkEligibleCount();
        checkEvaluationStatus();
        refreshRetrainingStatus();
        
        // Add event listeners
        document.getElementById('evaluateModelBtn').addEventListener('click', runEvaluation);
        document.getElementById('refreshEvalStatusBtn').addEventListener('click', checkEvaluationStatus);
        document.getElementById('retrainModelBtn').addEventListener('click', retrainModel);
        document.getElementById('refreshRetrainBtn').addEventListener('click', refreshRetrainingStatus);
        document.getElementById('toggleEvaluationResults').addEventListener('click', toggleEvaluationResults);
        });
    </script>
{% endblock %}

<style>
.rotate-180 {
    transform: rotate(180deg);
}
</style>
