{% extends "base.html" %}

{% block title %}ML vs Hunt Scoring Comparison - Huntable Detection Studio{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <div class="mb-8">
        <h1 class="text-3xl font-bold text-gray-900 dark:text-white mb-2">üìä ML vs Hunt Scoring Comparison</h1>
        <p class="text-gray-600 dark:text-gray-400">Compare ML model predictions with Hunt scoring system for articles with hunt_score > 50</p>
    </div>
    
    <!-- Stats Grid -->
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-4 mb-8">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
            <h3 class="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2">Total Model Versions</h3>
            <div class="text-2xl font-bold text-blue-600" id="totalModelVersions">-</div>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
            <h3 class="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2">Total Chunk Analyses</h3>
            <div class="text-2xl font-bold text-blue-600" id="totalChunkAnalyses">-</div>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
            <h3 class="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2">F1 Quality Metric</h3>
            <div class="text-2xl font-bold text-blue-600" id="averageAccuracy">-</div>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
            <h3 class="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2">Last Updated</h3>
            <div class="text-2xl font-bold text-blue-600" id="lastUpdated">-</div>
        </div>
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-sm font-medium text-gray-500 dark:text-gray-400">Eligible Articles</h3>
                <div class="relative group">
                    <button class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors" aria-label="Help">
                        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"></path>
                        </svg>
                    </button>
                    <div class="absolute right-0 top-6 w-96 bg-white dark:bg-gray-700 rounded-lg shadow-lg border border-gray-200 dark:border-gray-600 p-4 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-10">
                        <div class="text-sm text-gray-700 dark:text-gray-300">
                            <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Article Processing for ML Training</h4>
                            <p class="mb-3">This processes high-scoring threat intelligence articles (hunt_score > 50) through chunk analysis to generate ML training data.</p>
                            
                            <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Why This Matters</h4>
                            <ul class="list-disc list-inside space-y-1 mb-3">
                                <li><strong>Training Data Generation:</strong> Creates chunk-level classifications for ML model training</li>
                                <li><strong>Model Validation:</strong> Provides data to compare ML predictions vs hunt scoring</li>
                                <li><strong>Performance Metrics:</strong> Enables accuracy measurement and model improvement</li>
                                <li><strong>Quality Assurance:</strong> Validates that ML model aligns with threat hunting expertise</li>
                            </ul>
                            
                            <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Process Details</h4>
                            <ul class="list-disc list-inside space-y-1 mb-3">
                                <li>Articles are chunked into 1000-character segments</li>
                                <li>Each chunk gets ML classification (huntable/not huntable)</li>
                                <li>All chunks are stored for analysis regardless of confidence</li>
                                <li>Only chunks with ‚â•70% confidence are sent to LLM for processing</li>
                                <li>Results feed into ML vs Hunt comparison analysis</li>
                            </ul>
                            
                            <p class="text-xs text-gray-500 dark:text-gray-400">Note: This is essential for ML model retraining and performance evaluation.</p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="text-sm font-bold text-green-600" id="eligibleCount">Loading...</div>
            <button id="processEligibleBtn" 
                    class="mt-2 px-3 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                Process All Eligible Articles
            </button>
        </div>
    </div>

    <!-- Model Retraining Section -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <div class="flex items-center justify-between mb-4">
            <h2 class="text-xl font-semibold text-gray-900 dark:text-white">üîÑ Model Retraining</h2>
            <div class="relative group">
                <button class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors" aria-label="Help">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"></path>
                    </svg>
                </button>
                <div class="absolute right-0 top-8 w-80 bg-white dark:bg-gray-700 rounded-lg shadow-lg border border-gray-200 dark:border-gray-600 p-4 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-10">
                    <div class="text-sm text-gray-700 dark:text-gray-300">
                        <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Retraining Best Practices</h4>
                        <p class="mb-3">For optimal model performance, collect <strong>20-50 user classifications</strong> before retraining. The system uses <strong>cumulative learning</strong> - each retraining builds on ALL previous data plus new feedback.</p>
                        
                        <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Cumulative Learning Benefits</h4>
                        <ul class="list-disc list-inside space-y-1 mb-3">
                            <li>No data loss - all previous feedback is preserved</li>
                            <li>Progressive improvement with each retraining</li>
                            <li>Small batches still improve the model</li>
                            <li>No catastrophic forgetting of previous knowledge</li>
                        </ul>
                        
                        <p class="text-xs text-gray-500 dark:text-gray-400">Note: Retraining with too few samples may result in unstable model performance.</p>
                    </div>
                </div>
            </div>
        </div>
        <p class="text-gray-600 dark:text-gray-400 mb-4">Retrain the ML model with user feedback from annotations and chunk debugging to improve model performance</p>
        
        <div class="flex justify-between items-center">
            <div class="text-lg font-medium text-gray-900 dark:text-white">
                <div>Current model: <span id="retrainingStatus">v24 (79.4% accuracy)</span></div>
                <div class="text-sm text-gray-500 dark:text-gray-400 mt-1">
                    Available training data: <span id="feedbackCount">-</span> samples
                    <span id="feedbackBreakdown" class="text-xs ml-2"></span>
                </div>
                <div id="totalDataBreakdown" class="text-xs text-gray-400 dark:text-gray-500 mt-0.5"></div>
                <div id="retrainWarning" class="text-sm text-amber-600 dark:text-amber-400 mt-1 hidden">
                    ‚ö†Ô∏è Warning: 229 articles are unprocessed. Consider processing them first for complete workflow.
                </div>
            </div>
            <div class="flex gap-3">
                <button id="retrainModelBtn" 
                        class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2">
                    Retrain Model
                </button>
                <button id="refreshRetrainBtn" 
                        class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                    Refresh Status
                </button>
            </div>
        </div>
        
        <!-- Retraining Progress Bar -->
        <div id="retrainProgressSection" class="hidden mt-4">
            <div class="w-full bg-gray-200 rounded-full h-2">
                <div id="retrainProgressBar" class="bg-purple-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <div id="retrainProgressText" class="text-sm text-gray-600 mt-2">Retraining...</div>
        </div>
        
        <!-- Retraining Results -->
        <div id="retrainResultsSection" class="hidden mt-4 p-4 bg-gray-50 dark:bg-gray-700 rounded-md">
            <div id="retrainResultsContent"></div>
        </div>
    </div>

    
    
    <!-- Evaluation Metrics Charts -->
    <div class="mb-8">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-semibold text-gray-900 dark:text-white">üß™ Evaluation Metrics Over Time</h3>
                <div class="flex items-center gap-2">
                    <div class="flex items-center gap-1 bg-gray-100 dark:bg-gray-700 rounded-lg p-1">
                        <button id="zoomOutBtn" class="p-1.5 text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 rounded focus:outline-none" title="Zoom Out (Show More History)">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7"></path>
                            </svg>
                        </button>
                        <span id="zoomLevel" class="px-2 text-xs text-gray-600 dark:text-gray-300 min-w-[60px] text-center">All</span>
                        <button id="zoomInBtn" class="p-1.5 text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600 rounded focus:outline-none" title="Zoom In (Show Less History)">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v6m3-3H7"></path>
                            </svg>
                        </button>
                    </div>
                    <div class="relative group">
                        <button class="text-gray-400 hover:text-gray-600 focus:outline-none" onclick="showMetricsHelp()">
                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"></path>
                            </svg>
                        </button>
                        <div id="metricsHelpTooltip" class="absolute right-0 top-8 w-80 p-4 bg-gray-800 text-white text-sm rounded-lg shadow-lg opacity-0 invisible transition-all duration-200 z-50">
                            <div class="absolute -top-1 right-4 w-2 h-2 bg-gray-800 transform rotate-45"></div>
                            <div class="space-y-2">
                                <div><strong>F1</strong> ‚Äì Most balanced and widely used for classification benchmarks.</div>
                                <div><strong>Recall</strong> ‚Äì Prioritized when missing positives is costly (e.g., fraud, cancer detection).</div>
                                <div><strong>Precision</strong> ‚Äì Prioritized when false alarms are costly (e.g., spam filters, alerts).</div>
                                <div><strong>Accuracy</strong> ‚Äì Lowest priority; often misleading with imbalanced data.</div>
                                <div class="pt-2 border-t border-gray-600"><strong>Priority:</strong> F1 > Recall ‚âà Precision > Accuracy</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Custom Title - Fixed and Centered -->
            <div class="text-center mb-2">
                <h4 class="text-sm font-semibold text-gray-700 dark:text-gray-300">Model Performance on Test Set (160 chunks)</h4>
            </div>
            <!-- Custom Legend - Fixed and Centered -->
            <div class="flex justify-center items-center gap-6 mb-4 py-2">
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: rgba(75, 192, 192, 1);"></div>
                    <span class="text-sm text-gray-700 dark:text-gray-300">Accuracy %</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: rgba(255, 99, 132, 1);"></div>
                    <span class="text-sm text-gray-700 dark:text-gray-300">Precision %</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: rgba(54, 162, 235, 1);"></div>
                    <span class="text-sm text-gray-700 dark:text-gray-300">Recall %</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded" style="background-color: rgba(255, 206, 86, 1);"></div>
                    <span class="text-sm text-gray-700 dark:text-gray-300">F1 Score %</span>
                </div>
            </div>
            <div class="overflow-x-auto">
                <div id="chartContainer" style="min-width: 100%; height: 400px; position: relative;">
                    <canvas id="evalAccuracyChart"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let currentData = {
            stats: [],
            results: [],
        summary: null,
        modelVersions: []
        };

        let logPollingIntervalId = null;
        const processingLogState = {
            completed: false,
            failed: false,
        };

        function stopProcessingLogPolling() {
            if (logPollingIntervalId) {
                clearInterval(logPollingIntervalId);
                logPollingIntervalId = null;
            }
        }

        function startProcessingLogPolling() {
            stopProcessingLogPolling();
            processingLogState.completed = false;
            processingLogState.failed = false;
            pollLogs();
            logPollingIntervalId = setInterval(pollLogs, 1000);
        }

        function handleProcessingComplete() {
            if (processingLogState.completed) {
                return;
            }
            processingLogState.completed = true;
            stopProcessingLogPolling();
            resetButtonState();
            const countElement = document.getElementById('eligibleCount');
            if (countElement) {
                countElement.textContent = '‚úÖ Processing complete. Refreshing counts...';
            }
            setTimeout(() => {
                checkEligibleCount();
            }, 500);
        }

        function handleProcessingFailure() {
            if (processingLogState.failed || processingLogState.completed) {
                return;
            }
            processingLogState.failed = true;
            stopProcessingLogPolling();
            const btn = document.getElementById('processEligibleBtn');
            if (btn) {
                btn.disabled = false;
                btn.textContent = 'Retry Processing';
                btn.classList.remove('bg-gray-600', 'hover:bg-gray-700', 'bg-green-600', 'hover:bg-green-700');
                btn.classList.add('bg-blue-600', 'hover:bg-blue-700');
            }
            const countElement = document.getElementById('eligibleCount');
            if (countElement) {
                countElement.textContent = '‚ùå Processing failed. Check logs.';
            }
            setTimeout(() => {
                checkEligibleCount();
            }, 500);
        }

        function getAlignedVersionNumbers() {
            const classificationVersions = (currentData.timeline || [])
                .map(item => item.version_number);
            const evaluatedVersions = currentData.modelVersions
                .filter(v => v.has_evaluation)
                .map(v => v.version_number);
            const combinedSet = new Set([...classificationVersions, ...evaluatedVersions]);
            const combined = Array.from(combinedSet).sort((a, b) => a - b);
            return combined;
        }

        // Chart instances for proper cleanup
        let distributionChart = null;
        let evalAccuracyChart = null;
        let evalMetricsChart = null;
        
        // Zoom state
        let zoomState = {
            visibleCount: null, // null means show all
            startIndex: null   // null means start from latest
        };

        // Load initial data
        async function loadInitialData() {
            try {
                // Load summary
                const summaryResponse = await fetch('/api/ml-hunt-comparison/summary');
                const summaryData = await summaryResponse.json();
                if (summaryData.success) {
                    currentData.summary = summaryData.summary;
                    updateSummaryStats();
                }

                // Load stats
                const statsResponse = await fetch('/api/ml-hunt-comparison/stats');
                const statsData = await statsResponse.json();
                if (statsData.success) {
                    currentData.stats = statsData.stats;
            }
            
            // Load model versions for evaluation metrics
            const versionsResponse = await fetch('/api/model/versions');
            const versionsData = await versionsResponse.json();
            if (versionsData.success) {
                currentData.modelVersions = versionsData.versions;
            }

            // Load classification timeline
            const timelineResponse = await fetch('/api/model/classification-timeline');
            const timelineData = await timelineResponse.json();
            if (timelineData.success) {
                currentData.timeline = timelineData.timeline;
            }
            
            
            
            // Check feedback count and disable retrain button if no feedback available
            const feedbackResponse = await fetch('/api/model/feedback-count');
            const feedbackData = await feedbackResponse.json();
            
            // Update feedback count display
            const feedbackElement = document.getElementById('feedbackCount');
            if (feedbackElement && feedbackData.success) {
                feedbackElement.textContent = feedbackData.count.toLocaleString();
                
                // Show breakdown if available
                const breakdownElement = document.getElementById('feedbackBreakdown');
                if (breakdownElement && feedbackData.total_feedback_count && feedbackData.total_annotation_count) {
                    const usedFeedback = feedbackData.total_feedback_count - feedbackData.feedback_count;
                    const usedAnnotations = feedbackData.total_annotation_count - feedbackData.annotation_count;
                    breakdownElement.textContent = `(${feedbackData.feedback_count} unused feedback, ${feedbackData.annotation_count} unused annotations)`;
                    
                    // Show total breakdown
                    const totalBreakdown = document.getElementById('totalDataBreakdown');
                    if (totalBreakdown) {
                        totalBreakdown.textContent = `Total: ${feedbackData.total_feedback_count} feedback (${usedFeedback} used), ${feedbackData.total_annotation_count} annotations (${usedAnnotations} used)`;
                    }
                }
            }
            
            if (feedbackData.success && feedbackData.count === 0) {
                const retrainBtn = document.getElementById('retrainModelBtn');
                retrainBtn.disabled = true;
                retrainBtn.classList.add('opacity-50', 'cursor-not-allowed');
                retrainBtn.title = 'No feedback available for retraining';
            }
            
                    updateCharts();
            } catch (error) {
                console.error('Error loading initial data:', error);
                showError('Failed to load initial data');
            }
        }

        function updateSummaryStats() {
            const summary = currentData.summary;
        document.getElementById('totalModelVersions').textContent = summary.total_model_versions;
        document.getElementById('totalChunkAnalyses').textContent = summary.total_chunk_analyses.toLocaleString();
            
        if (summary.overall_stats && summary.overall_stats.length > 0) {
                const avgAccuracy = summary.overall_stats.reduce((sum, stat) => sum + stat.accuracy, 0) / summary.overall_stats.length;
            document.getElementById('averageAccuracy').textContent = (avgAccuracy * 100).toFixed(1) + '%';
            }
            
            if (summary.last_updated) {
                const date = new Date(summary.last_updated);
                document.getElementById('lastUpdated').textContent = date.toLocaleDateString();
            }
        }

        function updateCharts() {
        updateEvaluationCharts();
    }



    function updateEvaluationCharts() {
        updateEvalAccuracyChart();
    }

    function updateEvalAccuracyChart() {
        const ctx = document.getElementById('evalAccuracyChart').getContext('2d');
        
        // Destroy existing chart if it exists
        if (evalAccuracyChart) {
            evalAccuracyChart.destroy();
            evalAccuracyChart = null;
        }
        
        let timelineVersions = getAlignedVersionNumbers();
        const evaluatedVersionMap = new Map(
            currentData.modelVersions
                .filter(v => v.has_evaluation)
                .map(v => [v.version_number, v])
        );

        if (timelineVersions.length === 0) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillText('No timeline data available', 10, 50);
            return;
        }
        
        // Apply zoom filter
        if (zoomState.visibleCount !== null && zoomState.visibleCount < timelineVersions.length) {
            const totalVersions = timelineVersions.length;
            const startIdx = zoomState.startIndex !== null 
                ? zoomState.startIndex 
                : Math.max(0, totalVersions - zoomState.visibleCount);
            const endIdx = startIdx + zoomState.visibleCount;
            timelineVersions = timelineVersions.slice(startIdx, endIdx);
        }
        
        const accuracyPoints = timelineVersions.map(versionNumber => {
            const version = evaluatedVersionMap.get(versionNumber);
            return version && version.eval_accuracy != null
                ? (version.eval_accuracy * 100)
                : null;
        });

        const precisionPoints = timelineVersions.map(versionNumber => {
            const version = evaluatedVersionMap.get(versionNumber);
            return version && version.eval_precision_huntable != null
                ? (version.eval_precision_huntable * 100)
                : null;
        });

        const recallPoints = timelineVersions.map(versionNumber => {
            const version = evaluatedVersionMap.get(versionNumber);
            return version && version.eval_recall_huntable != null
                ? (version.eval_recall_huntable * 100)
                : null;
        });

        const f1Points = timelineVersions.map(versionNumber => {
            const version = evaluatedVersionMap.get(versionNumber);
            return version && version.eval_f1_score_huntable != null
                ? (version.eval_f1_score_huntable * 100)
                : null;
        });

        const evaluatedCount = accuracyPoints.filter(value => value !== null).length;

        if (evaluatedCount === 0) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillText('No evaluation data available', 10, 50);
            return;
        }
        
        // Set minimum width for chart container based on visible data points
        const chartContainer = document.getElementById('chartContainer');
        const scrollContainer = chartContainer?.parentElement;
        if (chartContainer) {
            const visibleCount = timelineVersions.length;
            const minWidth = Math.max(800, visibleCount * 80);
            chartContainer.style.minWidth = minWidth + 'px';
        }
        
            evalAccuracyChart = new Chart(ctx, {
            type: 'line',
                data: {
                labels: timelineVersions.map(v => `v${v}`),
                    datasets: [{
                    label: 'Accuracy %',
                    data: accuracyPoints,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1,
                    spanGaps: true
                    }, {
                    label: 'Precision %',
                    data: precisionPoints,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1,
                    spanGaps: true
                    }, {
                    label: 'Recall %',
                    data: recallPoints,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1,
                    spanGaps: true
                    }, {
                    label: 'F1 Score %',
                    data: f1Points,
                    borderColor: 'rgba(255, 206, 86, 1)',
                    backgroundColor: 'rgba(255, 206, 86, 0.2)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1,
                    spanGaps: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        },
                        x: {
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const labelVersion = timelineVersions[context.dataIndex];
                                if (context.parsed.y === null) {
                                    return `v${labelVersion}: No evaluation data`;
                                }
                                return `v${labelVersion}: ${context.parsed.y.toFixed(1)}%`;
                            }
                        }
                    }
                }
                }
            });
            
            // Scroll to show latest models by default
            if (scrollContainer && timelineVersions.length > 0) {
                // Wait for chart to render, then scroll to right
                setTimeout(() => {
                    scrollContainer.scrollLeft = scrollContainer.scrollWidth;
                }, 100);
            }
            
            updateZoomLevelDisplay();
        }
        
        function updateZoomLevelDisplay() {
            const zoomLevelEl = document.getElementById('zoomLevel');
            if (!zoomLevelEl) return;
            
            const allVersions = getAlignedVersionNumbers();
            const totalCount = allVersions.length;
            
            if (zoomState.visibleCount === null || zoomState.visibleCount >= totalCount) {
                zoomLevelEl.textContent = `All (${totalCount})`;
            } else {
                zoomLevelEl.textContent = `${zoomState.visibleCount}/${totalCount}`;
            }
        }
        
        function zoomIn() {
            const allVersions = getAlignedVersionNumbers();
            const totalCount = allVersions.length;
            
            if (totalCount === 0) return;
            
            // Define zoom levels: 5, 10, 15, 20, 30, 50, then all
            const zoomLevels = [5, 10, 15, 20, 30, 50, totalCount];
            
            if (zoomState.visibleCount === null) {
                // Currently showing all, zoom to largest preset
                zoomState.visibleCount = Math.min(50, totalCount);
            } else {
                // Find next smaller zoom level
                const currentIdx = zoomLevels.findIndex(level => level >= zoomState.visibleCount);
                if (currentIdx > 0) {
                    zoomState.visibleCount = zoomLevels[currentIdx - 1];
                } else {
                    // Already at minimum zoom, do nothing
                    return;
                }
            }
            
            // Keep showing latest models
            zoomState.startIndex = null;
            
            updateEvalAccuracyChart();
        }
        
        function zoomOut() {
            const allVersions = getAlignedVersionNumbers();
            const totalCount = allVersions.length;
            
            if (totalCount === 0) return;
            
            // Define zoom levels: 5, 10, 15, 20, 30, 50, then all
            const zoomLevels = [5, 10, 15, 20, 30, 50, totalCount];
            
            if (zoomState.visibleCount === null) {
                // Already showing all, do nothing
                return;
            }
            
            // Find next larger zoom level
            const currentIdx = zoomLevels.findIndex(level => level > zoomState.visibleCount);
            if (currentIdx !== -1) {
                zoomState.visibleCount = zoomLevels[currentIdx];
            } else {
                // Show all
                zoomState.visibleCount = null;
            }
            
            // Keep showing latest models
            zoomState.startIndex = null;
            
            updateEvalAccuracyChart();
        }


    function showError(message) {
        console.error(message);
        // Could add a toast notification here
    }

        // Backfill functions
        async function checkEligibleCount() {
            const countElement = document.getElementById('eligibleCount');
            
            if (!countElement) {
                console.error('eligibleCount element not found in DOM');
                return;
            }
            
            try {
                countElement.textContent = 'Checking...';
                
                const response = await fetch('/api/ml-hunt-comparison/eligible-count');
                const data = await response.json();
                
                if (data.success) {
                    const countText = data.count === 0 
                        ? 'No eligible articles found' 
                        : `${data.count} article${data.count === 1 ? '' : 's'} eligible for processing`;
                    countElement.textContent = countText;
                    
                    // Show/hide retrain warning based on eligible count
                    updateRetrainWarning(data.count);
                } else {
                    countElement.textContent = 'Error checking eligible articles';
                }
            } catch (error) {
                console.error('Error checking eligible count:', error);
                countElement.textContent = 'Error checking eligible articles';
            }
        }

        function resetButtonState() {
            const btn = document.getElementById('processEligibleBtn');
            if (btn) {
                btn.disabled = false;
                btn.textContent = 'Process All Eligible Articles';
                btn.classList.remove('bg-gray-600', 'hover:bg-gray-700', 'bg-green-600', 'hover:bg-green-700');
                btn.classList.add('bg-blue-600', 'hover:bg-blue-700');
            }
        }

        function updateRetrainWarning(eligibleCount) {
            const warningElement = document.getElementById('retrainWarning');
            const retrainBtn = document.getElementById('retrainModelBtn');
            
            if (!warningElement || !retrainBtn) return;
            
            if (eligibleCount > 0) {
                // Show warning
                warningElement.classList.remove('hidden');
                warningElement.innerHTML = `‚ö†Ô∏è Warning: ${eligibleCount} articles are unprocessed. Consider processing them first for complete workflow.`;
                
                // Add hover warning to retrain button
                retrainBtn.addEventListener('mouseenter', showRetrainHoverWarning);
                retrainBtn.addEventListener('mouseleave', hideRetrainHoverWarning);
                
                // Add click confirmation
                retrainBtn.addEventListener('click', confirmRetrainWithUnprocessed);
            } else {
                // Hide warning
                warningElement.classList.add('hidden');
                
                // Remove event listeners
                retrainBtn.removeEventListener('mouseenter', showRetrainHoverWarning);
                retrainBtn.removeEventListener('mouseleave', hideRetrainHoverWarning);
                retrainBtn.removeEventListener('click', confirmRetrainWithUnprocessed);
            }
        }

        function showRetrainHoverWarning() {
            const tooltip = document.createElement('div');
            tooltip.id = 'retrainTooltip';
            tooltip.className = 'absolute z-50 px-3 py-2 bg-amber-100 dark:bg-amber-900 text-amber-800 dark:text-amber-200 text-sm rounded-lg shadow-lg border border-amber-300 dark:border-amber-700';
            tooltip.innerHTML = '‚ö†Ô∏è You have unprocessed articles. Consider processing them first for complete ML vs Hunt comparison workflow.';
            
            const btn = document.getElementById('retrainModelBtn');
            const rect = btn.getBoundingClientRect();
            tooltip.style.position = 'fixed';
            tooltip.style.top = (rect.top - 50) + 'px';
            tooltip.style.left = rect.left + 'px';
            
            document.body.appendChild(tooltip);
        }

        function hideRetrainHoverWarning() {
            const tooltip = document.getElementById('retrainTooltip');
            if (tooltip) {
                tooltip.remove();
            }
        }

        function confirmRetrainWithUnprocessed(event) {
            const eligibleCount = document.getElementById('eligibleCount').textContent.match(/(\d+)/);
            if (eligibleCount && parseInt(eligibleCount[1]) > 0) {
                const confirmed = confirm(
                    `‚ö†Ô∏è You have ${eligibleCount[1]} unprocessed articles.\n\n` +
                    `Recommended workflow:\n` +
                    `1. Process articles first (for baseline comparison)\n` +
                    `2. Retrain model\n` +
                    `3. Reprocess articles (with new model)\n\n` +
                    `Do you want to proceed with retraining anyway?`
                );
                
                if (!confirmed) {
                    event.preventDefault();
                    event.stopPropagation();
                    return false;
                }
            }
        }

        async function processEligibleArticles() {
            const btn = document.getElementById('processEligibleBtn');
            const countElement = document.getElementById('eligibleCount');
            
            if (!btn || !countElement) {
                console.error('Required elements not found');
                return;
            }
            
            try {
                // Disable button and show progress
                btn.disabled = true;
                btn.textContent = 'Processing...';
                countElement.textContent = 'Processing articles...';
                
                // Show terminal output area
                showTerminalOutput();
                
                // Start polling for real logs
                startProcessingLogPolling();
                
                const response = await fetch('/api/ml-hunt-comparison/backfill', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                    if (data.success) {
                        // Check if processing was successful (even if 0 articles processed)
                        if (data.results && data.results.total_eligible === 0) {
                            countElement.textContent = `‚úÖ No eligible articles to process`;
                            btn.textContent = 'No Articles to Process';
                            btn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                            btn.classList.add('bg-gray-600', 'hover:bg-gray-700');
                        } else if (data.results) {
                            countElement.textContent = `‚úÖ Processed ${data.results.successful}/${data.results.total_eligible} articles`;
                            btn.textContent = 'Processing Complete';
                            btn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                            btn.classList.add('bg-green-600', 'hover:bg-green-700');
                        } else {
                            // Background processing started
                            countElement.textContent = `üîÑ Processing started in background...`;
                            btn.textContent = 'Processing...';
                        }
                        
                        // Fetch logs again after a short delay in case final entries just wrote
                        setTimeout(() => {
                            pollLogs();
                        }, 500);
                        
                        // Refresh eligible count and update warnings
                        setTimeout(() => {
                            checkEligibleCount();
                        }, 1000);
                    } else {
                        throw new Error(data.message || 'Processing failed');
                    }
            } catch (error) {
                console.error('Error processing articles:', error);
                handleProcessingFailure();
                
                // Update terminal with error
                updateTerminalOutput(`‚ùå Processing Failed!\n` +
                    `Error: ${error.message}\n` +
                    `Failed at ${new Date().toLocaleTimeString()}`);
            }
        }

            async function pollLogs() {
                try {
                    // Add cache-busting parameter to force fresh data
                    const timestamp = new Date().getTime();
                    console.log('Polling logs at:', new Date().toISOString());
                    
                    const response = await fetch(`/api/ml-hunt-comparison/logs?t=${timestamp}`);
                    console.log('Fetch response status:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    console.log('Logs API response:', {
                        success: data.success,
                        logsLength: data.logs ? data.logs.length : 0,
                        logsPreview: data.logs ? data.logs.substring(0, 100) : 'No logs'
                    });
                    
                    if (data.success && data.logs) {
                        const logPayload = data.logs;
                        if (logPayload.includes('‚úÖ Processing Complete!')) {
                            handleProcessingComplete();
                        } else if (logPayload.includes('‚ùå Processing Failed!')) {
                            handleProcessingFailure();
                        }
                        const terminalContent = document.getElementById('terminalContent');
                        if (terminalContent) {
                            console.log('Updating terminal content, length:', logPayload.length);
                            terminalContent.textContent = logPayload;
                            terminalContent.scrollTop = terminalContent.scrollHeight;
                        }
                    } else {
                        console.log('Logs response failed:', data);
                    }
                } catch (error) {
                    console.error('Error polling logs:', error);
                }
            }

            function showTerminalOutput() {
                // Create terminal output area if it doesn't exist
                let terminalDiv = document.getElementById('terminalOutput');
                if (!terminalDiv) {
                    terminalDiv = document.createElement('div');
                    terminalDiv.id = 'terminalOutput';
                    terminalDiv.className = 'fixed z-50 bg-black text-green-400 font-mono text-sm rounded-lg border border-gray-600 overflow-hidden shadow-2xl';
                    terminalDiv.innerHTML = `
                        <div class="flex justify-between items-center p-2 bg-gray-800 text-gray-300 text-xs border-b border-gray-600">
                            <span>üìü Real-Time Processing Logs</span>
                            <button id="closeTerminal" class="text-gray-400 hover:text-white">‚úï</button>
                        </div>
                        <div class="p-4 overflow-y-auto" style="height: 250px;">
                            <div id="terminalContent">üîÑ Fetching logs...</div>
                        </div>
                    `;
                
                    // Position terminal with smart viewport detection
                    const processBtn = document.getElementById('processEligibleBtn');
                    if (processBtn) {
                        const rect = processBtn.getBoundingClientRect();
                        const terminalWidth = 400;
                        const terminalHeight = 300;
                        
                        // Calculate optimal position
                        let left = rect.left - terminalWidth + 50; // Offset from button
                        let top = rect.top - terminalHeight - 20; // Above button
                        
                        // Ensure terminal stays within viewport bounds
                        const viewportWidth = window.innerWidth;
                        const viewportHeight = window.innerHeight;
                        
                        // Adjust horizontal position if it goes off screen
                        if (left < 20) left = 20;
                        if (left + terminalWidth > viewportWidth - 20) {
                            left = viewportWidth - terminalWidth - 20;
                        }
                        
                        // Adjust vertical position if it goes off screen
                        if (top < 20) {
                            // If can't fit above, position below button
                            top = rect.bottom + 20;
                            if (top + terminalHeight > viewportHeight - 20) {
                                // If still doesn't fit, center vertically
                                top = Math.max(20, (viewportHeight - terminalHeight) / 2);
                            }
                        }
                        
                        terminalDiv.style.position = 'fixed';
                        terminalDiv.style.top = top + 'px';
                        terminalDiv.style.left = left + 'px';
                        terminalDiv.style.width = terminalWidth + 'px';
                        terminalDiv.style.maxWidth = '90vw';
                        terminalDiv.style.maxHeight = '80vh';
                    }
                
                document.body.appendChild(terminalDiv);
                
                    // Add close button functionality
                    document.getElementById('closeTerminal').addEventListener('click', () => {
                        terminalDiv.remove();
                        // Reset the button and count when the terminal is closed
                        resetButtonState();
                        checkEligibleCount();
                    });
                    
                    // Make terminal draggable
                    makeTerminalDraggable(terminalDiv);
                }
            }

        function makeTerminalDraggable(terminalDiv) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            const header = terminalDiv.querySelector('.flex.justify-between');
            
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialX = parseInt(terminalDiv.style.left) || 0;
                initialY = parseInt(terminalDiv.style.top) || 0;
                terminalDiv.style.cursor = 'grabbing';
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    terminalDiv.style.left = (initialX + deltaX) + 'px';
                    terminalDiv.style.top = (initialY + deltaY) + 'px';
                }
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
                terminalDiv.style.cursor = 'default';
            });
        }

        function updateTerminalOutput(message) {
            const terminalContent = document.getElementById('terminalContent');
            if (terminalContent) {
                terminalContent.innerHTML += message;
                terminalContent.scrollTop = terminalContent.scrollHeight;
            }
        }



    function generateRetrainResults(status) {
        const evalMetrics = status.evaluation_metrics || {};
        
        return `
            <div class="space-y-6">
                <!-- Retraining Summary -->
                <div class="text-green-600 font-semibold text-lg">‚úÖ Retraining Complete</div>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">New Version</div>
                        <div class="text-xl font-bold text-blue-600">v${status.new_version || 'Unknown'}</div>
                    </div>
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">Training Samples</div>
                        <div class="text-xl font-bold text-green-600">${status.training_samples || 'Unknown'}</div>
                    </div>
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">Training Accuracy</div>
                        <div class="text-xl font-bold text-purple-600">${status.training_accuracy ? (status.training_accuracy * 100).toFixed(1) + '%' : 'N/A'}</div>
                    </div>
                    <div class="bg-white dark:bg-gray-600 p-3 rounded">
                        <div class="text-sm text-gray-600 dark:text-gray-300">Duration</div>
                        <div class="text-xl font-bold text-orange-600">${status.training_duration || 'Unknown'}</div>
                    </div>
                </div>
                
                ${evalMetrics.accuracy ? `
                <!-- Evaluation Results -->
                <div class="border-t pt-4">
                    <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">üìä Evaluation Results</h3>
                    
                    <!-- Overall Metrics -->
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                        <div class="bg-white dark:bg-gray-600 p-3 rounded">
                            <div class="text-sm text-gray-600 dark:text-gray-300">Test Accuracy</div>
                            <div class="text-2xl font-bold text-blue-600">${(evalMetrics.accuracy * 100).toFixed(1)}%</div>
                        </div>
                        <div class="bg-white dark:bg-gray-600 p-3 rounded">
                            <div class="text-sm text-gray-600 dark:text-gray-300">Avg Confidence</div>
                            <div class="text-2xl font-bold text-green-600">${evalMetrics.avg_confidence ? (evalMetrics.avg_confidence * 100).toFixed(1) + '%' : 'N/A'}</div>
                        </div>
                        <div class="bg-white dark:bg-gray-600 p-3 rounded">
                            <div class="text-sm text-gray-600 dark:text-gray-300">Total Chunks</div>
                            <div class="text-2xl font-bold text-purple-600">${evalMetrics.total_chunks || evalMetrics.total_eval_chunks || 'N/A'}</div>
                        </div>
                        <div class="bg-white dark:bg-gray-600 p-3 rounded">
                            <div class="text-sm text-gray-600 dark:text-gray-300">Misclassified</div>
                            <div class="text-2xl font-bold text-red-600">${evalMetrics.misclassified_count || 'N/A'}</div>
                        </div>
                    </div>
                    
                    <!-- Per-Class Metrics -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div class="bg-white dark:bg-gray-600 p-4 rounded">
                            <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Huntable Class</h4>
                            <div class="space-y-1 text-sm">
                                <div>Precision: <span class="font-mono">${evalMetrics.precision_huntable ? (evalMetrics.precision_huntable * 100).toFixed(1) + '%' : 'N/A'}</span></div>
                                <div>Recall: <span class="font-mono">${evalMetrics.recall_huntable ? (evalMetrics.recall_huntable * 100).toFixed(1) + '%' : 'N/A'}</span></div>
                                <div>F1 Score: <span class="font-mono">${evalMetrics.f1_score_huntable ? (evalMetrics.f1_score_huntable * 100).toFixed(1) + '%' : 'N/A'}</span></div>
                            </div>
                        </div>
                        <div class="bg-white dark:bg-gray-600 p-4 rounded">
                            <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Not Huntable Class</h4>
                            <div class="space-y-1 text-sm">
                                <div>Precision: <span class="font-mono">${evalMetrics.precision_not_huntable ? (evalMetrics.precision_not_huntable * 100).toFixed(1) + '%' : 'N/A'}</span></div>
                                <div>Recall: <span class="font-mono">${evalMetrics.recall_not_huntable ? (evalMetrics.recall_not_huntable * 100).toFixed(1) + '%' : 'N/A'}</span></div>
                                <div>F1 Score: <span class="font-mono">${evalMetrics.f1_score_not_huntable ? (evalMetrics.f1_score_not_huntable * 100).toFixed(1) + '%' : 'N/A'}</span></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Confusion Matrix -->
                    ${evalMetrics.confusion_matrix ? `
                    <div class="bg-white dark:bg-gray-600 p-4 rounded">
                        <h4 class="font-semibold text-gray-900 dark:text-white mb-2">Confusion Matrix</h4>
                        <div class="grid grid-cols-3 gap-2 text-sm">
                            <div></div>
                            <div class="text-center font-semibold">Predicted Not Huntable</div>
                            <div class="text-center font-semibold">Predicted Huntable</div>
                            <div class="font-semibold">Actual Not Huntable</div>
                            <div class="text-center bg-green-100 dark:bg-green-800 p-2 rounded">${evalMetrics.confusion_matrix.true_negative}</div>
                            <div class="text-center bg-red-100 dark:bg-red-800 p-2 rounded">${evalMetrics.confusion_matrix.false_positive}</div>
                            <div class="font-semibold">Actual Huntable</div>
                            <div class="text-center bg-red-100 dark:bg-red-800 p-2 rounded">${evalMetrics.confusion_matrix.false_negative}</div>
                            <div class="text-center bg-green-100 dark:bg-green-800 p-2 rounded">${evalMetrics.confusion_matrix.true_positive}</div>
                        </div>
                    </div>
                    ` : ''}
                </div>
                ` : ''}
            </div>
        `;
    }

    function showMetricsHelp() {
        const tooltip = document.getElementById('metricsHelpTooltip');
        if (tooltip) {
            tooltip.classList.toggle('opacity-0');
            tooltip.classList.toggle('invisible');
            tooltip.classList.toggle('opacity-100');
            tooltip.classList.toggle('visible');
        }
    }


    // Model Retraining functions
    async function retrainModel() {
        const btn = document.getElementById('retrainModelBtn');
        const progressSection = document.getElementById('retrainProgressSection');
        const resultsSection = document.getElementById('retrainResultsSection');
        const progressBar = document.getElementById('retrainProgressBar');
        const progressText = document.getElementById('retrainProgressText');
        const resultsContent = document.getElementById('retrainResultsContent');
        
        // Disable button and show progress
        btn.disabled = true;
        btn.textContent = 'Retraining...';
        progressSection.classList.remove('hidden');
        resultsSection.classList.add('hidden');
        progressBar.style.width = '0%';
        progressText.textContent = 'Starting retraining...';
        
        try {
            // Start retraining
            const response = await fetch('/api/model/retrain', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Start polling for status updates
                pollRetrainingStatus();
            } else {
                throw new Error(data.message || 'Retraining failed');
            }
            
        } catch (error) {
            console.error('Error during retraining:', error);
            resultsSection.classList.remove('hidden');
            resultsContent.innerHTML = `
                <div class="text-red-600 font-semibold">‚ùå Retraining Failed</div>
                <div class="mt-2 text-red-600">${error.message}</div>
            `;
        } finally {
            // Re-enable button
            btn.disabled = false;
            btn.textContent = 'Retrain Model';
            setTimeout(() => {
                progressSection.classList.add('hidden');
            }, 3000);
        }
    }
    
    async function pollRetrainingStatus() {
        const progressBar = document.getElementById('retrainProgressBar');
        const progressText = document.getElementById('retrainProgressText');
        const resultsSection = document.getElementById('retrainResultsSection');
        const resultsContent = document.getElementById('retrainResultsContent');
        const btn = document.getElementById('retrainModelBtn');
        
        const pollInterval = setInterval(async () => {
            try {
                const response = await fetch('/api/model/retrain-status');
                const status = await response.json();
                
                // Update progress
                progressBar.style.width = `${status.progress || 0}%`;
                progressText.textContent = status.message || 'Retraining...';
                
                if (status.status === 'complete') {
                    clearInterval(pollInterval);
                    
                    // Show results with evaluation metrics
                    resultsSection.classList.remove('hidden');
                    resultsContent.innerHTML = generateRetrainResults(status);
                    
                    // Update status
                    const statusElement = document.getElementById('retrainingStatus');
                    const accuracy = status.training_accuracy ? (status.training_accuracy * 100).toFixed(1) : 'N/A';
                    statusElement.textContent = `v${status.new_version || 'Unknown'} (${accuracy}% accuracy)`;
                    statusElement.classList.remove('cursor-help');
                    statusElement.removeAttribute('title');
                    
                    // Re-enable button
                    btn.disabled = false;
                    btn.textContent = 'Retrain Model';
                    
                    // Reload data
                    setTimeout(() => {
                        loadInitialData();
                    }, 1000);
                    
                } else if (status.status === 'error') {
                    clearInterval(pollInterval);
                    
                    // Show error
                    resultsSection.classList.remove('hidden');
                    resultsContent.innerHTML = `
                        <div class="text-red-600 font-semibold">‚ùå Retraining Failed</div>
                        <div class="mt-2">
                            <p>${status.message || 'Unknown error occurred'}</p>
                        </div>
                    `;
                    
                    // Re-enable button
                    btn.disabled = false;
                    btn.textContent = 'Retrain Model';
                }
                
            } catch (error) {
                console.error('Error polling retraining status:', error);
                clearInterval(pollInterval);
                
                // Show error
                resultsSection.classList.remove('hidden');
                resultsContent.innerHTML = `
                    <div class="text-red-600 font-semibold">‚ùå Error Checking Status</div>
                    <div class="mt-2">
                        <p>Failed to check retraining status: ${error.message}</p>
                    </div>
                `;
                
                // Re-enable button
                btn.disabled = false;
                btn.textContent = 'Retrain Model';
            }
        }, 2000); // Poll every 2 seconds
    }
    
    async function refreshRetrainingStatus() {
        const statusElement = document.getElementById('retrainingStatus');
        const feedbackElement = document.getElementById('feedbackCount');
        const retrainBtn = document.getElementById('retrainModelBtn');
        const refreshBtn = document.getElementById('refreshRetrainBtn');
        
        try {
            // Show loading state on refresh button
            refreshBtn.disabled = true;
            refreshBtn.textContent = 'Refreshing...';
            
            statusElement.textContent = 'Checking...';
            feedbackElement.textContent = 'Loading...';
            
            // Get latest model version and feedback count
            const [versionsResponse, feedbackResponse] = await Promise.all([
                fetch('/api/model/versions'),
                fetch('/api/model/feedback-count')
            ]);
            
            const versionsData = await versionsResponse.json();
            const feedbackData = await feedbackResponse.json();
            
            if (versionsData.success && versionsData.versions.length > 0) {
                const latest = versionsData.versions[0]; // Already sorted by version number
                if (latest.accuracy) {
                    const accuracyPercent = (latest.accuracy * 100).toFixed(1);
                    statusElement.textContent = `v${latest.version_number} (${accuracyPercent}% accuracy)`;
                    statusElement.classList.remove('cursor-help');
                    statusElement.removeAttribute('title');
                } else {
                    statusElement.textContent = `v${latest.version_number}`;
                    statusElement.classList.remove('cursor-help');
                    statusElement.removeAttribute('title');
                }
            } else {
                statusElement.textContent = 'None';
                statusElement.classList.remove('cursor-help');
                statusElement.removeAttribute('title');
            }
            
            if (feedbackData.success) {
                const feedbackCount = feedbackData.count;
                feedbackElement.textContent = feedbackCount.toLocaleString();
                
                // Show breakdown if available
                const breakdownElement = document.getElementById('feedbackBreakdown');
                if (breakdownElement && feedbackData.total_feedback_count && feedbackData.total_annotation_count) {
                    const usedFeedback = feedbackData.total_feedback_count - feedbackData.feedback_count;
                    const usedAnnotations = feedbackData.total_annotation_count - feedbackData.annotation_count;
                    breakdownElement.textContent = `(${feedbackData.feedback_count} unused feedback, ${feedbackData.annotation_count} unused annotations)`;
                    
                    // Show total breakdown
                    const totalBreakdown = document.getElementById('totalDataBreakdown');
                    if (totalBreakdown) {
                        totalBreakdown.textContent = `Total: ${feedbackData.total_feedback_count} feedback (${usedFeedback} used), ${feedbackData.total_annotation_count} annotations (${usedAnnotations} used)`;
                    }
                }
                
                // Enable/disable retrain button based on feedback availability
                if (feedbackCount === 0) {
                    retrainBtn.disabled = true;
                    retrainBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    retrainBtn.title = 'No feedback available for retraining';
                } else {
                    retrainBtn.disabled = false;
                    retrainBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    retrainBtn.title = '';
                }
            } else {
                feedbackElement.textContent = 'Error';
                retrainBtn.disabled = true;
                retrainBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
            
        } catch (error) {
            console.error('Error refreshing retraining status:', error);
            statusElement.textContent = 'Error';
            feedbackElement.textContent = 'Error';
            retrainBtn.disabled = true;
            retrainBtn.classList.add('opacity-50', 'cursor-not-allowed');
        } finally {
            // Re-enable refresh button
            refreshBtn.disabled = false;
            refreshBtn.textContent = 'Refresh Status';
        }
    }


        document.addEventListener('DOMContentLoaded', () => {
            loadInitialData();
            checkEligibleCount();
            refreshRetrainingStatus();
            
            // Add event listeners
            document.getElementById('retrainModelBtn').addEventListener('click', retrainModel);
            document.getElementById('refreshRetrainBtn').addEventListener('click', refreshRetrainingStatus);
            document.getElementById('processEligibleBtn').addEventListener('click', processEligibleArticles);
            
            // Zoom controls
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', zoomIn);
            }
            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', zoomOut);
            }
        });
    </script>
{% endblock %}

<style>
.rotate-180 {
    transform: rotate(180deg);
}
</style>
