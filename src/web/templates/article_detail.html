{% extends "base.html" %}

{% block title %}{{ article.title[:50] }}... - Huntable CTI Scraper{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <!-- Breadcrumb -->
    <nav class="flex mb-8" aria-label="Breadcrumb">
        <ol class="inline-flex items-center space-x-1 md:space-x-3">
            <li class="inline-flex items-center">
                <a href="/" class="inline-flex items-center text-sm font-medium text-gray-700 dark:text-gray-300 hover:text-blue-600 dark:hover:text-blue-400">
                    <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"></path>
                    </svg>
                    Dashboard
                </a>
            </li>
            <li>
                <div class="flex items-center">
                    <svg class="w-6 h-6 text-gray-400 dark:text-gray-500" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path>
                    </svg>
                    <a href="/articles" class="ml-1 text-sm font-medium text-gray-700 dark:text-gray-300 hover:text-blue-600 dark:hover:text-blue-400 md:ml-2">Articles</a>
                </div>
            </li>
            <li aria-current="page">
                <div class="flex items-center">
                    <svg class="w-6 h-6 text-gray-400 dark:text-gray-500" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path>
                    </svg>
                    <span class="ml-1 text-sm font-medium text-gray-500 dark:text-gray-400 md:ml-2">Article #{{ article.id }}</span>
                </div>
            </li>
        </ol>
    </nav>

    <!-- Article Header -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <div class="flex items-start justify-between">
            <div class="flex-1">
                <h1 class="text-3xl font-bold text-gray-900 dark:text-white mb-6 leading-tight">{{ article.title }}</h1>
                
                <div class="flex items-center space-x-6 text-sm text-gray-600 dark:text-gray-400 mb-6">
                    <div class="flex items-center">
                        <span class="mr-2">üì∞</span>
                        <span>Source: 
                            {% if article.canonical_url %}
                                <a href="{{ article.canonical_url }}" target="_blank" class="text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 hover:underline">
                                    {{ source.name if source else article.source_id }}
                                </a>
                            {% else %}
                                {{ source.name if source else article.source_id }}
                            {% endif %}
                        </span>
                    </div>
                    {% if article.published_at %}
                    <div class="flex items-center">
                        <span class="mr-2">üìÖ</span>
                        <span>{{ article.published_at.strftime('%Y-%m-%d %H:%M:%S') }}</span>
                    </div>
                    {% endif %}
                    <div class="flex items-center">
                        <span class="mr-2">üìä</span>
                        <span>{{ article.content|length }} characters</span>
                    </div>
                    <div class="flex items-center">
                        <span class="mr-2">üÜî</span>
                        <span>#{{ article.id }}</span>
                    </div>
                    {% if article.article_metadata and article.article_metadata.get('threat_hunting_score') is not none %}
                    <div class="flex items-center">
                        <span class="mr-2">üéØ</span>
                        <span>Threat Hunting Score: 
                            {% set score = article.article_metadata.get('threat_hunting_score', 0) %}
                            {% if score >= 80 %}
                                <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 border border-green-200 dark:border-green-700">
                                    üéØ {{ "%.1f"|format(score) }}
                                </span>
                            {% elif score >= 60 %}
                                <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 border border-yellow-200 dark:border-yellow-700">
                                    üü° {{ "%.1f"|format(score) }}
                                </span>
                            {% elif score >= 40 %}
                                <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-orange-100 dark:bg-orange-900 text-orange-800 dark:text-orange-200 border border-orange-200 dark:border-orange-700">
                                    üü† {{ "%.1f"|format(score) }}
                                </span>
                            {% else %}
                                <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 border border-red-200 dark:border-red-700">
                                    üî¥ {{ "%.1f"|format(score) }}
                                </span>
                            {% endif %}
                        </span>
                    </div>
                    {% endif %}
                </div>

                {% if article.canonical_url %}
                <div class="mb-4">
                    <a href="{{ article.canonical_url }}" target="_blank" 
                       class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 transition-colors">
                        <span class="mr-2">üîó</span>
                        View Original Source
                    </a>
                </div>
                {% endif %}
                
                <!-- Delete Article Button -->
                <div class="mb-4">
                    <button onclick="deleteArticle({{ article.id }})" 
                            class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700 transition-colors">
                        <span class="mr-2">üóëÔ∏è</span>
                        Delete Article
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Keyword Matches Display -->
    {% if article.article_metadata %}
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <button 
            onclick="toggleKeywordMatches()" 
            class="flex items-center justify-between w-full text-left focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-lg"
            aria-expanded="false"
            aria-controls="keyword-matches-content"
        >
            <h2 class="text-xl font-bold text-gray-900 dark:text-white">üéØ Keyword Matches</h2>
            <svg 
                id="keyword-matches-chevron" 
                class="w-6 h-6 text-gray-500 dark:text-gray-400 transform transition-transform duration-200" 
                fill="none" 
                stroke="currentColor" 
                viewBox="0 0 24 24"
            >
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
            </svg>
        </button>
        
        <div id="keyword-matches-content" class="hidden mt-6">
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
            <!-- Perfect Discriminators -->
            <div class="card bg-green-100 dark:bg-green-800 border border-green-300 dark:border-green-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-green-800 dark:text-green-200 flex items-center">
                        <span class="mr-2">‚úÖ</span>
                        Perfect Discriminators
                    </h3>
                    <span class="text-xs font-bold text-white bg-green-600 dark:bg-green-600 px-2 py-1 rounded-full">
                        75 pts
                    </span>
                </div>
                <div class="flex flex-wrap gap-1">
                    {% for keyword in article.article_metadata.get('perfect_keyword_matches', []) %}
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200 border border-green-200 dark:border-green-600">
                        {{ keyword }}
                    </span>
                    {% endfor %}
                    {% if not article.article_metadata.get('perfect_keyword_matches') %}
                    <span class="text-xs text-gray-500 dark:text-gray-400 italic">No matches</span>
                    {% endif %}
                </div>
            </div>
            
            <!-- Good Discriminators -->
            <div class="card bg-purple-100 dark:bg-purple-800 border border-purple-300 dark:border-purple-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-purple-800 dark:text-purple-200 flex items-center">
                        <span class="mr-2">üü£</span>
                        Good Discriminators
                    </h3>
                    <span class="text-xs font-bold text-white bg-purple-600 dark:bg-purple-600 px-2 py-1 rounded-full">
                        5 pts
                    </span>
                </div>
                <div class="flex flex-wrap gap-1">
                    {% for keyword in article.article_metadata.get('good_keyword_matches', []) %}
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-purple-100 dark:bg-purple-800 text-purple-800 dark:text-purple-200 border border-purple-200 dark:border-purple-600">
                        {{ keyword }}
                    </span>
                    {% endfor %}
                    {% if not article.article_metadata.get('good_keyword_matches') %}
                    <span class="text-xs text-gray-500 dark:text-gray-400 italic">No matches</span>
                    {% endif %}
                </div>
            </div>
            
            <!-- LOLBAS Executables -->
            <div class="card bg-blue-100 dark:bg-blue-800 border border-blue-300 dark:border-blue-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-blue-800 dark:text-blue-200 flex items-center">
                        <span class="mr-2">üîß</span>
                        LOLBAS Executables
                    </h3>
                    <span class="text-xs font-bold text-white bg-blue-600 dark:bg-blue-600 px-2 py-1 rounded-full">
                        10 pts
                    </span>
                </div>
                <div class="flex flex-wrap gap-1">
                    {% for keyword in article.article_metadata.get('lolbas_matches', []) %}
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-blue-100 dark:bg-blue-800 text-blue-800 dark:text-blue-200 border border-blue-200 dark:border-blue-600">
                        {{ keyword }}
                    </span>
                    {% endfor %}
                    {% if not article.article_metadata.get('lolbas_matches') %}
                    <span class="text-xs text-gray-500 dark:text-gray-400 italic">No matches</span>
                    {% endif %}
                </div>
            </div>
            
            <!-- Intelligence Indicators -->
            <div class="card bg-red-100 dark:bg-red-800 border border-red-300 dark:border-red-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-red-800 dark:text-red-200 flex items-center">
                        <span class="mr-2">üéØ</span>
                        Intelligence Indicators
                    </h3>
                    <span class="text-xs font-bold text-white bg-red-600 dark:bg-red-600 px-2 py-1 rounded-full">
                        10 pts
                    </span>
                </div>
                <div class="flex flex-wrap gap-1">
                    {% for keyword in article.article_metadata.get('intelligence_matches', []) %}
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-red-100 dark:bg-red-800 text-red-800 dark:text-red-200 border border-red-200 dark:border-red-600">
                        {{ keyword }}
                    </span>
                    {% endfor %}
                    {% if not article.article_metadata.get('intelligence_matches') %}
                    <span class="text-xs text-gray-500 dark:text-gray-400 italic">No matches</span>
                    {% endif %}
                </div>
            </div>
            
            <!-- Negative Indicators -->
            <div class="card bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-gray-800 dark:text-gray-200 flex items-center">
                        <span class="mr-2">‚ö†Ô∏è</span>
                        Negative Indicators
                    </h3>
                    <span class="text-xs font-bold text-white bg-gray-600 dark:bg-gray-600 px-2 py-1 rounded-full">
                        -10 pts
                    </span>
                </div>
                <div class="flex flex-wrap gap-1">
                    {% for keyword in article.article_metadata.get('negative_matches', []) %}
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-gray-100 dark:bg-gray-800 text-gray-800 dark:text-gray-200 border border-gray-200 dark:border-gray-600">
                        {{ keyword }}
                    </span>
                    {% endfor %}
                    {% if not article.article_metadata.get('negative_matches') %}
                    <span class="text-xs text-gray-500 dark:text-gray-400 italic">No matches</span>
                    {% endif %}
                </div>
            </div>
            
            </div>
        </div>
        
    </div>
    {% endif %}

    <!-- Classification Controls -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <h2 class="text-xl font-bold text-gray-900 dark:text-white mb-6">üè∑Ô∏è Article Classification</h2>
        
        <!-- Settings Status -->
        <!-- Current Classification Status -->
        <div class="mb-6">
            {% if article.article_metadata and article.article_metadata.get('training_category') %}
                <div class="flex items-center space-x-2">
                    <span class="text-sm font-medium text-gray-700">Current Status:</span>
                    <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium
                        {% if article.article_metadata.get('training_category') == 'chosen' %}bg-green-100 text-green-800
                        {% elif article.article_metadata.get('training_category') == 'rejected' %}bg-red-100 text-red-800
                        {% else %}bg-gray-100 text-gray-800{% endif %}">
                        {% if article.article_metadata.get('training_category') == 'chosen' %}‚úÖ Chosen
                        {% elif article.article_metadata.get('training_category') == 'rejected' %}‚ùå Rejected
                        {% else %}‚è≥ Unclassified{% endif %}
                    </span>
                    {% if article.article_metadata.get('training_categorized_at') %}
                        <span class="text-sm text-gray-500">({{ article.article_metadata.get('training_categorized_at')[:19] }})</span>
                    {% endif %}
                </div>
            {% else %}
                <div class="flex items-center space-x-2">
                    <span class="text-sm font-medium text-gray-700">Current Status:</span>
                    <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-100 text-gray-800">
                        ‚è≥ Unclassified
                    </span>
                </div>
            {% endif %}
        </div>
        
        
        <!-- Classification Buttons -->
        <div class="flex flex-wrap gap-4 mb-6">
            <button onclick="classifyArticle('chosen')" 
                    class="inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors">
                <span class="mr-2">‚úÖ</span>
                Mark as Chosen
            </button>
            
            <button onclick="classifyArticle('rejected')" 
                    class="inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors">
                <span class="mr-2">‚ùå</span>
                Mark as Rejected
            </button>
            
            <button onclick="classifyArticle('unclassified')" 
                    class="inline-flex items-center px-6 py-3 border border-gray-300 text-base font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                <span class="mr-2">‚è≥</span>
                Mark as Unclassified
            </button>
            
            <!-- AI Assistant Button with Popover -->
            <div class="relative inline-block" id="aiAssistantWrapper">
                <button id="aiAssistantBtn" onclick="showAIAssistant()" 
                        class="inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-purple-600 hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                    <span class="mr-2">ü§ñ</span>
                    AL/ML Assistant
                </button>
                
                
                <!-- Popover explanation -->
                <div id="aiAssistantPopover" class="absolute z-10 top-full left-0 mt-2 hidden w-64">
                    <div class="text-sm text-amber-700 bg-amber-50 border border-amber-200 rounded-md p-3 shadow-lg">
                        <div class="flex items-start">
                            <span class="mr-2 mt-0.5">‚ö†Ô∏è</span>
                            <div>
                                <div class="font-medium">Article too large for AI processing</div>
                                <div class="text-xs text-amber-600 mt-1" id="popoverContent">
                                    Loading...
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Navigation Buttons -->
        <div class="flex flex-wrap gap-4">
            <button onclick="navigateToNextUnclassified()" 
                    class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                <span class="mr-2">‚è≠Ô∏è</span>
                Next Unclassified
            </button>
            
            <button onclick="navigateToPrevious()" 
                    class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                <span class="mr-2">‚èÆÔ∏è</span>
                Previous Article
            </button>
            
            <button onclick="navigateToNext()" 
                    class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                <span class="mr-2">‚è≠Ô∏è</span>
                Next Article
            </button>
        </div>
    </div>
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <h2 class="text-xl font-bold text-gray-900 dark:text-white mb-6">üìÑ Article Content</h2>
        
        <div class="bg-gray-100 dark:bg-gray-900 rounded-lg p-6">
            <div class="flex items-center justify-between mb-6">
                <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200">Article Content</h3>
                <div class="flex items-center space-x-4">
                    <div class="flex items-center space-x-2">
                        <span class="text-sm text-gray-600 dark:text-gray-400">Select text to annotate</span>
                        <div class="flex items-center space-x-1">
                            <span class="w-3 h-3 bg-green-100 dark:bg-green-900 border border-green-300 dark:border-green-700 rounded"></span>
                            <span class="text-xs text-gray-600 dark:text-gray-400">Huntable</span>
                        </div>
                        <div class="flex items-center space-x-1">
                            <span class="w-3 h-3 bg-red-100 dark:bg-red-900 border border-red-300 dark:border-red-700 rounded"></span>
                            <span class="text-xs text-gray-600 dark:text-gray-400">Not Huntable</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="prose max-w-none">
                <div id="article-content" class="whitespace-pre-wrap text-base text-black font-mono leading-relaxed select-text bg-gray-50 dark:bg-gray-950 p-6 rounded-lg border-2 border-gray-300 dark:border-gray-600 shadow-inner">{{ article.content|highlight_keywords(article.article_metadata)|safe }}</div>
            </div>
        </div>
    </div>

    <!-- Article Metadata -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <h2 class="text-xl font-bold text-gray-900 dark:text-white mb-6">üìã Article Metadata</h2>
        
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
                <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4">Basic Information</h3>
                <dl class="space-y-3">
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Article ID</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">#{{ article.id }}</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Source ID</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.source_id }}</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Published At</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.published_at.strftime('%Y-%m-%d %H:%M:%S') if article.published_at else 'N/A' }}</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Discovered At</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.discovered_at.strftime('%Y-%m-%d %H:%M:%S') if article.discovered_at else 'N/A' }}</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Processing Status</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.processing_status }}</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Word Count</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.word_count or 'N/A' }}</dd>
                    </div>
                </dl>
            </div>
            
            <div>
                <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4">Content Details</h3>
                <dl class="space-y-3">
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Content Length</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.content|length }} characters</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Content Hash</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100 font-mono">{{ article.content_hash[:20] }}...</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Authors</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">
                            {% if article.authors %}
                                {{ article.authors|join(', ') }}
                            {% else %}
                                N/A
                            {% endif %}
                        </dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Tags</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">
                            {% if article.tags %}
                                {{ article.tags|join(', ') }}
                            {% else %}
                                N/A
                            {% endif %}
                        </dd>
                    </div>
                </dl>
            </div>
        </div>
        
        {% if article.article_metadata %}
        <div class="mt-6">
            <h3 class="text-lg font-semibold text-gray-800 mb-2">Additional Metadata</h3>
            <pre class="bg-gray-50 p-4 rounded-lg text-sm text-gray-700 overflow-x-auto">{{ article.article_metadata|tojson(indent=2) }}</pre>
        </div>
        {% endif %}
    </div>

    <!-- Navigation -->
    <div class="flex items-center justify-between">
        <a href="/articles" class="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 transition-colors">
            <span class="mr-2">‚Üê</span>
            Back to Articles
        </a>
        
        <div class="flex space-x-2">
            <button onclick="navigateToPrevious()" 
                    class="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 transition-colors">
                Previous Article
            </button>
            
            <button onclick="navigateToNext()" 
                    class="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 transition-colors">
                Next Article
                <span class="ml-2">‚Üí</span>
            </button>
        </div>
    </div>
</div>
{% endblock %}
{% block scripts %}
<script>

    // Global help functions - must be defined at top level for onclick handlers
    let previousModalElement = null;
    
    function showHelpModal(title, promptContent, modelInfo = null) {
        // Remove any existing help modal
        const existingModal = document.getElementById('helpModal');
        if (existingModal) {
            existingModal.remove();
        }
        
        // Find and hide the currently visible modal (the one that opened the help)
        const visibleModals = document.querySelectorAll('#iocsModal, #sigmaRulesModal, #gpt4oRankingModal, #customPromptModal');
        previousModalElement = null;
        
        visibleModals.forEach(modal => {
            if (modal.style.display !== 'none' && modal.offsetParent !== null) {
                modal.style.display = 'none';
                previousModalElement = modal;
            }
        });
        
        const modal = document.createElement('div');
        modal.id = 'helpModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-[9999]';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeHelpModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeHelpModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium text-gray-900">‚ÑπÔ∏è ${title}</h3>
                    <button onclick="closeHelpModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-4 text-sm text-gray-600">
                    <span class="font-medium">Prompt Template:</span> This is the canned prompt sent to the LLM for this analysis.
                </div>
                
                <div class="bg-gray-50 p-4 rounded-lg max-h-96 overflow-y-auto">
                    <pre class="text-sm text-gray-800 whitespace-pre-wrap font-mono">${promptContent}</pre>
                </div>
                
                <div class="mt-4 text-xs text-gray-500">
                    <strong>Note:</strong> Future versions will support custom prompts for different models.
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
    }
    
    function closeHelpModal() {
        const modal = document.getElementById('helpModal');
        if (modal) {
            modal.remove();
        }
        
        // Restore the previously hidden modal
        if (previousModalElement) {
            previousModalElement.style.display = 'block';
            previousModalElement = null;
        }
    }

    function showIOCHelp() {
        const promptContent = `Extract Indicators of Compromise (IOCs) from this threat intelligence article.

**Article Title:** {title}
**Source:** {source}
**URL:** {url}

**Extraction Guidelines:**
1. **Focus on Actionable IOCs:** Extract IP addresses, domains, file hashes, email addresses, and URLs
2. **Context Matters:** Include surrounding context for each IOC to understand its significance
3. **Categorize Properly:** Classify each IOC by type (ip, domain, hash, email, url, etc.)
4. **Confidence Scoring:** Provide confidence scores (0.0-1.0) based on IOC clarity and context
5. **Avoid False Positives:** Only extract IOCs that are clearly malicious or suspicious

**IOC Types to Extract:**
- **IP Addresses:** IPv4 and IPv6 addresses
- **Domains:** Fully qualified domain names
- **File Hashes:** MD5, SHA1, SHA256 hashes
- **Email Addresses:** Malicious or suspicious email addresses
- **URLs:** Full URLs including paths and parameters
- **File Paths:** Suspicious file paths and filenames
- **Registry Keys:** Windows registry keys and values
- **Process Names:** Malicious process names and executables

**Output Format:**
Return a JSON array of IOC objects with the following structure:
[
  {
    "type": "ip",
    "value": "192.168.1.100",
    "context": "C2 server used for command and control",
    "confidence": 0.95
  },
  {
    "type": "domain",
    "value": "malicious.example.com",
    "context": "Domain used for data exfiltration",
    "confidence": 0.88
  }
]

**Important Notes:**
- Only extract IOCs that are clearly malicious or suspicious
- Provide meaningful context for each IOC
- Use appropriate confidence scores based on IOC clarity
- Return valid JSON format only

**Threat Intelligence Content:**
{content}`;
        showHelpModal('IOC Extraction Prompt', promptContent);
    }

    function showSigmaHelp() {
        const promptContent = `Generate a Sigma detection rule based on this threat intelligence:

**Article Title:** {title}
**Source:** {source}
**URL:** {url}

**SIGMA Rule Requirements:**
1. **Focus on TTPs:** Create rules for Tactics, Techniques, and Procedures, not atomic IOCs
2. **Behavioral Patterns:** Detect attack behaviors and techniques
3. **Proper Syntax:** Use correct SIGMA rule format and structure
4. **Required Fields:** Include all mandatory SIGMA fields (title, description, logsource, detection, etc.)
5. **Actionable Detection:** Rules should detect real attack patterns

**Rule Guidelines:**
- Avoid rules for single IP addresses or file hashes
- Focus on command-line patterns, process creation, and system modifications
- Use appropriate log sources (Windows Event Logs, Sysmon, Linux auditd, etc.)
- Include proper categorization and references
- Make rules specific enough to avoid false positives

**CRITICAL OUTPUT REQUIREMENTS:**
- Output ONLY the YAML rule content
- Do NOT include markdown code blocks (\`\`\`yaml or \`\`\`)
- Do NOT include any explanatory text before or after the rule
- Start directly with the YAML content

**YAML Formatting Rules:**
- Use exactly 2 spaces for each indentation level
- NEVER use tabs
- Ensure proper YAML syntax
- All field names must be lowercase
- Use quotes for values containing special characters

**Required YAML Structure:**
title: [Descriptive rule title]
id: [UUID or generated ID]
description: [What this rule detects]
logsource:
  category: [process_creation/network_connection/etc]
  product: [windows/linux/macos]
detection:
  selection:
    [detection criteria]
  condition: selection
level: [low/medium/high/critical]
tags:
  - attack.[technique]
references:
  - [URL or reference]

**Threat Intelligence Content:**
{content}`;
        showHelpModal('SIGMA Generation Prompt', promptContent);
    }

    function showRankingHelp() {
        const promptContent = `# Blog Content SIGMA-Suitability Huntability Ranking System

## Your Role

You are a detection engineer evaluating cybersecurity blog content specifically for its suitability to create SIGMA detection rules. Rate content based on how directly it maps to structured log data sources including Windows Event Logs, Sysmon, Linux auditd/Syslog, macOS system logs, AND cloud service logs (AWS CloudTrail, Azure Activity, GCP Audit).

## SIGMA-Focused Scoring (1-10 Scale)

Only content that maps to structured log telemetry receives points. Ignore network payloads, binary analysis, or packet-level details.

## Important Notes

- Do not award points for atomic IOCs (file hashes, IPs, or one-off domains).
- Filename/path patterns and directory conventions are acceptable if they indicate repeatable behavior.
- Only award points for observables that map directly to Windows Event Logs, Sysmon, Linux auditd/Syslog, or macOS system logs.

### Category A ‚Äì Process Creation & Command-Line Arguments (0-4 pts)

**Data Sources:** 
- Windows: Sysmon Event ID 1, Security 4688
- Linux: process logs, auditd
- **macOS: Endpoint Security process events, unified logging (log show)**
- Cloud: CLI commands in CloudTrail/Activity logs

**Look For:**

- Parent ‚Üí child process chains with full paths
- Exact command-line strings with arguments, switches, flags
- Process execution sequences
- Cloud CLI commands (aws, az, gcloud) with specific parameters
- **macOS-specific:** osascript commands, launchctl usage, security framework calls

**Scoring:**

- 0 = No process/command details
- 1 = Vague mentions ("runs PowerShell", "uses AWS CLI", or "executes AppleScript")
- 2 = Partial arguments or missing execution context
- 3 = Detailed examples but limited coverage
- 4 = Multiple detailed command chains with full arguments

### Category B - Persistence & System/Service Modification (0-3 pts)

**Data Sources:** 
- Windows: Sysmon Event IDs 12/13/19/7045, Security 4697
- Linux: auditd, systemd logs
- **macOS: LaunchAgent/LaunchDaemon creation, login items, authorization database changes**
- Cloud: AWS CloudTrail, Azure Activity

**Look For:**

- Registry keys with exact paths and values (Windows)
- Service creation/modification details
- Scheduled tasks, cron jobs, or **macOS LaunchAgents/LaunchDaemons**
- Cloud service configurations (IAM roles, SNS topics, Lambda functions, etc.)
- API calls that establish persistence or modify services
- **macOS persistence:** ~/Library/LaunchAgents, /Library/LaunchDaemons, login items, authorization plugins

**Scoring:**

- 0 = No persistence/modification details
- 1 = Generic mention ("creates persistence" or "modifies cloud config")
- 2 = Specific mechanism but incomplete details
- 3 = Exact configurations, API calls, plist files, or settings ready for SIGMA rules

### Category C - Log-Correlated Behavior (0-2 pts)

**Data Sources:** Multiple log sources in sequence (Windows/Linux/macOS/Cloud)

**Look For:**

- Cross-log correlations (process ‚Üí network, cloud API ‚Üí local execution)
- Event sequences that can be chained in SIGMA rules
- Time-based correlations between different log types
- Cloud service chains (EC2 ‚Üí SNS ‚Üí external endpoint)
- **macOS correlations:** Endpoint Security events + unified logging + authorization logs

**Scoring:**

- 0 = Single log source only
- 1 = Limited correlation opportunities
- 2 = Clear multi-log correlation patterns

### Category D - Structured Log Patterns (0-1 pt)

**Data Sources:** Any structured log format (file creation, API calls, service events)

**Look For:**

- File path patterns or naming conventions (not hashes)
- API call patterns with specific parameters
- Service usage patterns or anomalous configurations
- Structured event patterns in any log format
- **macOS-specific:** .plist file patterns, app bundle structures, Gatekeeper/XProtect logs

**Scoring:**

- 0 = No usable structured patterns
- 1 = Clear structured patterns present

## Important: Multi-Platform Content

**AWS CloudTrail, Azure Activity Logs, GCP Audit Logs, and macOS system logs ARE valid SIGMA data sources.** Do not dismiss cloud-focused or macOS content. API calls, service configurations, LaunchAgent creation, and command execution are all huntable through structured logs.

**macOS SIGMA Data Sources Include:**
- Endpoint Security Framework events
- Unified Logging System (log show commands)  
- Authorization database logs
- LaunchAgent/LaunchDaemon plist files
- Gatekeeper and XProtect logs

## Scoring Bands

- **1-2:** Mostly strategic content, minimal SIGMA applicability
- **3-4:** Limited SIGMA potential, too generic for reliable rules
- **5-6:** Moderate SIGMA candidates with some specificity
- **7-8:** Strong SIGMA potential, multiple rule-ready observables
- **9-10:** Excellent SIGMA content, rules can be drafted immediately

## Output Format

**SIGMA HUNTABILITY SCORE: [1-10]**

**CATEGORY BREAKDOWN:**

- **Process/Command-Line (0-4):** [Score] - [Brief reasoning, noting platform if applicable]
- **Persistence/System Mods (0-3):** [Score] - [Brief reasoning, noting platform-specific mechanisms]
- **Log Correlation (0-2):** [Score] - [Brief reasoning]
- **Structured Patterns (0-1):** [Score] - [Brief reasoning]

**SIGMA-READY OBSERVABLES:**
[List specific elements that can directly become SIGMA rules, noting target platform]

**REQUIRED LOG SOURCES:**
[Windows Event IDs, Sysmon events, Linux logs, macOS log sources, OR cloud service logs needed]

**RULE FEASIBILITY:**
[Assessment of how quickly detection rules could be created, noting any platform-specific considerations]

## Instructions

Analyze the provided blog content using this SIGMA-focused rubric. All major platforms (Windows, Linux, macOS) and cloud service logs are valid SIGMA data sources. Focus on structured log patterns regardless of platform. Ignore only unstructured data like network payloads or binary analysis.

Please analyze the following blog content:

**Title:** {title}
**Source:** {source}
**URL:** {url}

**Content:**
{content}`;
        showHelpModal('LLM SIGMA Huntability Analysis Prompt', promptContent, 'LLM');
    }

    function showCustomHelp() {
        const promptContent = `You are a cybersecurity analyst with expertise in threat intelligence analysis. Analyze the provided article content and respond to the user's specific question or request.

**Article Title:** {title}
**Source:** {source}
**URL:** {url}

**Article Content:**
{content}

**User Request:** {user_prompt}

Please provide a detailed analysis based on the article content and the user's specific request. Focus on actionable insights, technical details, and practical recommendations where applicable.`;
        showHelpModal('Custom Prompt Template', promptContent, 'ChatGPT/Claude/Llama');
    }

    // Add syntax highlighting for matched text
    document.addEventListener('DOMContentLoaded', function() {
        
        // Syntax highlighting for matched text
        const matchedTexts = document.querySelectorAll('.font-mono');
        matchedTexts.forEach(element => {
            element.style.backgroundColor = '#fef3c7';
            element.style.border = '1px solid #f59e0b';
        });
        
        // Initialize current article classification in localStorage
        const currentClassification = '{{ article.article_metadata.get("training_category", "") }}';
        localStorage.setItem('currentArticleClassification', currentClassification);
        
        // Load existing annotations
    });
    
    // Simple Text Management System - Single Source of Truth
    class SimpleTextManager {
        constructor() {
            this.contentElement = document.getElementById('article-content');
            this.userClassifications = new Map();
            this.previousStates = []; // Store previous HTML states for undo
            this.maxUndoStates = 10;
            this.isSubmitting = false; // Prevent duplicate submissions
            
            this.init();
        }
        
        init() {
            // Load existing user classifications
            this.loadExistingClassifications();
            
            // Enable user text selection
            this.enableUserSelection();
            
            // Enable keyboard shortcuts
            this.enableKeyboardShortcuts();
            
            // Enable clicking on annotations to remove them
            this.enableAnnotationClicking();
        }
        
        async loadExistingClassifications() {
            try {
                // Loading existing classifications for article {{ article.id }}
                const response = await fetch(`/api/articles/{{ article.id }}/annotations`);
                const data = await response.json();
                
                // API response received
                
                if (data.success && data.annotations) {
                    // Found ${data.annotations.length} existing annotations
                    
                    // Wait a bit for the page to fully load before adding annotations
                    setTimeout(() => {
                        data.annotations.forEach(annotation => {
                            // Loading annotation: ${annotation.annotation_type}
                            this.addExistingClassification(
                                annotation.start_position,
                                annotation.end_position,
                                annotation.annotation_type,
                                annotation.selected_text
                            );
                        });
                    }, 100);
                } else {
                    // No existing annotations found
                }
            } catch (error) {
                console.error('Failed to load existing classifications:', error);
            }
        }
        
        addExistingClassification(start, end, classification, text) {
            // Checking existing annotation: ${classification}
            
            // Check if this text is already highlighted by looking for spans with our classes
            const cssClass = classification === 'huntable' 
                ? 'bg-blue-100 dark:bg-blue-900' 
                : 'bg-red-100 dark:bg-red-900';
            
            // Look for existing spans with our annotation classes
            const existingSpans = this.contentElement.querySelectorAll(`span[class*="${cssClass.split(' ')[0]}"]`);
            let alreadyHighlighted = false;
            
            for (const span of existingSpans) {
                // Check if this span contains our text (or vice versa for partial matches)
                const spanText = span.textContent.trim();
                const searchText = text.trim();
                
                // More precise matching - check if the span text matches our annotation text
                if (spanText === searchText || spanText.includes(searchText)) {
                    alreadyHighlighted = true;
                    console.log(`Text already highlighted in span: "${spanText.substring(0, 50)}..."`);
                    break;
                }
            }
            
            if (!alreadyHighlighted) {
                console.log('Text not yet highlighted, adding annotation');
                this.addUserClassification(start, end, classification, text);
            } else {
                console.log('Skipping duplicate annotation');
            }
        }
        
        addUserClassification(start, end, classification, text) {
            console.log(`Attempting to add ${classification} classification for: "${text.substring(0, 100)}..."`);
            console.log(`Text length: ${text.length}, Start: ${start}, End: ${end}`);
            
            // Always use position-based highlighting to avoid text duplication issues
            // The text-based replacement was causing duplication when the same text appeared multiple times
            console.log('Using position-based highlighting to prevent text duplication');
            this.highlightTextAtPosition(start, end, classification, text);
        }
        
        highlightTextAtPosition(start, end, classification, text) {
            console.log('Using position-based highlighting:', { start, end, textLength: text.length });
            
            // Create a range to select the text at the exact position
            const range = document.createRange();
            const walker = document.createTreeWalker(
                this.contentElement,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let currentPos = 0;
            let startNode = null;
            let startOffset = 0;
            let endNode = null;
            let endOffset = 0;
            
            // Find the text nodes that contain our selection
            let node;
            while (node = walker.nextNode()) {
                const nodeLength = node.textContent.length;
                
                if (!startNode && currentPos + nodeLength >= start) {
                    startNode = node;
                    startOffset = start - currentPos;
                }
                
                if (!endNode && currentPos + nodeLength >= end) {
                    endNode = node;
                    endOffset = end - currentPos;
                    break;
                }
                
                currentPos += nodeLength;
            }
            
            if (startNode && endNode) {
                try {
                    range.setStart(startNode, startOffset);
                    range.setEnd(endNode, endOffset);
                    
                    // Create highlight span
                    const cssClass = classification === 'huntable' 
                        ? 'bg-blue-100 dark:bg-blue-900 border-blue-300 dark:border-blue-700 text-blue-800 dark:text-blue-200' 
                        : 'bg-red-100 dark:bg-red-900 border-red-300 dark:border-red-700 text-red-800 dark:text-red-200';
                    
                    const highlightSpan = document.createElement('span');
                    highlightSpan.className = `px-1 py-0.5 rounded text-xs font-medium border ${cssClass}`;
                    highlightSpan.title = `${classification === 'huntable' ? 'Huntable' : 'Not Huntable'}: ${text.substring(0, 50)}...`;
                    highlightSpan.textContent = text;
                    
                    // Replace the range content with our highlight span
                    range.deleteContents();
                    range.insertNode(highlightSpan);
                    
                    console.log('Position-based highlighting successful');
                    
                    // Save state for undo
                    this.saveState();
                    
                } catch (error) {
                    console.error('Error in position-based highlighting:', error);
                    // Fallback: just add a visual indicator
                    this.addVisualIndicator(start, end, classification, text);
                }
            } else {
                console.error('Could not find text nodes for position-based highlighting');
                this.addVisualIndicator(start, end, classification, text);
            }
        }
        
        addVisualIndicator(start, end, classification, text) {
            console.log('Adding visual indicator as last resort');
            
            // Create a simple visual indicator at the top of the content
            const indicator = document.createElement('div');
            indicator.className = `p-2 mb-2 rounded border-l-4 ${classification === 'huntable' ? 'bg-blue-50 border-blue-400' : 'bg-red-50 border-red-400'}`;
            indicator.innerHTML = `
                <div class="text-sm font-medium ${classification === 'huntable' ? 'text-blue-800' : 'text-red-800'}">
                    ${classification === 'huntable' ? '‚úì Huntable' : '‚úó Not Huntable'} Text Annotated
                </div>
                <div class="text-xs text-gray-600 mt-1">
                    "${text.substring(0, 100)}${text.length > 100 ? '...' : ''}"
                </div>
            `;
            
            // Insert at the beginning of the content
            this.contentElement.insertBefore(indicator, this.contentElement.firstChild);
            
            // Save state for undo
            this.saveState();
        }
        
        addLongTextClassification(start, end, classification, text) {
            // For very long text, try to highlight multiple parts of it
            const cssClass = classification === 'huntable' 
                ? 'bg-blue-100 dark:bg-blue-900 border-blue-300 dark:border-blue-700 text-blue-800 dark:text-blue-200' 
                : 'bg-red-100 dark:bg-red-900 border-red-300 dark:border-red-700 text-red-800 dark:text-red-200';
            
            // Get the current HTML content
            const content = this.contentElement.innerHTML;
            
            // Try to highlight the first 500 characters and add an indicator
            const shortText = text.substring(0, Math.min(500, text.length));
            const highlightSpan = `<span class="px-1 py-0.5 rounded text-xs font-medium border ${cssClass}" title="${classification === 'huntable' ? 'Huntable' : 'Not Huntable'}: Long selection (${text.length} chars)">${shortText}${text.length > 500 ? '...' : ''}</span>`;
            
            // Try to find and replace the text
            if (content.includes(shortText)) {
                let newContent = content.replace(shortText, highlightSpan);
                
                // Also try to highlight the end of the selection if it's very long
                if (text.length > 1000) {
                    const endText = text.substring(text.length - 100);
                    const endHighlightSpan = `<span class="px-1 py-0.5 rounded text-xs font-medium border ${cssClass}" title="End of long ${classification} selection">...${endText}</span>`;
                    
                    if (newContent.includes(endText) && !newContent.includes(endHighlightSpan)) {
                        newContent = newContent.replace(endText, endHighlightSpan);
                    }
                }
                
                this.contentElement.innerHTML = newContent;
                console.log(`Added ${classification} highlight for long text selection (${text.length} chars)`);
            } else {
                // Fallback to shorter text
                const veryShortText = text.substring(0, Math.min(100, text.length));
                if (content.includes(veryShortText)) {
                    const shortHighlightSpan = `<span class="px-1 py-0.5 rounded text-xs font-medium border ${cssClass}" title="${classification === 'huntable' ? 'Huntable' : 'Not Huntable'}: Long selection (${text.length} chars)">${veryShortText}...</span>`;
                    const newContent = content.replace(veryShortText, shortHighlightSpan);
                    this.contentElement.innerHTML = newContent;
                    console.log(`Added ${classification} highlight for part of long text selection`);
                } else {
                    console.log(`Could not find text for long selection highlighting`);
                }
            }
        }
        
        saveState() {
            // Save current HTML state for undo functionality
            this.previousStates.push(this.contentElement.innerHTML);
            
            // Keep only the last maxUndoStates
            if (this.previousStates.length > this.maxUndoStates) {
                this.previousStates.shift();
            }
        }
        
        async undo() {
            if (this.previousStates.length > 0) {
                const previousState = this.previousStates.pop();
                this.contentElement.innerHTML = previousState;
                
                // Delete the last annotation from database
                try {
                    const response = await fetch(`/api/articles/{{ article.id }}/annotations`, {
                        method: 'GET'
                    });
                    const data = await response.json();
                    
                    if (data.success && data.annotations.length > 0) {
                        // Get the most recent annotation (highest ID)
                        const lastAnnotation = data.annotations.reduce((prev, current) => 
                            (prev.id > current.id) ? prev : current
                        );
                        
                        // Delete it from database
                        const deleteResponse = await fetch(`/api/articles/{{ article.id }}/annotations/${lastAnnotation.id}`, {
                            method: 'DELETE'
                        });
                        
                        if (deleteResponse.ok) {
                            console.log(`Undid last classification and removed annotation ID ${lastAnnotation.id} from database`);
                        } else {
                            console.error('Failed to remove annotation from database');
                        }
                    }
                } catch (error) {
                    console.error('Error removing annotation from database:', error);
                }
                
                console.log('Undid last classification');
                return true;
            } else {
                console.log('No previous states to undo');
                return false;
            }
        }
        
        
        enableKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ctrl+Z for undo
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    this.undo();
                }
            });
        }
        
        enableAnnotationClicking() {
            // Use event delegation to handle clicks on annotation spans
            this.contentElement.addEventListener('click', (e) => {
                // Check if clicked element is an annotation span
                const clickedSpan = e.target.closest('span.px-1.py-0\\.5.rounded.text-xs.font-medium.border');
                
                if (clickedSpan) {
                    // Check if it's a user annotation (not a keyword discriminator)
                    const isHuntableAnnotation = clickedSpan.classList.contains('bg-blue-100') || clickedSpan.classList.contains('dark:bg-blue-900');
                    const isNotHuntableAnnotation = clickedSpan.classList.contains('bg-red-100') || clickedSpan.classList.contains('dark:bg-red-900');
                    
                    if (isHuntableAnnotation || isNotHuntableAnnotation) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const annotationType = isHuntableAnnotation ? 'huntable' : 'not_huntable';
                        const annotationText = clickedSpan.textContent;
                        
                        this.showRemoveAnnotationModal(clickedSpan, annotationType, annotationText);
                    }
                }
            });
        }
        
        enableUserSelection() {
            let isSelecting = false;
            let startPos = null;
            let endPos = null;
            
            this.contentElement.addEventListener('mousedown', (e) => {
                isSelecting = true;
                startPos = this.getTextPositionFromEvent(e);
            });
            
            this.contentElement.addEventListener('mousemove', (e) => {
                if (isSelecting) {
                    endPos = this.getTextPositionFromEvent(e);
                    this.showSelectionPreview(startPos, endPos);
                }
            });
            
            this.contentElement.addEventListener('mouseup', (e) => {
                if (isSelecting) {
                    isSelecting = false;
                    endPos = this.getTextPositionFromEvent(e);
                    this.showClassificationOptions(startPos, endPos);
                }
            });
            
            // Also listen for native text selection events (as backup)
            document.addEventListener('mouseup', (e) => {
                // Only handle if the click was within our content area
                if (this.contentElement.contains(e.target)) {
                    setTimeout(() => {
                        // Skip if we're currently updating the selection programmatically
                        if (this.isUpdatingSelection) {
                            console.log('Skipping native selection handler - programmatic update in progress');
                            return;
                        }
                        
                        const selection = window.getSelection();
                        const selectedText = selection.toString().trim();
                        
                        if (selectedText.length > 0) {
                            console.log('Native selection detected:', {
                                text: selectedText.substring(0, 100),
                                fullLength: selectedText.length
                            });
                            
                            try {
                                const range = selection.getRangeAt(0);
                                const startPos = this.getTextPositionFromRange(range.startContainer, range.startOffset);
                                const endPos = this.getTextPositionFromRange(range.endContainer, range.endOffset);
                                
                                if (startPos !== endPos && endPos - startPos === selectedText.length) {
                                    console.log('Position calculation successful:', {
                                        start: startPos,
                                        end: endPos,
                                        calculatedLength: endPos - startPos,
                                        actualLength: selectedText.length
                                    });
                                    this.showClassificationOptions(startPos, endPos);
                                } else {
                                    console.log('Position calculation mismatch, using fallback');
                                    // Fallback: try to find the text in the content
                                    const contentText = this.contentElement.textContent;
                                    const textIndex = contentText.indexOf(selectedText);
                                    if (textIndex !== -1) {
                                        this.showClassificationOptions(textIndex, textIndex + selectedText.length);
                                    }
                                }
                            } catch (error) {
                                console.error('Error processing native selection:', error);
                                // Fallback: try to find the text in the content
                                const contentText = this.contentElement.textContent;
                                const textIndex = contentText.indexOf(selectedText);
                                if (textIndex !== -1) {
                                    this.showClassificationOptions(textIndex, textIndex + selectedText.length);
                                }
                            }
                        }
                    }, 50);
                }
            });
        }
        
        getTextPositionFromEvent(e) {
            const range = document.caretRangeFromPoint(e.clientX, e.clientY);
            if (!range) return 0;
            
            // Find the character position in the text content (ignoring HTML)
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(this.contentElement);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            
            return preCaretRange.toString().length;
        }
        
        getTextPositionFromRange(container, offset) {
            // Create a range from the start of the content to the given position
            const range = document.createRange();
            range.setStart(this.contentElement, 0);
            range.setEnd(container, offset);
            
            // Return the length of text content up to this point
            return range.toString().length;
        }
        
        showSelectionPreview(start, end) {
            // Clear previous preview
            this.clearSelectionPreview();
            
            if (start === end) return;
            
            const min = Math.min(start, end);
            const max = Math.max(start, end);
            
            const preview = document.createElement('div');
            preview.className = 'absolute bg-yellow-200 bg-opacity-50 border border-yellow-400';
            preview.id = 'selection-preview';
            
            try {
                // Create a range based on text content positions
                const range = document.createRange();
                const textContent = this.contentElement.textContent;
                
                // Find the text nodes that contain our selection
                const walker = document.createTreeWalker(
                    this.contentElement,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );
                
                let currentPos = 0;
                let startNode = null;
                let endNode = null;
                let startOffset = 0;
                let endOffset = 0;
                
                while (walker.nextNode()) {
                    const textNode = walker.currentNode;
                    const nodeLength = textNode.textContent.length;
                    
                    if (!startNode && currentPos + nodeLength >= min) {
                        startNode = textNode;
                        startOffset = min - currentPos;
                    }
                    
                    if (!endNode && currentPos + nodeLength >= max) {
                        endNode = textNode;
                        endOffset = max - currentPos;
                        break;
                    }
                    
                    currentPos += nodeLength;
                }
                
                if (startNode && endNode) {
                    range.setStart(startNode, startOffset);
                    range.setEnd(endNode, endOffset);
                    
                    const rect = range.getBoundingClientRect();
                    const containerRect = this.contentElement.getBoundingClientRect();
                    
                    preview.style.left = `${rect.left - containerRect.left}px`;
                    preview.style.top = `${rect.top - containerRect.top}px`;
                    preview.style.width = `${rect.width}px`;
                    preview.style.height = `${rect.height}px`;
                    
                    this.contentElement.appendChild(preview);
                }
            } catch (error) {
                console.error('Error showing selection preview:', error);
            }
        }
        
        clearSelectionPreview() {
            const preview = document.getElementById('selection-preview');
            if (preview) {
                preview.remove();
            }
        }
        
        showClassificationOptions(start, end) {
            this.clearSelectionPreview();
            
            if (start === end) return;
            
            const min = Math.min(start, end);
            const max = Math.max(start, end);
            const selectedText = this.contentElement.textContent.substring(min, max);
            
            console.log('Showing classification options:', {
                start: min,
                end: max,
                textLength: selectedText.length,
                textPreview: selectedText.substring(0, 100)
            });
            
            // Show classification modal with enhanced features
            this.showClassificationModal(selectedText, min, max);
        }
        showClassificationModal(text, start, end) {
            // Prevent infinite loops when updating existing modal
            if (this.isUpdatingModal) {
                return;
            }
            
            // Auto-expand to 1000 characters before showing modal
            const expandedSelection = this.autoExpandTo1000(start, end);
            const expandedText = expandedSelection.text;
            const expandedStart = expandedSelection.start;
            const expandedEnd = expandedSelection.end;
            
            // Create modal for classification
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 z-50 flex items-center justify-center';
            
            // Add click outside to close
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    this.closeModal();
                }
            }.bind(this));
            
            // Add ESC key to close
            const handleEsc = function(e) {
                if (e.key === 'Escape') {
                    this.closeModal();
                    document.removeEventListener('keydown', handleEsc);
                }
            }.bind(this);
            document.addEventListener('keydown', handleEsc);
            
            // Calculate character count and length guidance
            const charCount = expandedText.length;
            const targetLength = 1000;
            
            // Color coding for length guidance (production-aligned)
            let lengthStatus = 'good'; // green
            let lengthMessage = '';
            if (charCount < 800) {
                lengthStatus = 'short'; // yellow
                lengthMessage = '‚ö†Ô∏è Too short - add more context to match production chunks';
            } else if (charCount < 950) {
                lengthStatus = 'acceptable'; // blue
                lengthMessage = '‚ö†Ô∏è Acceptable but not optimal - aim for 950-1000 chars';
            } else if (charCount > 1000) {
                lengthStatus = 'long'; // red
                lengthMessage = '‚ö†Ô∏è Too long - will be chunked differently in production';
            }
            
            modal.innerHTML = `
                <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold">Classify Selected Text</h3>
                        <div class="char-counter ${lengthStatus}">
                            ${charCount}/${targetLength} chars
                        </div>
                    </div>
                    ${lengthMessage ? `<div class="length-guidance ${lengthStatus} mb-4">${lengthMessage}</div>` : ''}
                    <p class="text-sm text-gray-600 mb-4">"${expandedText.substring(0, 100)}${expandedText.length > 100 ? '...' : ''}"</p>
                    
                    <div class="flex space-x-3">
                        <button id="huntable-btn" 
                                class="flex-1 bg-green-600 text-white px-4 py-3 rounded-lg text-lg font-semibold min-h-[48px] touch-manipulation">
                            üéØ Huntable
                        </button>
                        <button id="not-huntable-btn" 
                                class="flex-1 bg-red-600 text-white px-4 py-3 rounded-lg text-lg font-semibold min-h-[48px] touch-manipulation">
                            ‚ùå Not Huntable
                        </button>
                        <button id="cancel-btn" 
                                class="px-4 py-3 border border-gray-300 rounded-lg text-lg font-semibold min-h-[48px] touch-manipulation">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Add touch event handlers for mobile
            addMobileModalHandlers(modal, expandedStart, expandedEnd);
            
            // Add CSS styles if not already present
            if (!document.getElementById('annotation-enhancement-styles')) {
                const styles = document.createElement('style');
                styles.id = 'annotation-enhancement-styles';
                styles.textContent = `
                    .char-counter {
                        font-size: 11px;
                        font-weight: 600;
                        padding: 2px 6px;
                        border-radius: 4px;
                        margin-left: 8px;
                    }
                    
                    .char-counter.good {
                        background: #dcfce7;
                        color: #15803d;
                        border: 1px solid #16a34a;
                    }
                    
                    .char-counter.short {
                        background: #fef3c7;
                        color: #d97706;
                        border: 1px solid #f59e0b;
                    }
                    
                    .char-counter.acceptable {
                        background: #dbeafe;
                        color: #1d4ed8;
                        border: 1px solid #3b82f6;
                    }
                    
                    .char-counter.long {
                        background: #fef2f2;
                        color: #dc2626;
                        border: 1px solid #ef4444;
                    }
                    
                    .length-guidance {
                        font-size: 11px;
                        padding: 6px 8px;
                        border-radius: 4px;
                        text-align: center;
                    }
                    
                    .length-guidance.good {
                        background: #dcfce7;
                        color: #15803d;
                        border: 1px solid #16a34a;
                    }
                    
                    .length-guidance.short {
                        background: #fef3c7;
                        color: #d97706;
                        border: 1px solid #f59e0b;
                    }
                    
                    .length-guidance.acceptable {
                        background: #dbeafe;
                        color: #1d4ed8;
                        border: 1px solid #3b82f6;
                    }
                    
                    .length-guidance.long {
                        background: #fef2f2;
                        color: #dc2626;
                        border: 1px solid #ef4444;
                    }
                `;
                document.head.appendChild(styles);
            }
        }
        
        expandSelection(currentStart, currentEnd, expandBy) {
            // Get the full article text
            const fullText = this.contentElement.textContent;
            
            // Calculate new boundaries
            let newStart, newEnd;
            
            if (expandBy > 0) {
                // Expanding - add to both sides symmetrically
                const halfExpand = Math.floor(expandBy / 2);
                newStart = Math.max(0, currentStart - halfExpand);
                newEnd = Math.min(fullText.length, currentEnd + halfExpand);
            } else {
                // Contracting - remove from both sides symmetrically
                const halfContract = Math.floor(Math.abs(expandBy) / 2);
                newStart = currentStart + halfContract;
                newEnd = currentEnd - halfContract;
            }
            
            // Apply smart boundary detection
            const smartBoundaries = this.findSmartBoundaries(fullText, newStart, newEnd);
            newStart = smartBoundaries.start;
            newEnd = smartBoundaries.end;
            
            // Get new text
            const newText = fullText.substring(newStart, newEnd);
            
            // Update the live text selection in the browser
            this.updateLiveSelection(newStart, newEnd);
            
            // Update the current modal with new selection data
            this.updateModalWithNewSelection(newText, newStart, newEnd);
        }
        
        autoExpandTo1000(currentStart, currentEnd) {
            // Get the full article text
            const fullText = this.contentElement.textContent;
            const currentText = fullText.substring(currentStart, currentEnd);
            const currentLength = currentText.length;
            const targetLength = 1000;
            
            let newStart, newEnd;
            
            if (currentLength >= targetLength) {
                // Already at or over target, just trim to exactly 1000
                const trimAmount = currentLength - targetLength;
                const halfTrim = Math.floor(trimAmount / 2);
                newStart = currentStart + halfTrim;
                newEnd = currentEnd - (trimAmount - halfTrim);
            } else {
                // Need to expand - calculate how much to add
                const expandBy = targetLength - currentLength;
                const halfExpand = Math.floor(expandBy / 2);
                
                // Try to expand symmetrically
                newStart = Math.max(0, currentStart - halfExpand);
                newEnd = Math.min(fullText.length, currentEnd + halfExpand);
                
                // If we hit boundaries, expand more on the other side
                if (newStart === 0 && newEnd < fullText.length) {
                    const remainingExpand = targetLength - (newEnd - newStart);
                    newEnd = Math.min(fullText.length, newEnd + remainingExpand);
                } else if (newEnd === fullText.length && newStart > 0) {
                    const remainingExpand = targetLength - (newEnd - newStart);
                    newStart = Math.max(0, newStart - remainingExpand);
                }
                
                // CRITICAL: Ensure we don't exceed 1000 characters for ML training
                const finalLength = newEnd - newStart;
                if (finalLength > targetLength) {
                    const excess = finalLength - targetLength;
                    const halfExcess = Math.floor(excess / 2);
                    newStart += halfExcess;
                    newEnd -= (excess - halfExcess);
                    console.log(`Trimmed selection to stay under 1000 chars: ${finalLength} ‚Üí ${newEnd - newStart}`);
                }
            }
            
            // Apply smart boundary detection
            const smartBoundaries = this.findSmartBoundaries(fullText, newStart, newEnd);
            newStart = smartBoundaries.start;
            newEnd = smartBoundaries.end;
            
            // CRITICAL: Final check - ensure we don't exceed 1000 characters for ML training
            const finalLength = newEnd - newStart;
            if (finalLength > targetLength) {
                const excess = finalLength - targetLength;
                const halfExcess = Math.floor(excess / 2);
                newStart += halfExcess;
                newEnd -= (excess - halfExcess);
                console.log(`Final trim to stay under 1000 chars: ${finalLength} ‚Üí ${newEnd - newStart}`);
            }
            
            const newText = fullText.substring(newStart, newEnd);
            
            console.log(`Auto-expand: ${currentLength} ‚Üí ${newText.length} chars`);
            
            // Update the live text selection in the browser
            this.updateLiveSelection(newStart, newEnd);
            
            // Update the current modal with new selection data
            this.updateModalWithNewSelection(newText, newStart, newEnd);
        }
        updateLiveSelection(newStart, newEnd) {
            // Update the browser's text selection to show the expanded selection
            try {
                // Temporarily disable the native selection event handler to prevent conflicts
                this.isUpdatingSelection = true;
                
                const range = document.createRange();
                const startNode = this.getTextNodeAtOffset(newStart);
                const endNode = this.getTextNodeAtOffset(newEnd);
                
                if (startNode && endNode) {
                    range.setStart(startNode.node, startNode.offset);
                    range.setEnd(endNode.node, endNode.offset);
                    
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // Disable automatic scrolling for Auto 1000 to prevent background page jumping
                    // The selection will be updated but the page position will remain stable
                }
                
                // Re-enable the native selection event handler after a short delay
                setTimeout(() => {
                    this.isUpdatingSelection = false;
                }, 100);
                
            } catch (error) {
                console.error('Error updating live selection:', error);
                this.isUpdatingSelection = false;
            }
        }
        
        updateModalWithNewSelection(newText, newStart, newEnd) {
            // NUCLEAR OPTION: Completely recreate the modal to force UI update
            console.log('Recreating modal to force UI update');
            
            // Set flag to prevent infinite loops
            this.isUpdatingModal = true;
            
            // Close the current modal
            this.closeModal();
            
            // Wait a frame to ensure DOM cleanup
            setTimeout(() => {
                // Create modal directly without auto-expanding (we already have the right text)
                this.createModalDirectly(newText, newStart, newEnd);
                
                // Clear the flag after modal is recreated
                setTimeout(() => {
                    this.isUpdatingModal = false;
                }, 100);
            }, 10);
        }
        
        createModalDirectly(text, start, end) {
            // Create modal for classification without auto-expanding
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 z-50 flex items-center justify-center';
            
            // Add click outside to close
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    this.closeModal();
                }
            }.bind(this));
            
            // Add ESC key to close
            const handleEsc = function(e) {
                if (e.key === 'Escape') {
                    this.closeModal();
                    document.removeEventListener('keydown', handleEsc);
                }
            }.bind(this);
            document.addEventListener('keydown', handleEsc);
            
            // Calculate character count and length guidance
            const charCount = text.length;
            const targetLength = 1000;
            
            // Color coding for length guidance (production-aligned)
            let lengthStatus = 'good'; // green
            let lengthMessage = '';
            if (charCount < 800) {
                lengthStatus = 'short'; // yellow
                lengthMessage = '‚ö†Ô∏è Too short - add more context to match production chunks';
            } else if (charCount < 950) {
                lengthStatus = 'acceptable'; // blue
                lengthMessage = '‚ö†Ô∏è Acceptable but not optimal - aim for 950-1000 chars';
            } else if (charCount > 1000) {
                lengthStatus = 'long'; // red
                lengthMessage = '‚ö†Ô∏è Too long - will be chunked differently in production';
            }
            
            modal.innerHTML = `
                <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold">Classify Selected Text</h3>
                        <div class="char-counter ${lengthStatus}">
                            ${charCount}/${targetLength} chars
                        </div>
                    </div>
                    ${lengthMessage ? `<div class="length-guidance ${lengthStatus} mb-4">${lengthMessage}</div>` : ''}
                    <p class="text-sm text-gray-600 mb-4">"${text.substring(0, 100)}${text.length > 100 ? '...' : ''}"</p>
                    
                    <div class="flex space-x-3">
                        <button id="huntable-btn" 
                                class="flex-1 bg-green-600 text-white px-4 py-3 rounded-lg text-lg font-semibold min-h-[48px] touch-manipulation">
                            üéØ Huntable
                        </button>
                        <button id="not-huntable-btn" 
                                class="flex-1 bg-red-600 text-white px-4 py-3 rounded-lg text-lg font-semibold min-h-[48px] touch-manipulation">
                            ‚ùå Not Huntable
                        </button>
                        <button id="cancel-btn" 
                                class="px-4 py-3 border border-gray-300 rounded-lg text-lg font-semibold min-h-[48px] touch-manipulation">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Add touch event handlers for mobile
            addMobileModalHandlers(modal, start, end);
            
            // Add CSS styles if not already present
            if (!document.getElementById('annotation-enhancement-styles')) {
                const styles = document.createElement('style');
                styles.id = 'annotation-enhancement-styles';
                styles.textContent = `
                    .char-counter {
                        font-size: 11px;
                        font-weight: 600;
                        padding: 2px 6px;
                        border-radius: 4px;
                        margin-left: 8px;
                    }
                    
                    .char-counter.good {
                        background: #dcfce7;
                        color: #15803d;
                        border: 1px solid #16a34a;
                    }
                    
                    .char-counter.short {
                        background: #fef3c7;
                        color: #92400e;
                        border: 1px solid #f59e0b;
                    }
                    
                    .char-counter.acceptable {
                        background: #dbeafe;
                        color: #1e40af;
                        border: 1px solid #3b82f6;
                    }
                    
                    .char-counter.long {
                        background: #fee2e2;
                        color: #dc2626;
                        border: 1px solid #ef4444;
                    }
                    
                    .length-guidance {
                        font-size: 12px;
                        padding: 8px 12px;
                        border-radius: 6px;
                        border-left: 4px solid;
                    }
                    
                    .length-guidance.good {
                        background: #dcfce7;
                        color: #15803d;
                        border-left-color: #16a34a;
                    }
                    
                    .length-guidance.short {
                        background: #fef3c7;
                        color: #92400e;
                        border-left-color: #f59e0b;
                    }
                    
                    .length-guidance.acceptable {
                        background: #dbeafe;
                        color: #1e40af;
                        border-left-color: #3b82f6;
                    }
                    
                    .length-guidance.long {
                        background: #fee2e2;
                        color: #dc2626;
                        border-left-color: #ef4444;
                    }
                `;
                document.head.appendChild(styles);
            }
        }
        
        findSmartBoundaries(text, start, end) {
            // Smart boundary detection - prefer sentence, paragraph, then word boundaries
            const maxLookback = 100; // Don't look back more than 100 chars
            const maxLookahead = 100; // Don't look ahead more than 100 chars
            
            // Find sentence boundaries (preferred)
            const sentenceStart = this.findSentenceStart(text, start, maxLookback);
            const sentenceEnd = this.findSentenceEnd(text, end, maxLookahead);
            
            if (sentenceStart !== start || sentenceEnd !== end) {
                return { start: sentenceStart, end: sentenceEnd };
            }
            
            // Find paragraph boundaries (second choice)
            const paragraphStart = this.findParagraphStart(text, start, maxLookback);
            const paragraphEnd = this.findParagraphEnd(text, end, maxLookahead);
            
            if (paragraphStart !== start || paragraphEnd !== end) {
                return { start: paragraphStart, end: paragraphEnd };
            }
            
            // Find word boundaries (last resort)
            const wordStart = this.findWordStart(text, start, maxLookback);
            const wordEnd = this.findWordEnd(text, end, maxLookahead);
            
            return { start: wordStart, end: wordEnd };
        }
        
        findSentenceStart(text, position, maxLookback) {
            const start = Math.max(0, position - maxLookback);
            const searchText = text.substring(start, position);
            
            // Look for sentence endings followed by whitespace and capital letter
            const sentenceEndRegex = /[.!?]\s+[A-Z]/g;
            let match;
            let lastMatch = start;
            
            while ((match = sentenceEndRegex.exec(searchText)) !== null) {
                lastMatch = start + match.index + match[0].length - 1; // Position after the capital letter
            }
            
            return lastMatch;
        }
        
        findSentenceEnd(text, position, maxLookahead) {
            const end = Math.min(text.length, position + maxLookahead);
            const searchText = text.substring(position, end);
            
            // Look for sentence endings
            const sentenceEndRegex = /[.!?](?=\s|$)/g;
            const match = sentenceEndRegex.exec(searchText);
            
            if (match) {
                return position + match.index + 1; // Position after the punctuation
            }
            
            return position;
        }
        
        findParagraphStart(text, position, maxLookback) {
            const start = Math.max(0, position - maxLookback);
            const searchText = text.substring(start, position);
            
            // Look for double newlines (paragraph breaks)
            const paragraphBreak = searchText.lastIndexOf('\n\n');
            if (paragraphBreak !== -1) {
                return start + paragraphBreak + 2; // After the double newline
            }
            
            return start;
        }
        
        findParagraphEnd(text, position, maxLookahead) {
            const end = Math.min(text.length, position + maxLookahead);
            const searchText = text.substring(position, end);
            
            // Look for double newlines (paragraph breaks)
            const paragraphBreak = searchText.indexOf('\n\n');
            if (paragraphBreak !== -1) {
                return position + paragraphBreak; // Before the double newline
            }
            
            return position;
        }
        
        findWordStart(text, position, maxLookback) {
            const start = Math.max(0, position - maxLookback);
            const searchText = text.substring(start, position);
            
            // Look for word boundary (space or punctuation followed by letter)
            const wordBoundaryRegex = /[^\w](?=\w)/g;
            let match;
            let lastMatch = start;
            
            while ((match = wordBoundaryRegex.exec(searchText)) !== null) {
                lastMatch = start + match.index + 1; // Position after the boundary
            }
            
            return lastMatch;
        }
        
        findWordEnd(text, position, maxLookahead) {
            const end = Math.min(text.length, position + maxLookahead);
            const searchText = text.substring(position, end);
            
            // Look for word boundary (letter followed by space or punctuation)
            const wordBoundaryRegex = /\w(?=[^\w]|$)/g;
            const match = wordBoundaryRegex.exec(searchText);
            
            if (match) {
                return position + match.index + 1; // Position after the word
            }
            
            return position;
        }
        
        getTextNodeAtOffset(offset) {
            // Helper method to find text node at character offset
            let currentOffset = 0;
            const walker = document.createTreeWalker(
                this.contentElement,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let node;
            while (node = walker.nextNode()) {
                const nodeLength = node.textContent.length;
                if (currentOffset + nodeLength >= offset) {
                    return {
                        node: node,
                        offset: offset - currentOffset
                    };
                }
                currentOffset += nodeLength;
            }
            
            // Fallback to last node
            const lastNode = this.contentElement.lastChild;
            if (lastNode && lastNode.nodeType === Node.TEXT_NODE) {
                return {
                    node: lastNode,
                    offset: lastNode.textContent.length
                };
            }
            
            return null;
        }
        
        async classifySelection(start, end, classification) {
            // Prevent duplicate submissions - check immediately
            if (this.isSubmitting) {
                console.log('Preventing duplicate submission - already submitting');
                return;
            }
            this.isSubmitting = true;
            
            try {
                const text = this.contentElement.textContent.substring(start, end);
                
                console.log('Classifying selection:', {
                    start: start,
                    end: end,
                    textLength: text.length,
                    textPreview: text.substring(0, 100),
                    classification: classification
                });
                
                // Close modal immediately to provide visual feedback
                this.closeModal();
                
                // Add the classification highlight
                this.addUserClassification(start, end, classification, text);
                
                // Save to server
                await this.saveClassification(start, end, text, classification);
                
                // Show success message
                this.showSuccessMessage('Text classified as ' + (classification === 'huntable' ? 'Huntable' : 'Not Huntable'));
                
            } finally {
                // Reset submission state after a short delay to prevent rapid clicking
                setTimeout(() => {
                    this.isSubmitting = false;
                }, 500);
            }
        }
        showRemoveAnnotationModal(spanElement, annotationType, annotationText) {
            // Store reference to the span element for removal
            this.pendingRemovalSpan = spanElement;
            this.pendingRemovalText = annotationText;
            
            // Create modal for removing annotation
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 z-50 flex items-center justify-center';
            
            // Add click outside to close
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    this.closeModal();
                }
            }.bind(this));
            
            // Add ESC key to close
            const handleEsc = function(e) {
                if (e.key === 'Escape') {
                    this.closeModal();
                    document.removeEventListener('keydown', handleEsc);
                }
            }.bind(this);
            document.addEventListener('keydown', handleEsc);
            
            modal.innerHTML = `
                <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                    <h3 class="text-lg font-semibold mb-4">Remove Annotation</h3>
                    <p class="text-sm text-gray-600 mb-2">
                        <strong>Type:</strong> ${annotationType === 'huntable' ? 'Huntable' : 'Not Huntable'}
                    </p>
                    <p class="text-sm text-gray-600 mb-4">
                        <strong>Text:</strong> "${annotationText.substring(0, 100)}${annotationText.length > 100 ? '...' : ''}"
                    </p>
                    <p class="text-sm text-gray-700 mb-4">
                        Do you want to remove this annotation?
                    </p>
                    <div class="flex space-x-3">
                        <button onclick="simpleTextManager.confirmRemoveAnnotation()" 
                                class="flex-1 bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700">
                            Remove
                        </button>
                        <button onclick="simpleTextManager.closeModal()" 
                                class="flex-1 px-4 py-2 border border-gray-300 rounded hover:bg-gray-50">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        async confirmRemoveAnnotation() {
            if (!this.pendingRemovalSpan || !this.pendingRemovalText) {
                console.error('No pending annotation removal');
                return;
            }
            
            try {
                // Save state for undo
                this.saveState();
                
                // Remove the span from the DOM (replace with original text)
                const originalText = this.pendingRemovalText;
                const parent = this.pendingRemovalSpan.parentNode;
                const textNode = document.createTextNode(originalText);
                parent.replaceChild(textNode, this.pendingRemovalSpan);
                
                // Find and delete the annotation from the database
                const response = await fetch(`/api/articles/{{ article.id }}/annotations`, {
                    method: 'GET'
                });
                const data = await response.json();
                
                if (data.success && data.annotations.length > 0) {
                    // Find the annotation that matches our text
                    const matchingAnnotation = data.annotations.find(annotation => 
                        annotation.selected_text === originalText
                    );
                    
                    if (matchingAnnotation) {
                        // Delete it from database
                        const deleteResponse = await fetch(`/api/articles/{{ article.id }}/annotations/${matchingAnnotation.id}`, {
                            method: 'DELETE'
                        });
                        
                        if (deleteResponse.ok) {
                            console.log(`Removed annotation ID ${matchingAnnotation.id} from database`);
                        } else {
                            console.error('Failed to remove annotation from database');
                        }
                    } else {
                        console.log('Could not find matching annotation in database');
                    }
                }
                
                // Clear pending removal references
                this.pendingRemovalSpan = null;
                this.pendingRemovalText = null;
                
                console.log('Annotation removed successfully');
                
            } catch (error) {
                console.error('Error removing annotation:', error);
            }
            
            this.closeModal();
        }
        
        closeModal() {
            const modal = document.querySelector('.fixed.inset-0.bg-gray-600.bg-opacity-50');
            if (modal) {
                modal.remove();
            }
        }
        
        showSuccessMessage(message) {
            // Create a temporary success message
            const successDiv = document.createElement('div');
            successDiv.className = 'fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded shadow-lg z-50';
            successDiv.textContent = message;
            document.body.appendChild(successDiv);
            
            // Remove after 2 seconds
            setTimeout(() => {
                if (successDiv.parentNode) {
                    successDiv.parentNode.removeChild(successDiv);
                }
            }, 2000);
        }
        
        async saveClassification(start, end, text, classification) {
            try {
                console.log('Saving classification:', {
                    start: start,
                    end: end,
                    textLength: text.length,
                    textPreview: text.substring(0, 100),
                    classification: classification
                });
                
                const response = await fetch(`/api/articles/{{ article.id }}/annotations`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        selected_text: text,
                        start_position: start,
                        end_position: end,
                        annotation_type: classification
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API Error Response:', errorText);
                    throw new Error(`Failed to save classification: ${response.status} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log('Classification saved successfully:', result);
                
                // Show success notification
                showNotification(`Annotation saved successfully!`, 'success');
                
            } catch (error) {
                console.error('Error saving classification:', error);
                showNotification(`Failed to save annotation: ${error.message}`, 'error');
            }
        }
    }
    
    // Initialize the simple text manager
    let simpleTextManager;
    document.addEventListener('DOMContentLoaded', function() {
        simpleTextManager = new SimpleTextManager();
        
        // Add iPhone touch support
        addiPhoneTouchSupport();
    });
    
    // iPhone Touch Support for Text Selection
    function addiPhoneTouchSupport() {
        const contentElement = document.getElementById('article-content');
        if (!contentElement) return;
        
        let touchStartTime = 0;
        let touchStartPos = null;
        let isLongPress = false;
        let longPressTimer = null;
        
        // Add touch event listeners
        contentElement.addEventListener('touchstart', function(e) {
            touchStartTime = Date.now();
            touchStartPos = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
            };
            
            console.log('üì± Touch start at:', touchStartPos);
            
            // Start long press timer
            longPressTimer = setTimeout(() => {
                console.log('üì± Long press timer triggered');
                isLongPress = true;
                handleLongPress(e);
            }, 800); // 800ms for long press (more reliable on iPhone)
            
            // Don't prevent default to allow text selection
        }, { passive: true });
        
        contentElement.addEventListener('touchmove', function(e) {
            // Cancel long press if finger moves too much
            if (touchStartPos) {
                const deltaX = Math.abs(e.touches[0].clientX - touchStartPos.x);
                const deltaY = Math.abs(e.touches[0].clientY - touchStartPos.y);
                
                if (deltaX > 10 || deltaY > 10) {
                    clearTimeout(longPressTimer);
                    isLongPress = false;
                }
            }
        });
        
        contentElement.addEventListener('touchend', function(e) {
            clearTimeout(longPressTimer);
            
            if (!isLongPress) {
                // Handle regular tap for text selection
                handleTap(e);
            }
            
            isLongPress = false;
            touchStartPos = null;
        });
        
        function handleLongPress(e) {
            console.log('üì± iPhone long press detected');
            
            // Get text at touch point
            const touch = e.touches[0];
            const range = document.caretRangeFromPoint ? 
                document.caretRangeFromPoint(touch.clientX, touch.clientY) :
                document.createRange();
            
            if (range) {
                // Select word at touch point
                range.selectNodeContents(range.commonAncestorContainer);
                if (range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {
                    const textNode = range.commonAncestorContainer;
                    const text = textNode.textContent;
                    const touchOffset = range.startOffset;
                    
                    // Find word boundaries
                    let start = touchOffset;
                    let end = touchOffset;
                    
                    while (start > 0 && /\S/.test(text[start - 1])) start--;
                    while (end < text.length && /\S/.test(text[end])) end++;
                    
                    range.setStart(textNode, start);
                    range.setEnd(textNode, end);
                    
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // Trigger annotation modal
                    if (simpleTextManager && selection.toString().trim()) {
                        const selectedText = selection.toString();
                        const fullText = contentElement.textContent;
                        const startPos = fullText.indexOf(selectedText);
                        const endPos = startPos + selectedText.length;
                        
                        if (startPos !== -1) {
                            console.log('üì± iPhone: Triggering annotation modal');
                            simpleTextManager.showClassificationOptions(startPos, endPos);
                        }
                    }
                }
            }
        }
        
        function handleTap(e) {
            // Handle regular tap - let browser handle text selection
            console.log('üì± iPhone tap detected');
        }
        
        // Primary method: Double-tap to activate annotation modal
        let tapCount = 0;
        let tapTimer = null;
        
        contentElement.addEventListener('touchend', function(e) {
            tapCount++;
            
            if (tapCount === 1) {
                tapTimer = setTimeout(() => {
                    tapCount = 0;
                }, 300);
            } else if (tapCount === 2) {
                clearTimeout(tapTimer);
                tapCount = 0;
                
                console.log('üì± Double tap detected - triggering annotation modal');
                
                // Get current selection
                const selection = window.getSelection();
                if (selection.toString().trim()) {
                    const selectedText = selection.toString();
                    const fullText = contentElement.textContent;
                    const startPos = fullText.indexOf(selectedText);
                    const endPos = startPos + selectedText.length;
                    
                    if (startPos !== -1 && simpleTextManager) {
                        console.log('üì± Double tap: Triggering annotation modal');
                        simpleTextManager.showClassificationOptions(startPos, endPos);
                    }
                } else {
                    // If no text is selected, try to select word at tap location
                    console.log('üì± Double tap: No selection, trying to select word');
                    selectWordAtTapLocation(e);
                }
            }
        });
        
        // Helper function to select word at tap location
        function selectWordAtTapLocation(e) {
            // Get touch coordinates
            const touch = e.changedTouches[0];
            const x = touch.clientX;
            const y = touch.clientY;
            
            // Try to get text at touch point
            if (document.caretRangeFromPoint) {
                const range = document.caretRangeFromPoint(x, y);
                if (range) {
                    const textNode = range.commonAncestorContainer;
                    if (textNode.nodeType === Node.TEXT_NODE) {
                        const text = textNode.textContent;
                        const offset = range.startOffset;
                        
                        // Find word boundaries
                        let start = offset;
                        let end = offset;
                        
                        while (start > 0 && /\S/.test(text[start - 1])) start--;
                        while (end < text.length && /\S/.test(text[end])) end++;
                        
                        if (start < end) {
                            // Create selection
                            const newRange = document.createRange();
                            newRange.setStart(textNode, start);
                            newRange.setEnd(textNode, end);
                            
                            const selection = window.getSelection();
                            selection.removeAllRanges();
                            selection.addRange(newRange);
                            
                            // Trigger annotation modal
                            const selectedText = selection.toString();
                            const fullText = contentElement.textContent;
                            const startPos = fullText.indexOf(selectedText);
                            const endPos = startPos + selectedText.length;
                            
                            if (startPos !== -1 && simpleTextManager) {
                                console.log('üì± Double tap: Word selected, triggering modal');
                                simpleTextManager.showClassificationOptions(startPos, endPos);
                            }
                        }
                    }
                }
            }
        }
        
        console.log('üì± iPhone touch support added');
        
        // Add iPhone instructions
        addiPhoneInstructions();
    }
    // Add mobile-friendly touch handlers for modal buttons
    function addMobileModalHandlers(modal, start, end) {
        // Huntable button
        const huntableBtn = modal.querySelector('#huntable-btn');
        if (huntableBtn) {
            huntableBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                console.log('üì± Huntable button clicked');
                simpleTextManager.classifySelection(start, end, 'huntable');
                simpleTextManager.closeModal();
            });
            
            huntableBtn.addEventListener('touchend', function(e) {
                e.stopPropagation();
                console.log('üì± Huntable button touched');
                simpleTextManager.classifySelection(start, end, 'huntable');
                simpleTextManager.closeModal();
            });
        }
        
        // Not Huntable button
        const notHuntableBtn = modal.querySelector('#not-huntable-btn');
        if (notHuntableBtn) {
            notHuntableBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                console.log('üì± Not Huntable button clicked');
                simpleTextManager.classifySelection(start, end, 'not_huntable');
                simpleTextManager.closeModal();
            });
            
            notHuntableBtn.addEventListener('touchend', function(e) {
                e.stopPropagation();
                console.log('üì± Not Huntable button touched');
                simpleTextManager.classifySelection(start, end, 'not_huntable');
                simpleTextManager.closeModal();
            });
        }
        
        // Cancel button
        const cancelBtn = modal.querySelector('#cancel-btn');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                console.log('üì± Cancel button clicked');
                simpleTextManager.closeModal();
            });
            
            cancelBtn.addEventListener('touchend', function(e) {
                e.stopPropagation();
                console.log('üì± Cancel button touched');
                simpleTextManager.closeModal();
            });
        }
        
        console.log('üì± Mobile modal handlers added');
    }
    
    function addiPhoneInstructions() {
        // Check if we're on mobile
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        if (!isMobile) return;
        
        // Add instructions banner
        const instructions = document.createElement('div');
        instructions.id = 'iphone-instructions';
        instructions.className = 'bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4 text-sm text-blue-800';
        instructions.innerHTML = `
            <div class="flex items-center space-x-2">
                <span class="text-lg">üì±</span>
                <div>
                    <strong>iPhone Annotation:</strong> 
                    <span class="block mt-1">
                        ‚Ä¢ <strong>Double-tap any word</strong> to select and annotate<br>
                        ‚Ä¢ <strong>Or select text normally</strong> then <strong>double-tap</strong> to annotate<br>
                        ‚Ä¢ <strong>Use "üéØ Auto 1000"</strong> to expand to 1000 characters<br>
                        ‚Ä¢ <strong>Perfect for ML training</strong>
                    </span>
                </div>
            </div>
        `;
        
        const contentElement = document.getElementById('article-content');
        if (contentElement && !document.getElementById('iphone-instructions')) {
            contentElement.parentNode.insertBefore(instructions, contentElement);
        }
    }
    
    // Classification functions
    async function classifyArticle(category) {
        const articleId = {{ article.id }};
        
        try {
            const response = await fetch(`/api/articles/${articleId}/classify`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    category: category
                })
            });
            
            if (response.ok) {
                // Show success message
                showNotification(`Article marked as ${category} successfully!`, 'success');
                
                // Update the current status display
                updateClassificationStatus(category);
            } else {
                const error = await response.json();
                showNotification(`Error: ${error.detail}`, 'error');
            }
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        }
    }
    
    function updateClassificationStatus(category) {
        console.log('updateClassificationStatus called with category:', category);
        
        // Find all spans with the status badge classes and filter by context
        const statusSpans = document.querySelectorAll('span.inline-flex.items-center.px-3.py-1.rounded-full');
        console.log('Found', statusSpans.length, 'status spans');
        
        // Look for the span that's in a div containing "Current Status:"
        let statusElement = null;
        for (const span of statusSpans) {
            const parentDiv = span.closest('div');
            console.log('Checking span:', span.textContent, 'parent text:', parentDiv ? parentDiv.textContent.substring(0, 50) : 'no parent');
            if (parentDiv && parentDiv.textContent.includes('Current Status:')) {
                statusElement = span;
                console.log('Found status element:', span);
                break;
            }
        }
        
        if (statusElement) {
            statusElement.className = 'inline-flex items-center px-3 py-1 rounded-full text-sm font-medium';
            
            if (category === 'chosen') {
                statusElement.className += ' bg-green-100 text-green-800';
                statusElement.textContent = '‚úÖ Chosen';
            } else if (category === 'rejected') {
                statusElement.className += ' bg-red-100 text-red-800';
                statusElement.textContent = '‚ùå Rejected';
            } else {
                statusElement.className += ' bg-gray-100 text-gray-800';
                statusElement.textContent = '‚è≥ Unclassified';
            }
            
            console.log('Status updated to:', category);
        } else {
            console.error('Could not find status element to update');
            console.log('Available spans:', Array.from(statusSpans).map(s => ({text: s.textContent, classes: s.className})));
        }
        
        // Store the current classification in localStorage for the AL/ML Assistant modal
        localStorage.setItem('currentArticleClassification', category);
    }
    
    function showNotification(message, type) {
        // Create notification element
        const notification = document.createElement('div');
        notification.className = `fixed top-4 right-4 z-50 p-4 rounded-md shadow-lg max-w-sm ${
            type === 'success' ? 'bg-green-500 text-white' : 
            type === 'error' ? 'bg-red-500 text-white' : 
            type === 'info' ? 'bg-blue-500 text-white' : 'bg-gray-500 text-white'
        }`;
        notification.textContent = message;
        
        // Add to page
        document.body.appendChild(notification);
        
        // Remove after 3 seconds
        setTimeout(() => {
            notification.remove();
        }, 3000);
    }
    
    function markOperationComplete(operationId, status = 'completed') {
        console.log('markOperationComplete called with:', operationId, status);
        
        // Update operation status in localStorage
        const ongoingOps = JSON.parse(localStorage.getItem('ongoingAIOperations') || '[]');
        const operationIndex = ongoingOps.findIndex(op => op.id === operationId);
        
        console.log('Found operation at index:', operationIndex, 'Operations:', ongoingOps);
        
        if (operationIndex !== -1) {
            ongoingOps[operationIndex].status = status;
            ongoingOps[operationIndex].completedAt = Date.now();
            localStorage.setItem('ongoingAIOperations', JSON.stringify(ongoingOps));
            
            // Store completion notification for cross-page display
            if (status === 'completed') {
                const completionNotification = {
                    id: `completion_${Date.now()}`,
                    operationId: operationId,
                    type: ongoingOps[operationIndex].type,
                    typeText: ongoingOps[operationIndex].typeText,
                    typeIcon: ongoingOps[operationIndex].typeIcon,
                    articleId: ongoingOps[operationIndex].articleId,
                    articleTitle: ongoingOps[operationIndex].articleTitle,
                    completedAt: Date.now()
                };
                
                console.log('Creating completion notification:', completionNotification);
                
                const completions = JSON.parse(localStorage.getItem('pendingCompletions') || '[]');
                completions.push(completionNotification);
                localStorage.setItem('pendingCompletions', JSON.stringify(completions));
                
                console.log('Stored pending completions:', completions);
            }
        }
    }
    
    function showCompletionBanner(type, typeText, typeIcon, articleId = null, articleTitle = null) {
        console.log('showCompletionBanner called with:', type, typeText, typeIcon, articleId, articleTitle);
        
        // Create completion banner
        const banner = document.createElement('div');
        banner.id = 'completionBanner';
        banner.className = 'fixed top-4 right-4 z-50 p-4 rounded-md shadow-lg max-w-sm bg-green-500 text-white';
        
        const bannerArticleTitle = articleTitle ? 
            articleTitle.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : 
            {{ article.title | tojson }};
        const bannerArticleId = articleId || {{ article.id }};
        
        banner.innerHTML = `
            <div class="flex items-center space-x-2">
                <span class="text-lg">${typeIcon}</span>
                <div class="flex-1">
                    <div class="font-medium">${typeText} Complete!</div>
                    <div class="text-sm opacity-90">Article: ${bannerArticleTitle.length > 30 ? bannerArticleTitle.substring(0, 30) + '...' : bannerArticleTitle}</div>
                    <a href="#" onclick="event.preventDefault(); window.location.hash = '${type}'; setTimeout(() => window.location.reload(), 100);" class="text-sm underline hover:no-underline">View Results ‚Üí</a>
                </div>
                <button onclick="this.parentElement.parentElement.remove()" class="text-white hover:text-gray-200">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
        `;
        
        // Add to page
        document.body.appendChild(banner);
        console.log('Banner added to DOM:', banner);
        
        // Remove after 10 seconds
        setTimeout(() => {
            const bannerElement = document.getElementById('completionBanner');
            if (bannerElement) {
                console.log('Removing banner after 10 seconds');
                bannerElement.remove();
            }
        }, 10000);
    }
    // Navigation functions
    async function navigateToNextUnclassified(retryCount = 0) {
        try {
            const response = await fetch(`/api/articles/next-unclassified?current_article_id={{ article.id }}`);
            const data = await response.json();
            
            if (data.article_id) {
                window.location.href = `/articles/${data.article_id}`;
            } else {
                // If no article found and we haven't retried yet, wait and retry once
                if (retryCount === 0) {
                    console.log('No unclassified article found, retrying in 1 second...');
                    setTimeout(() => {
                        navigateToNextUnclassified(1);
                    }, 1000);
            } else {
                showNotification('No more unclassified articles found!', 'info');
                }
            }
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        }
    }
    
    async function navigateToPrevious() {
        try {
            const currentId = {{ article.id }};
            const response = await fetch(`/api/articles/previous?current_article_id=${currentId}`);
            const data = await response.json();
            
            if (data.article_id) {
                window.location.href = `/articles/${data.article_id}`;
            } else {
                showNotification('No previous article found', 'info');
            }
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        }
    }
    
    async function navigateToNext() {
        try {
            const currentId = {{ article.id }};
            const response = await fetch(`/api/articles/next?current_article_id=${currentId}`);
            const data = await response.json();
            
            if (data.article_id) {
                window.location.href = `/articles/${data.article_id}`;
            } else {
                showNotification('No next article found', 'info');
            }
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        }
    }
    
    // AL/ML Assistant Functions
    async function showAIAssistant() {
        // Get AI model from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const aiModel = settings.aiModel || 'chatgpt';
        
        // Check content size limits
        const contentLength = {{ article.content|length if article.content else 0 }};
        const contentLimit = aiModel === 'chatgpt' ? {{ chatgpt_content_limit }} : 
                           aiModel === 'anthropic' ? {{ anthropic_content_limit }} : {{ ollama_content_limit }};
        
        if (contentLength > contentLimit) {
            const modelName = aiModel === 'chatgpt' ? 'ChatGPT' : 
                            aiModel === 'anthropic' ? 'Claude' : 
                            aiModel === 'tinyllama' ? 'TinyLlama' : 'Llama';
            showNotification(`Article too large for ${modelName}. Content: ${contentLength.toLocaleString()} chars, limit: ${contentLimit.toLocaleString()} chars.`, 'warning');
            return;
        }
        
        // Get current article classification
        const currentClassification = localStorage.getItem('currentArticleClassification') || '{{ article.article_metadata.get("training_category", "") }}';
        const isChosen = currentClassification === 'chosen';
        
        // Get threat hunting score for SIGMA warning
        const threatHuntingScore = {{ article.article_metadata.get('threat_hunting_score', 0) if article.article_metadata and article.article_metadata.get('threat_hunting_score') else 0 }};
        const showSigmaWarning = isChosen && threatHuntingScore < 65;
        
        // Fetch fresh data from API to get current state
        let hasSigmaRules = {{ 'true' if article.article_metadata and article.article_metadata.get('sigma_rules') else 'false' }};
        let hasIOCs = {{ 'true' if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'false' }};
        let hasRanking = {{ 'true' if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'false' }};
        
        try {
            const response = await fetch(`/api/articles/{{ article.id }}`);
            if (response.ok) {
                const data = await response.json();
                if (data.article_metadata) {
                    hasSigmaRules = data.article_metadata.sigma_rules ? true : false;
                    hasIOCs = data.article_metadata.extracted_iocs ? true : false;
                    hasRanking = data.article_metadata.gpt4o_ranking ? true : false;
                }
            }
        } catch (error) {
            console.log('Failed to fetch fresh data, using template data:', error);
        }
        
        const modal = document.createElement('div');
        modal.id = 'aiAssistantModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeAIAssistantModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeAIAssistantModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        // Determine if there is existing generated content to display/regenerate
        const hasExisting = hasSigmaRules || hasIOCs || hasRanking;
        const rankingButtonText = hasRanking ? 
            (aiModel === 'chatgpt' ? 'Display GPT4o Rank' : 
             aiModel === 'anthropic' ? 'Display Claude Rank' : 'Display LLM Rank') :
            (aiModel === 'chatgpt' ? 'Rank with GPT4o' : 
             aiModel === 'anthropic' ? 'Rank with Claude' : 'Rank with LLM');
        
        modal.innerHTML = `
            <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <h3 class="text-lg font-medium text-gray-900 mb-4">ü§ñ AL/ML Assistant</h3>
                    <p class="text-sm text-gray-500 mb-6">Choose what you'd like to ${hasExisting ? 'view or regenerate' : 'generate'}:</p>
                    
                    <div class="space-y-3">
                        <button onclick="generateAIAnalysis('sigma')" 
                                class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md transition-colors ${isChosen ? 'text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500' : 'text-gray-400 bg-gray-300 cursor-not-allowed'}"
                                ${!isChosen ? 'disabled' : ''}
                                title="${isChosen ? (hasSigmaRules ? 'Display existing SIGMA detection rules' : 'Generate SIGMA detection rules for this article') : 'SIGMA rules can only be generated for articles marked as "Chosen". Please classify this article first.'}">
                            <span class="mr-2">üîç</span>
                            ${hasSigmaRules ? 'Display SIGMA Rules' : 'Generate SIGMA Rules'}
                            ${showSigmaWarning ? '<span class="ml-2 text-yellow-300">‚ö†Ô∏è</span>' : ''}
                        </button>
                        ${!isChosen ? '<div class="text-xs text-gray-500 text-center mt-1">‚ö†Ô∏è Only available for articles marked as "Chosen"</div>' : ''}
                        ${showSigmaWarning ? '<div class="text-xs text-yellow-600 text-center mt-1">‚ö†Ô∏è Low threat hunting score (' + threatHuntingScore + '/100) - SIGMA rules may lack technical depth</div>' : ''}
                        
                        <button onclick="generateAIAnalysis('iocs')" 
                                class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-orange-600 hover:bg-orange-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500 transition-colors">
                            <span class="mr-2">üîç</span>
                            ${hasIOCs ? 'Display IOCs' : 'Extract IOCs'}
                        </button>
                        
                        <button onclick="generateAIAnalysis('ranking')" 
                                class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors">
                            <span class="mr-2">üìä</span>
                            ${rankingButtonText}
                        </button>
                        
                        <button onclick="showCustomPromptModal()" 
                                class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-purple-600 hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                            <span class="mr-2">üí¨</span>
                            Custom Prompt
                        </button>
                        
                        <button onclick="showChunkDebugModal()" 
                                class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                            <span class="mr-2">üîç</span>
                            Chunk ML Feedback
                        </button>
                        
                        <button onclick="closeAIAssistantModal()" 
                                class="w-full inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                            Cancel
                        </button>
                    </div>
                    
                    <div class="mt-4 p-2 bg-gray-50 rounded text-xs text-gray-600">
                        Using: ${aiModel === 'chatgpt' ? 'ChatGPT (OpenAI)' : 
                               aiModel === 'anthropic' ? 'Claude (Anthropic)' : 
                               aiModel === 'tinyllama' ? 'TinyLlama (Local)' : 'Llama (Local)'}
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }
    
    function closeAIAssistantModal() {
        const modal = document.getElementById('aiAssistantModal');
        if (modal) {
            modal.remove();
        }
    }
    
    async function generateAIAnalysis(type, forceRegenerate = false, useLLMValidation = false) {
        closeAIAssistantModal();
        
        // Check for existing content first (unless force regenerate)
        if (!forceRegenerate) {
            if (type === 'sigma' && {{ 'true' if article.article_metadata and article.article_metadata.get('sigma_rules') else 'false' }}) {
                const sigmaData = {{ article.article_metadata.get('sigma_rules') | tojson if article.article_metadata and article.article_metadata.get('sigma_rules') else 'null' }};
                // Parse conversation log if it's a string
                if (sigmaData && sigmaData.metadata && sigmaData.metadata.conversation && typeof sigmaData.metadata.conversation === 'string') {
                    try {
                        sigmaData.metadata.conversation = JSON.parse(sigmaData.metadata.conversation);
                    } catch (e) {
                        console.error('Failed to parse conversation log:', e);
                        sigmaData.metadata.conversation = [];
                    }
                }
                showSigmaRulesModal(sigmaData.rules, sigmaData);
                return;
            }
            
            if (type === 'iocs' && {{ 'true' if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'false' }}) {
                const iocData = {{ article.article_metadata.get('extracted_iocs') | tojson if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'null' }};
                
                // Check if the data has the old field name and force regeneration
                if (iocData && 'llm_validation_used' in iocData && !('use_llm_validation' in iocData)) {
                    console.log('Detected old IOC field name, forcing regeneration...');
                    // Fall through to regeneration instead of showing cached data
                } else {
                    showIOCsModal(JSON.stringify(iocData.iocs, null, 2), iocData);
                    return;
                }
            }
            
            if (type === 'ranking' && {{ 'true' if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'false' }}) {
                const rankingData = {{ article.article_metadata.get('gpt4o_ranking') | tojson if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'null' }};
                showGPT4oRankingModal(rankingData.analysis, rankingData);
                return;
            }
        }
        
        // Check if SIGMA rules are allowed for this article
        if (type === 'sigma') {
            const currentClassification = localStorage.getItem('currentArticleClassification') || '{{ article.article_metadata.get("training_category", "") }}';
            const isChosen = currentClassification === 'chosen';
            if (!isChosen) {
                showNotification('SIGMA rules can only be generated for articles marked as "Chosen". Please classify this article first.', 'error');
                return;
            }
            
            // Check threat hunting score for SIGMA rules
            const threatHuntingScore = {{ article.article_metadata.get('threat_hunting_score', 0) if article.article_metadata and article.article_metadata.get('threat_hunting_score') else 0 }};
            if (threatHuntingScore < 65) {
                const confirmed = confirm(`‚ö†Ô∏è Warning: This article has a low threat hunting score (${threatHuntingScore}/100).\n\nSIGMA rules are not recommended for articles with scores below 65 as they may lack sufficient technical depth for effective detection rules.\n\nDo you want to proceed anyway?`);
                if (!confirmed) {
                    return;
                }
            }
        }
        
        // Get AI model from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        let aiModel = settings.aiModel || 'chatgpt';
        
        // Fix: If OpenAI API key is configured but model is still 'lmstudio' (stale localStorage),
        // default to 'chatgpt' to honor the user's settings page selection
        if (aiModel === 'lmstudio' && settings.openaiApiKey) {
            console.warn('‚ö†Ô∏è Detected stale localStorage: aiModel is "lmstudio" but OpenAI API key is configured. Defaulting to "chatgpt".');
            aiModel = 'chatgpt';
            // Update localStorage to persist the fix
            settings.aiModel = 'chatgpt';
            localStorage.setItem('ctiScraperSettings', JSON.stringify(settings));
        }
        // Fix: Similarly for Anthropic
        if (aiModel === 'lmstudio' && settings.anthropicApiKey) {
            console.warn('‚ö†Ô∏è Detected stale localStorage: aiModel is "lmstudio" but Anthropic API key is configured. Defaulting to "anthropic".');
            aiModel = 'anthropic';
            // Update localStorage to persist the fix
            settings.aiModel = 'anthropic';
            localStorage.setItem('ctiScraperSettings', JSON.stringify(settings));
        }
        
        // Only set API key for cloud models that require it
        let apiKey = null;
        if (aiModel === 'anthropic') {
            apiKey = settings.anthropicApiKey;
        } else if (aiModel === 'chatgpt') {
            apiKey = settings.openaiApiKey;
        }
        
        // DEBUG: Log what we got from localStorage
        console.log(`üîç DEBUG: aiModel="${aiModel}", openaiApiKey exists=${!!settings.openaiApiKey}, anthropicApiKey exists=${!!settings.anthropicApiKey}`);
        console.log(`üîç DEBUG: apiKey after selection=${apiKey ? 'EXISTS' : 'NULL'}, type=${typeof apiKey}, length=${apiKey ? apiKey.length : 0}`);
        
        if (apiKey) {
            console.log(`üîç DEBUG localStorage: apiKey type: ${typeof apiKey}, length: ${apiKey.length}, ends_with: ...${apiKey.substring(apiKey.length - 4)}`);
            console.log(`üîç DEBUG localStorage: Full key check - ends with "1WQA": ${apiKey.endsWith('1WQA')}, ends with "gkMA": ${apiKey.endsWith('gkMA')}`);
            
            // CRITICAL: Detect if key is corrupted (ends with gkMA instead of expected 1WQA)
            if (apiKey.endsWith('gkMA')) {
                console.error(`‚ùå CORRUPTED API KEY DETECTED: Key ends with 'gkMA' instead of expected '1WQA'`);
                console.error(`‚ùå This indicates localStorage corruption. The key must be re-entered in Settings.`);
                showNotification(
                    '‚ö†Ô∏è API key appears corrupted in localStorage (ends with gkMA). Please go to Settings and re-enter your OpenAI API key.',
                    'error'
                );
                return;
            }
        } else {
            // DEBUG: More detailed logging when apiKey is null
            console.warn(`‚ö†Ô∏è DEBUG: apiKey is NULL. aiModel="${aiModel}", settings keys:`, {
                hasOpenaiKey: !!settings.openaiApiKey,
                hasAnthropicKey: !!settings.anthropicApiKey,
                openaiKeyLength: settings.openaiApiKey ? settings.openaiApiKey.length : 0,
                anthropicKeyLength: settings.anthropicApiKey ? settings.anthropicApiKey.length : 0
            });
        }
        
        // Strip whitespace from API key (common issue when copying/pasting)
        if (apiKey && typeof apiKey === 'string') {
            const beforeTrim = apiKey;
            apiKey = apiKey.trim();
            
            // DEBUG: Check if trim changed anything
            if (beforeTrim !== apiKey) {
                console.warn(`‚ö†Ô∏è API key had whitespace - trimmed from ${beforeTrim.length} to ${apiKey.length}`);
            }
            
            // Validate key format before using
            if (!apiKey.startsWith('sk-')) {
                console.error(`‚ùå ERROR: API key doesn't start with 'sk-': ${apiKey.substring(0, 10)}...`);
                showNotification('Invalid API key format in localStorage. Please re-enter your API key in Settings.', 'error');
                return;
            }
            
            if (apiKey.startsWith('sk-proj-') && apiKey.length < 100) {
                console.error(`‚ùå ERROR: API key appears truncated: length ${apiKey.length} (expected 100+ for sk-proj- keys)`);
                showNotification('API key appears truncated in localStorage. Please re-enter your API key in Settings.', 'error');
                return;
            }
            
            // Update localStorage with trimmed value to persist the fix
            if (aiModel === 'anthropic') {
                settings.anthropicApiKey = apiKey;
            } else if (aiModel === 'chatgpt') {
                settings.openaiApiKey = apiKey;
            }
            localStorage.setItem('ctiScraperSettings', JSON.stringify(settings));
        }
        // For local models like lmstudio, apiKey remains null
        
        if ((aiModel === 'chatgpt' || aiModel === 'anthropic') && !apiKey) {
            const keyType = aiModel === 'anthropic' ? 'Anthropic' : 'OpenAI';
            console.error(`‚ùå ERROR: ${keyType} API key not found! aiModel="${aiModel}", apiKey is ${apiKey ? 'NOT NULL' : 'NULL'}`);
            console.error(`‚ùå DEBUG: Full settings from localStorage:`, {
                aiModel: settings.aiModel,
                hasOpenaiKey: !!settings.openaiApiKey,
                hasAnthropicKey: !!settings.anthropicApiKey,
                openaiKeyLength: settings.openaiApiKey ? settings.openaiApiKey.length : 0,
                anthropicKeyLength: settings.anthropicApiKey ? settings.anthropicApiKey.length : 0,
                allSettingsKeys: Object.keys(settings)
            });
            showNotification(`Please configure your ${keyType} API key in Settings first. Make sure to click "Save Settings" after entering the key.`, 'error');
            return;
        }
        
        // Store ongoing AI operation in localStorage for cross-page tracking
        const articleId = {{ article.id }};
        const operationId = `ai_${type}_${articleId}_${Date.now()}`;
        const operationData = {
            id: operationId,
            type: type,
            typeText: type === 'sigma' ? 'SIGMA Rules' : type === 'ranking' ? (aiModel === 'chatgpt' ? 'GPT4o Ranking' : 'Local AI Ranking') : 'IOCs',
            typeIcon: type === 'sigma' ? 'üîç' : type === 'ranking' ? 'üìä' : 'üîç',
            articleId: articleId,
            articleTitle: {{ article.title | tojson }},
            startedAt: Date.now(),
            status: 'running'
        };
        
        // Store in localStorage
        const ongoingOps = JSON.parse(localStorage.getItem('ongoingAIOperations') || '[]');
        ongoingOps.push(operationData);
        localStorage.setItem('ongoingAIOperations', JSON.stringify(ongoingOps));
        
        // Show loading modal
        const loadingModal = document.createElement('div');
        loadingModal.id = 'loadingModal';
        loadingModal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        const typeText = operationData.typeText;
        const typeIcon = operationData.typeIcon;
        
        // Debug logging
        console.log('generateAIAnalysis called with type:', type);
        console.log('typeText:', typeText);
        console.log('typeIcon:', typeIcon);
        
        // Track if request has started
        let requestStarted = false;
        
        // Add ESC key handler to close loading modal
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('loadingModal');
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleEsc);
                
                // Only show background message if request actually started
                if (requestStarted) {
                    showNotification('AI generation continues in the background. You can return to this article later to view the results.', 'info');
                }
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        loadingModal.innerHTML = `
            <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-purple-100">
                        <svg class="animate-spin h-6 w-6 text-purple-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <h3 class="text-lg font-medium text-gray-900 mt-4">${typeIcon} ${type === 'sigma' ? 'Generating' : type === 'ranking' ? 'Generating' : 'Extracting'} ${typeText}...</h3>
                    <p class="text-sm text-gray-500 mt-2">${type === 'sigma' ? 'Creating detection rules' : type === 'ranking' ? (aiModel === 'chatgpt' ? 'Analyzing content with GPT-4o' : 'Analyzing content with local AI') : 'Extracting indicators of compromise'} - this may take a few moments.</p>
                    <p class="text-xs text-gray-400 mt-3">üí° Press <kbd class="px-1 py-0.5 bg-gray-200 rounded text-xs">ESC</kbd> to leave while generation continues</p>
                </div>
            </div>
        `;
        document.body.appendChild(loadingModal);
        
        try {
            // Create a timeout promise - longer for LLM operations
            const timeoutPromise = new Promise((_, reject) => {
                const timeoutMs = aiModel === 'chatgpt' ? 180000 : 600000; // 180s for ChatGPT, 600s for LLM
                setTimeout(() => reject(new Error(`Request timed out after ${timeoutMs/1000} seconds`)), timeoutMs);
            });
            
            // Create the fetch promise
            const endpoint = type === 'sigma' ? 'generate-sigma' : type === 'ranking' ? 'rank-with-gpt4o' : 'extract-iocs';
            
            // Prepare request body
            const requestBody = {
                include_content: true,
                force_regenerate: forceRegenerate,
                ai_model: aiModel,
                temperature: parseFloat(settings.aiTemperature || '0.3')
            };
            
            // Only include API key if it's provided (for cloud models)
            if (apiKey) {
                // DEBUG: Log before assignment
                console.log(`üîç DEBUG Frontend: apiKey type: ${typeof apiKey}, length: ${apiKey.length}, ends_with: ...${apiKey.substring(apiKey.length - 4)}`);
                requestBody.api_key = apiKey;
                // DEBUG: Log after assignment
                console.log(`üîç DEBUG Frontend: requestBody.api_key type: ${typeof requestBody.api_key}, length: ${requestBody.api_key.length}, ends_with: ...${requestBody.api_key.substring(requestBody.api_key.length - 4)}`);
                // Debug logging (masked for security)
                const apiKeyPreview = apiKey.length > 12 ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 4)}` : 'N/A';
                console.log(`üîë Sending API key with length: ${apiKey.length}, preview: ${apiKeyPreview}`);
                // DEBUG: Log full request body size
                console.log(`üîç DEBUG Frontend: requestBody JSON size: ${JSON.stringify(requestBody).length} chars`);
            } else {
                console.warn(`‚ö†Ô∏è No API key available for model: ${aiModel}`);
            }
            
            // Add LLM validation setting for IOC extraction
            if (type === 'iocs') {
                requestBody.use_llm_validation = useLLMValidation;
                
                // Add optimization options for IOC extraction when LLM validation is enabled
                if (useLLMValidation && requestBody.optimization_options) {
                    requestBody.use_filtering = requestBody.optimization_options.useFiltering;
                    requestBody.min_confidence = requestBody.optimization_options.minConfidence;
                }
            }
            
            // Add author name for SIGMA rules
            if (type === 'sigma') {
                const sigmaAuthor = settings.sigmaAuthor || 'Huntable CTI Scraper User';
                requestBody.author_name = sigmaAuthor;
            }
            
            // Add optimization options for ranking, sigma, and IOC extraction with LLM validation
            // Only show optimization dialog for cloud models to prevent UI hanging
            const shouldShowOptimization = (type === 'ranking' || type === 'sigma' || 
                (type === 'iocs' && useLLMValidation && ['chatgpt', 'anthropic'].includes(aiModel)));
            
            console.log('shouldShowOptimization:', shouldShowOptimization, 'type:', type, 'useLLMValidation:', useLLMValidation, 'aiModel:', aiModel);
            
            if (shouldShowOptimization) {
                console.log('Showing optimization dialog...');
                const optimizationOptions = await showOptimizationDialog();
                if (!optimizationOptions) {
                    // User cancelled - clean up and return
                    const loadingModal = document.getElementById('loadingModal');
                    if (loadingModal && loadingModal.parentNode) {
                        loadingModal.remove();
                    }
                    document.removeEventListener('keydown', handleEsc);
                    return;
                }
                requestBody.optimization_options = optimizationOptions;
            }
            
            console.log('Making fetch request to:', `/api/articles/{{ article.id }}/${endpoint}`);
            // DEBUG: Check API key in request body before sending
            if (requestBody.api_key) {
                const keyInBody = requestBody.api_key;
                console.log(`üîç DEBUG Before Fetch: requestBody.api_key length: ${keyInBody.length}, ends_with: ...${keyInBody.substring(keyInBody.length - 4)}`);
                console.log(`üîç DEBUG Before Fetch: Key ends with "1WQA": ${keyInBody.endsWith('1WQA')}, ends with "gkMA": ${keyInBody.endsWith('gkMA')}`);
                
                // Stringify and parse back to check for corruption
                const stringified = JSON.stringify(requestBody);
                const parsedBack = JSON.parse(stringified);
                if (parsedBack.api_key) {
                    console.log(`üîç DEBUG After JSON round-trip: api_key length: ${parsedBack.api_key.length}, ends_with: ...${parsedBack.api_key.substring(parsedBack.api_key.length - 4)}`);
                    if (parsedBack.api_key !== keyInBody) {
                        console.error(`‚ùå ERROR: API key corrupted during JSON stringify/parse!`);
                        console.error(`Original: ...${keyInBody.substring(keyInBody.length - 10)}`);
                        console.error(`After:    ...${parsedBack.api_key.substring(parsedBack.api_key.length - 10)}`);
                    }
                }
            }
            console.log('Request body (without content):', {...requestBody, include_content: requestBody.include_content ? '[CONTENT INCLUDED]' : false});
            
            // Send API key in header instead of body to avoid corruption with large payloads
            const fetchHeaders = {
                'Content-Type': 'application/json',
            };
            if (apiKey) {
                // FINAL VALIDATION: Check key one more time before sending
                const keyEnd = apiKey.substring(apiKey.length - 4);
                if (keyEnd === 'gkMA') {
                    console.error(`‚ùå CORRUPTED KEY DETECTED AT SEND TIME: ends with 'gkMA'`);
                    showNotification(
                        '‚ö†Ô∏è API key corruption detected. Please go to Settings and re-enter your OpenAI API key.',
                        'error'
                    );
                    return;
                }
                
                // Use appropriate header based on model
                if (aiModel === 'anthropic') {
                    fetchHeaders['X-Anthropic-API-Key'] = apiKey;
                } else {
                    fetchHeaders['X-OpenAI-API-Key'] = apiKey;
                }
                
                // DEBUG: Log what we're actually sending
                console.log(`üîç DEBUG Send: Setting ${aiModel === 'anthropic' ? 'X-Anthropic-API-Key' : 'X-OpenAI-API-Key'} header with key ending: ...${keyEnd}`);
                
                // Remove from body to avoid potential corruption
                delete requestBody.api_key;
            }
            
            const fetchPromise = fetch(`/api/articles/{{ article.id }}/${endpoint}`, {
                method: 'POST',
                headers: fetchHeaders,
                body: JSON.stringify(requestBody)
            });
            
            // Mark request as started
            requestStarted = true;
            
            // Race between fetch and timeout
            const response = await Promise.race([fetchPromise, timeoutPromise]);
            
            if (response.ok) {
                const data = await response.json();
                
                console.log('AI generation completed successfully:', data);
                
                // Mark operation as complete and show banner
                markOperationComplete(operationId);
                showCompletionBanner(type, typeText, typeIcon);
                
                console.log('Completion banner should be showing now');
                
                // Don't automatically show results - let user choose when to view them
            } else {
                const error = await response.json();
                console.log('API Error:', error);
                markOperationComplete(operationId, 'failed');
                showNotification(`${typeText} ${type === 'sigma' ? 'generation' : type === 'ranking' ? 'generation' : 'extraction'} failed: ${error.detail}`, 'error');
            }
        } catch (error) {
            console.log('Caught error:', error);
            markOperationComplete(operationId, 'failed');
            if (error.message.includes('timed out')) {
                const timeoutMsg = aiModel === 'chatgpt' ? '60 seconds' : '200 seconds';
                showNotification(`${typeText} ${type === 'sigma' ? 'generation' : type === 'ranking' ? 'generation' : 'extraction'} timed out after ${timeoutMsg}. Try using a different model or check your settings.`, 'error');
            } else {
                showNotification(`Error: ${error.message}`, 'error');
            }
        } finally {
            // Remove loading modal and clean up ESC handler
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.parentNode) {
                loadingModal.remove();
            }
            // Clean up the ESC key handler
            document.removeEventListener('keydown', handleEsc);
        }
    }
    
    // Enhanced GPT4o Ranking Function with Content Filtering
    async function rankWithGPT4o() {
        const articleId = {{ article.id }};
        
        // Get API key from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        let aiModel = settings.aiModel || 'chatgpt';
        
        // Fix: If OpenAI API key is configured but model is still 'lmstudio' (stale localStorage),
        // default to 'chatgpt' to honor the user's settings page selection
        if (aiModel === 'lmstudio' && settings.openaiApiKey) {
            console.warn('‚ö†Ô∏è Detected stale localStorage: aiModel is "lmstudio" but OpenAI API key is configured. Defaulting to "chatgpt".');
            aiModel = 'chatgpt';
            // Update localStorage to persist the fix
            settings.aiModel = 'chatgpt';
            localStorage.setItem('ctiScraperSettings', JSON.stringify(settings));
        }
        // Fix: Similarly for Anthropic
        if (aiModel === 'lmstudio' && settings.anthropicApiKey) {
            console.warn('‚ö†Ô∏è Detected stale localStorage: aiModel is "lmstudio" but Anthropic API key is configured. Defaulting to "anthropic".');
            aiModel = 'anthropic';
            // Update localStorage to persist the fix
            settings.aiModel = 'anthropic';
            localStorage.setItem('ctiScraperSettings', JSON.stringify(settings));
        }
        
        // Only set API key for cloud models that require it
        let apiKey = null;
        if (aiModel === 'anthropic') {
            apiKey = settings.anthropicApiKey;
        } else if (aiModel === 'chatgpt') {
            apiKey = settings.openaiApiKey;
        }
        // For local models like lmstudio, apiKey remains null
        
        if ((aiModel === 'chatgpt' || aiModel === 'anthropic') && !apiKey) {
            const keyType = aiModel === 'anthropic' ? 'Anthropic' : 'OpenAI';
            showNotification(`Please configure your ${keyType} API key in Settings first`, 'error');
            return;
        }
        
        // Show optimization options dialog
        const optimizationOptions = await showOptimizationDialog();
        if (!optimizationOptions) {
            return; // User cancelled
        }
        
        // Estimate cost before proceeding (only for ChatGPT)
        if (aiModel === 'chatgpt') {
            const articleContent = {{ article.content[:1000] | tojson }}; // Get first 1000 chars for estimation
            const estimatedTokens = Math.ceil(articleContent.length / 4); // Rough estimate: 1 token ‚âà 4 chars
            const promptTokens = 1508; // Updated prompt length (6,033 chars ‚âà 1,508 tokens)
            const totalTokens = estimatedTokens + promptTokens;
            
            // GPT4o pricing: $5.00 per 1M input tokens, $15.00 per 1M output tokens
            const inputCost = (totalTokens / 1000000) * 5.00;
            const outputCost = (2000 / 1000000) * 15.00; // Assume 2000 output tokens
            const totalCost = inputCost + outputCost;
            
            // Estimate cost savings if filtering is enabled
            let costSavings = 0;
            let costMessage = `Estimated cost: $${totalCost.toFixed(4)} (${totalTokens.toLocaleString()} input tokens + ~2,000 output tokens)`;
            
            if (optimizationOptions.useFiltering) {
                // Dynamic cost reduction based on confidence threshold
                // Lower confidence = more aggressive filtering = higher savings
                let savingsPercent = 0;
                if (optimizationOptions.minConfidence <= 0.5) {
                    savingsPercent = 0.6; // 60% savings for aggressive filtering
                } else if (optimizationOptions.minConfidence <= 0.7) {
                    savingsPercent = 0.4; // 40% savings for balanced filtering
                } else {
                    savingsPercent = 0.25; // 25% savings for conservative filtering
                }
                
                costSavings = totalCost * savingsPercent;
                const optimizedCost = totalCost - costSavings;
                costMessage = `Estimated cost: $${optimizedCost.toFixed(4)} (${(savingsPercent*100).toFixed(0)}% savings from content filtering)`;
            }
            
            const confirmed = confirm(`GPT4o Analysis Cost Estimate:\n\n${costMessage}\n\nOptimization: ${optimizationOptions.useFiltering ? 'Enabled' : 'Disabled'}\nConfidence Threshold: ${optimizationOptions.minConfidence}\n\nDo you want to proceed with the analysis?`);
            if (!confirmed) {
                return;
            }
        }
        
        // Show loading state
        const button = document.querySelector('button[onclick="rankWithGPT4o()"]');
        const originalText = button.innerHTML;
        button.innerHTML = '<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Analyzing...';
        button.disabled = true;
        button.classList.add('opacity-75', 'cursor-not-allowed');
        
        try {
            // Build request body conditionally
            const rankRequestBody = {
                use_filtering: optimizationOptions.useFiltering,
                min_confidence: optimizationOptions.minConfidence,
                ai_model: aiModel
            };
            
            // Send API key in header instead of body to avoid corruption with large payloads
            const rankFetchHeaders = {
                'Content-Type': 'application/json',
            };
            if (apiKey) {
                if (aiModel === 'anthropic') {
                    rankFetchHeaders['X-Anthropic-API-Key'] = apiKey;
                } else {
                    rankFetchHeaders['X-OpenAI-API-Key'] = apiKey;
                }
                // Don't include in body to avoid potential corruption
            }
            
            const response = await fetch(`/api/articles/${articleId}/rank-with-gpt4o`, {
                method: 'POST',
                headers: rankFetchHeaders,
                body: JSON.stringify(rankRequestBody)
            });
            
            if (response.ok) {
                const data = await response.json();
                showGPT4oRankingModal(data.analysis, data);
                
                // Show optimization results if available
                if (data.optimization && data.optimization.enabled) {
                    const opt = data.optimization;
                    showNotification(
                        `GPT4o analysis completed! Cost savings: $${opt.cost_savings.toFixed(4)} (${opt.tokens_saved.toLocaleString()} tokens saved, ${opt.chunks_removed} chunks removed)`, 
                        'success'
                    );
                    
                    // Show debug info if available
                    if (data.debug_info && data.debug_info.removed_chunks.length > 0) {
                        showRemovedChunksDialog(data.debug_info);
                    }
                } else {
                    showNotification('GPT4o analysis completed successfully!', 'success');
                }
            } else {
                const error = await response.json();
                showNotification(`GPT4o analysis failed: ${error.detail}`, 'error');
            }
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        } finally {
            // Restore button state
            button.innerHTML = originalText;
            button.disabled = false;
            button.classList.remove('opacity-75', 'cursor-not-allowed');
        }
    }
    // Show optimization options dialog
    async function showOptimizationDialog() {
        return new Promise((resolve) => {
            // Get AI model from settings to determine modal title
            const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
            const aiModel = settings.aiModel || 'chatgpt';
            const modelDisplayName = aiModel === 'chatgpt' ? 'GPT-4o' : 
                                    aiModel === 'anthropic' ? 'Claude' : 
                                    aiModel === 'tinyllama' ? 'TinyLlama' : 'LLM';
            
            // Create modal dialog
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold text-gray-900">${modelDisplayName} Content Optimization</h3>
                        <button onclick="showRankingHelp()" class="text-gray-400 hover:text-gray-600 text-sm px-2 py-1 rounded">
                            Help
                        </button>
                    </div>
                    
                    <div class="space-y-4">
                        <div class="flex items-center">
                            <input type="checkbox" id="useFiltering" checked class="mr-3">
                            <label for="useFiltering" class="text-sm text-gray-700">
                                Enable content filtering to reduce costs
                            </label>
                        </div>
                        
                        <div id="confidenceSection" class="ml-6">
                            <label for="minConfidence" class="block text-sm text-gray-700 mb-2">
                                Confidence threshold:
                            </label>
                            <select id="minConfidence" class="w-full border border-gray-300 rounded px-3 py-2">
                                <option value="0.5">0.5 - Aggressive filtering (~60% cost savings)</option>
                                <option value="0.7" selected>0.7 - Balanced filtering (~40% cost savings)</option>
                                <option value="0.8">0.8 - Conservative filtering (~25% cost savings)</option>
                            </select>
                            <p class="text-xs text-gray-500 mt-1">
                                Higher values keep more content but reduce cost savings
                            </p>
                        </div>
                        
                        <div class="bg-blue-50 p-3 rounded">
                            <h4 class="text-sm font-medium text-blue-900 mb-2">How it works:</h4>
                            <ul class="text-xs text-blue-800 space-y-1">
                                <li>‚Ä¢ Analyzes content chunks for huntability</li>
                                <li>‚Ä¢ Removes acknowledgments, marketing content</li>
                                <li>‚Ä¢ Keeps technical details, commands, IOCs</li>
                                <li>‚Ä¢ Typically saves 20-40% on costs</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="flex justify-end space-x-3 mt-6">
                        <button id="cancelBtn" class="px-4 py-2 text-gray-600 hover:text-gray-800">
                            Cancel
                        </button>
                        <button id="confirmBtn" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
                            Analyze
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Handle checkbox change
            const useFilteringCheckbox = modal.querySelector('#useFiltering');
            const confidenceSection = modal.querySelector('#confidenceSection');
            
            useFilteringCheckbox.addEventListener('change', (e) => {
                confidenceSection.style.display = e.target.checked ? 'block' : 'none';
            });
            
            // Handle button clicks
            modal.querySelector('#cancelBtn').addEventListener('click', () => {
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                resolve(null);
            });
            
            modal.querySelector('#confirmBtn').addEventListener('click', () => {
                const useFiltering = useFilteringCheckbox.checked;
                const minConfidence = parseFloat(modal.querySelector('#minConfidence').value);
                
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                resolve({
                    useFiltering,
                    minConfidence
                });
            });
            
            // Handle escape key
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    if (modal && modal.parentNode) {
                        modal.remove();
                    }
                    document.removeEventListener('keydown', handleEscape);
                    resolve(null);
                }
            };
            document.addEventListener('keydown', handleEscape);
        });
    }
    // Show removed chunks dialog for debugging
    function showRemovedChunksDialog(debugInfo) {
        const modal = document.createElement('div');
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        
        const chunksHtml = debugInfo.removed_chunks.map((chunk, index) => `
            <div class="mb-4 p-3 bg-red-50 border border-red-200 rounded">
                <div class="flex justify-between items-center mb-2">
                    <h4 class="text-sm font-medium text-red-900">Chunk ${chunk.chunk_id}</h4>
                    <span class="text-xs text-red-600">${chunk.text.length} chars</span>
                </div>
                <div class="text-xs text-red-800 bg-white p-2 rounded border max-h-32 overflow-y-auto">
                    ${chunk.text.replace(/\n/g, '<br>')}
                </div>
                <div class="text-xs text-red-600 mt-1">
                    Reason: ${chunk.reason || 'Not huntable'} | Confidence: ${chunk.confidence && !isNaN(chunk.confidence) ? chunk.confidence.toFixed(2) : 'N/A'}
                </div>
            </div>
        `).join('');
        
        modal.innerHTML = `
            <div class="bg-white rounded-lg p-6 max-w-4xl w-full mx-4 max-h-[80vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold text-gray-900">üóëÔ∏è Removed Content Chunks</h3>
                    <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded">
                    <div class="text-sm text-blue-800">
                        <strong>Summary:</strong> ${debugInfo.chunks_removed} chunks removed 
                        (${debugInfo.reduction_percent}% content reduction)
                        <br>
                        <strong>Original:</strong> ${debugInfo.original_length.toLocaleString()} chars ‚Üí 
                        <strong>Filtered:</strong> ${debugInfo.filtered_length.toLocaleString()} chars
                    </div>
                </div>
                
                <div class="space-y-2">
                    ${chunksHtml}
                </div>
                
                <div class="mt-6 flex justify-end">
                    <button onclick="this.closest('.fixed').remove()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Handle escape key
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);
    }
    
    function showCustomPromptModal() {
        closeAIAssistantModal();
        
        // Get AI model from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const aiModel = settings.aiModel || 'chatgpt';
        const modelDisplayName = aiModel === 'chatgpt' ? 'ChatGPT (OpenAI)' : 
                                aiModel === 'anthropic' ? 'Claude (Anthropic)' : 
                                aiModel === 'tinyllama' ? 'TinyLlama (Local Ollama)' : 
                                aiModel === 'lmstudio' ? 'LMStudio (Local)' : 'Llama (Local Ollama)';
        
        const modal = document.createElement('div');
        modal.id = 'customPromptModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeCustomPromptModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeCustomPromptModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-2xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gray-900">üí¨ Custom AI Prompt</h3>
                    <div class="flex items-center space-x-2">
                        <button onclick="showCustomHelp()" class="text-blue-500 hover:text-blue-700 text-sm px-2 py-1 rounded border border-blue-300 hover:bg-blue-50">
                            <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            Help
                        </button>
                        <button onclick="closeCustomPromptModal()" class="text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="mb-4 p-3 bg-gray-50 border border-gray-200 rounded-md">
                    <div class="text-sm text-gray-700">
                        <p class="font-medium mb-1">ü§ñ AI Model:</p>
                        <p class="text-gray-600">${modelDisplayName}</p>
                    </div>
                </div>
                
                <div class="mb-4">
                    <label for="customPrompt" class="block text-sm font-medium text-gray-700 mb-2">
                        Your Question or Request
                    </label>
                    <textarea id="customPrompt" 
                              rows="4" 
                              class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                              placeholder="Ask anything about this article. For example:&#10;- What are the main attack vectors mentioned?&#10;- How would I detect this threat in my network?&#10;- What are the key IOCs to monitor?&#10;- Explain the technical details in simple terms"></textarea>
                </div>
                
                <div class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
                    <div class="text-sm text-blue-800">
                        <p class="font-medium mb-1">üí° Tips:</p>
                        <ul class="list-disc list-inside space-y-1">
                            <li>Be specific about what you want to know</li>
                            <li>Ask for technical details, IOCs, or analysis</li>
                            <li>Request detection rules or threat hunting queries</li>
                            <li>Ask for explanations in different detail levels</li>
                        </ul>
                    </div>
                </div>
                
                <div class="flex justify-between">
                    <button onclick="showCustomPromptHistory()" 
                            class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                        <span class="mr-2">üìö</span>
                        View Previous Prompts
                    </button>
                    <div class="flex space-x-3">
                        <button onclick="closeCustomPromptModal()" 
                                class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                            Cancel
                        </button>
                        <button onclick="generateCustomPrompt()" 
                                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-purple-600 hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                            <span class="mr-2">ü§ñ</span>
                            Generate Response
                        </button>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        // Add Cmd/Ctrl+Enter key handler to textarea
        const textarea = document.getElementById('customPrompt');
        if (textarea) {
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                    e.preventDefault();
                    generateCustomPrompt();
                }
            });
            // Focus the textarea
            textarea.focus();
        }
    }
    
    function closeCustomPromptModal() {
        const modal = document.getElementById('customPromptModal');
        if (modal) {
            modal.remove();
        }
    }
    
    async function generateCustomPrompt() {
        const customPrompt = document.getElementById('customPrompt').value.trim();
        
        if (!customPrompt) {
            showNotification('Please enter a question or request', 'error');
            return;
        }
        
        closeCustomPromptModal();
        
        // Get AI model from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const aiModel = settings.aiModel || 'chatgpt';
        
        // Only set API key for cloud models that require it
        let apiKey = null;
        if (aiModel === 'anthropic') {
            apiKey = settings.anthropicApiKey;
        } else if (aiModel === 'chatgpt') {
            apiKey = settings.openaiApiKey;
        }
        // For local models like lmstudio, apiKey remains null
        
        if ((aiModel === 'chatgpt' || aiModel === 'anthropic') && !apiKey) {
            const keyType = aiModel === 'anthropic' ? 'Anthropic' : 'OpenAI';
            showNotification(`Please configure your ${keyType} API key in Settings first`, 'error');
            return;
        }
        
        // Show loading modal
        const loadingModal = document.createElement('div');
        loadingModal.id = 'loadingModal';
        loadingModal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Track if request has started
        let requestStarted = false;
        
        // Add ESC key handler to close loading modal
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('loadingModal');
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleEsc);
                
                // Only show background message if request actually started
                if (requestStarted) {
                    showNotification('Custom prompt generation continues in the background. You can return to this article later to view the results.', 'info');
                }
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        loadingModal.innerHTML = `
            <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-purple-100">
                        <svg class="animate-spin h-6 w-6 text-purple-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <h3 class="text-lg font-medium text-gray-900 mt-4">ü§ñ Processing Custom Request...</h3>
                    <p class="text-sm text-gray-500 mt-2">This may take a few moments.</p>
                    <p class="text-xs text-gray-400 mt-3">üí° Press <kbd class="px-1 py-0.5 bg-gray-200 rounded text-xs">ESC</kbd> to leave while generation continues</p>
                </div>
            </div>
        `;
        document.body.appendChild(loadingModal);
        
        try {
            // Create a timeout promise - longer for LLM operations
            const timeoutPromise = new Promise((_, reject) => {
                const timeoutMs = aiModel === 'chatgpt' ? 180000 : 600000; // 180s for ChatGPT, 600s for LLM
                setTimeout(() => reject(new Error(`Request timed out after ${timeoutMs/1000} seconds`)), timeoutMs);
            });
            
            // Build request body conditionally
            const customPromptBody = {
                prompt: customPrompt,
                ai_model: aiModel
            };
            
            // Only include API key if it's provided (for cloud models)
            if (apiKey) {
                customPromptBody.api_key = apiKey;
            }
            
            // Create the fetch promise
            const fetchPromise = fetch(`/api/articles/{{ article.id }}/custom-prompt`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(customPromptBody)
            });
            
            // Mark request as started
            requestStarted = true;
            
            // Race between fetch and timeout
            const response = await Promise.race([fetchPromise, timeoutPromise]);
            
            if (response.ok) {
                const data = await response.json();
                showCustomResponseModal(data.response, customPrompt, data);
            } else {
                const error = await response.json();
                showNotification(`Custom prompt failed: ${error.detail}`, 'error');
            }
        } catch (error) {
            if (error.message.includes('timed out')) {
                const timeoutMsg = aiModel === 'chatgpt' ? '60 seconds' : '200 seconds';
                showNotification(`Custom prompt timed out after ${timeoutMsg}. Try using a different model or check your settings.`, 'error');
            } else {
                showNotification(`Error: ${error.message}`, 'error');
            }
        } finally {
            // Remove loading modal and clean up ESC handler
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.parentNode) {
                loadingModal.remove();
            }
            // Clean up the ESC key handler
            document.removeEventListener('keydown', handleEsc);
        }
    }
    
    function showCustomResponseModal(response, originalPrompt, data = null) {
        const modal = document.createElement('div');
        modal.id = 'customResponseModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeCustomResponseModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeCustomResponseModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        const modelUsed = data?.ai_model || data?.model_name || 'Unknown';
        const respondedAt = data?.responded_at ? new Date(data.responded_at).toLocaleString() : 'Unknown';
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gray-900">üí¨ Custom AI Response</h3>
                    <button onclick="closeCustomResponseModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-4 p-3 bg-gray-50 rounded-md">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                        <div>
                            <span class="font-medium text-gray-700">Your Question:</span>
                            <p class="text-gray-900 mt-1">${originalPrompt}</p>
                        </div>
                        <div>
                            <span class="font-medium text-gray-700">Model Used:</span>
                            <span class="text-gray-900">${modelUsed}</span>
                        </div>
                        <div>
                            <span class="font-medium text-gray-700">Responded At:</span>
                            <span class="text-gray-900">${respondedAt}</span>
                        </div>
                    </div>
                </div>
                
                <div class="bg-gray-50 rounded-lg p-4 max-h-96 overflow-y-auto">
                    <div class="prose max-w-none">
                        <pre class="whitespace-pre-wrap text-sm text-gray-800 font-mono">${response}</pre>
                    </div>
                </div>
                
                <div class="mt-4 flex justify-end space-x-3">
                    <button onclick="showCustomPromptModal()" 
                            class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-purple-600 hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                        <span class="mr-2">üí¨</span>
                        Ask a new question
                    </button>
                    <button onclick="closeCustomResponseModal()" 
                            class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }
    
    function closeCustomResponseModal() {
        const modal = document.getElementById('customResponseModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function showCustomPromptHistory() {
        closeCustomPromptModal();
        
        const modal = document.createElement('div');
        modal.id = 'customPromptHistoryModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeCustomPromptHistoryModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeCustomPromptHistoryModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        // Get stored custom prompts from article metadata
        const customPrompts = {{ article.article_metadata.get('custom_prompts', []) | tojson }};
        console.log('Custom prompts data:', customPrompts);
        console.log('Custom prompts length:', customPrompts ? customPrompts.length : 'null');
        
        let historyContent = '';
        if (customPrompts && customPrompts.length > 0) {
            console.log('Processing custom prompts...');
            historyContent = customPrompts.map((prompt, index) => {
                const respondedAt = new Date(prompt.responded_at).toLocaleString();
                const responsePreview = prompt.response.substring(0, 200) + (prompt.response.length > 200 ? '...' : '');
                
                return `
                    <div class="border border-gray-200 rounded-lg p-4 mb-4 bg-white">
                        <div class="flex justify-between items-start mb-3">
                            <div class="flex-1">
                                <h4 class="font-semibold text-gray-900 mb-2">${prompt.prompt}</h4>
                                <div class="text-sm text-gray-600 mb-2">
                                    <span class="font-medium">Model:</span> ${prompt.model_name || prompt.model_used || 'Unknown'} ‚Ä¢ 
                                    <span class="font-medium">Date:</span> ${respondedAt}
                                </div>
                            </div>
                            <button onclick="showFullPromptResponse(${index})" 
                                    class="ml-4 px-3 py-1 text-sm bg-purple-100 text-purple-700 rounded hover:bg-purple-200 transition-colors">
                                View Full
                            </button>
                        </div>
                        <div class="bg-gray-50 rounded p-3">
                            <div class="text-sm text-gray-700 font-mono whitespace-pre-wrap">${responsePreview}</div>
                        </div>
                    </div>
                `;
            }).join('');
            console.log('Generated history content:', historyContent);
        } else {
            console.log('No custom prompts found, showing empty state');
            historyContent = `
                <div class="text-center py-8 text-gray-500">
                    <div class="text-4xl mb-4">üìù</div>
                    <p class="text-lg font-medium mb-2">No Previous Prompts</p>
                    <p class="text-sm">You haven't asked any custom questions about this article yet.</p>
                </div>
            `;
        }
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-6">
                    <h3 class="text-xl font-bold text-gray-900">üìö Custom Prompt History</h3>
                    <div class="flex space-x-3">
                        <button onclick="showCustomPromptModal()" 
                                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-purple-600 hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                            <span class="mr-2">üí¨</span>
                            Ask New Question
                        </button>
                        <button onclick="closeCustomPromptHistoryModal()" class="text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="max-h-96 overflow-y-auto">
                    ${historyContent}
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }
    
    function closeCustomPromptHistoryModal() {
        const modal = document.getElementById('customPromptHistoryModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function showFullPromptResponse(index) {
        const customPrompts = {{ article.article_metadata.get('custom_prompts', []) | tojson }};
        if (!customPrompts || !customPrompts[index]) {
            showNotification('Prompt not found', 'error');
            return;
        }
        
        const prompt = customPrompts[index];
        closeCustomPromptHistoryModal();
        showCustomResponseModal(prompt.response, prompt.prompt, {
            model_name: prompt.model_name || prompt.model_used,
            responded_at: prompt.responded_at
        });
    }
    
    // Store generated rules globally for easy access
    let currentGeneratedSigmaRules = [];
    
    function showSigmaRulesModal(sigmaRules, data) {
        // Remove any existing modal
        closeSigmaRulesModal();
        
        // Store generated rules globally
        if (sigmaRules && Array.isArray(sigmaRules)) {
            currentGeneratedSigmaRules = sigmaRules;
        } else if (data && data.rules && Array.isArray(data.rules)) {
            currentGeneratedSigmaRules = data.rules;
        }
        
        const modal = document.createElement('div');
        modal.id = 'sigmaRulesModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeSigmaRulesModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeSigmaRulesModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        const modelUsed = data?.ai_model || data?.model_name || data?.metadata?.ai_model || data?.metadata?.model_name || 'gpt-4';
        const generatedAt = data?.generated_at || data?.metadata?.generated_at ? new Date(data.generated_at || data.metadata.generated_at).toLocaleString() : 'Unknown';
        const temperature = data?.temperature || data?.metadata?.temperature || '0.2';
        const validationResults = data?.validation_results || data?.metadata?.validation_results || [];
        const failureError = data?.error || null;
        const hasFailure = (sigmaRules === null || sigmaRules === 'null') && failureError;
        
        // Convert sigmaRules to string if it's an object
        let sigmaRulesText = sigmaRules;
        if (typeof sigmaRules === 'object' && sigmaRules !== null) {
            // If it's an array of rules with content field, extract and format the content
            if (Array.isArray(sigmaRules) && sigmaRules.length > 0 && sigmaRules[0].content) {
                sigmaRulesText = sigmaRules.map((rule, index) => {
                    return `--- Rule ${index + 1} ---\n${rule.content.replace(/\\n/g, '\n')}`;
                }).join('\n\n');
            } else {
                sigmaRulesText = JSON.stringify(sigmaRules, null, 2);
            }
        }
        
        // Build error banner if there was a failure
        let errorBannerHtml = '';
        if (hasFailure) {
            errorBannerHtml = `
                <div class="mb-4 p-4 bg-red-50 border-2 border-red-300 rounded-lg">
                    <div class="flex items-start">
                        <span class="text-2xl mr-3">‚ö†Ô∏è</span>
                        <div class="flex-1">
                            <h4 class="font-bold text-red-900 mb-2">SIGMA Generation Failed</h4>
                            <p class="text-sm text-red-800 mb-2">${failureError}</p>
                            <p class="text-xs text-red-700">The conversation log below shows what was attempted before the failure. Click "Regenerate" to try again.</p>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Build validation status display
        let validationStatusHtml = '';
        if (validationResults.length > 0) {
            validationStatusHtml = '<div class="mb-4 p-3 bg-gray-50 rounded-lg">';
            validationStatusHtml += '<h4 class="font-medium text-gray-900 mb-2">üîç Validation Results</h4>';
            
            validationResults.forEach((result, index) => {
                const statusIcon = result.is_valid ? '‚úÖ' : '‚ùå';
                const statusColor = result.is_valid ? 'text-green-600' : 'text-red-600';
                const statusText = result.is_valid ? 'Valid' : 'Invalid';
                const ruleIndex = result.rule_index !== undefined ? result.rule_index : (index + 1);
                
                validationStatusHtml += `<div class="mb-2 p-2 border rounded ${result.is_valid ? 'border-green-200 bg-green-50' : 'border-red-200 bg-red-50'}">`;
                validationStatusHtml += `<div class="flex items-center mb-1">`;
                validationStatusHtml += `<span class="mr-2">${statusIcon}</span>`;
                validationStatusHtml += `<span class="font-medium ${statusColor}">Rule ${ruleIndex}: ${statusText}</span>`;
                validationStatusHtml += `</div>`;
                
                if (result.errors && result.errors.length > 0) {
                    validationStatusHtml += `<div class="text-sm text-red-600 mb-1">`;
                    validationStatusHtml += `<strong>Errors:</strong><ul class="list-disc list-inside ml-2">`;
                    result.errors.forEach(error => {
                        const escapedError = String(error).replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                        validationStatusHtml += `<li>${escapedError}</li>`;
                    });
                    validationStatusHtml += `</ul></div>`;
                }
                
                if (result.warnings && result.warnings.length > 0) {
                    validationStatusHtml += `<div class="text-sm text-yellow-600 mb-1">`;
                    validationStatusHtml += `<strong>Warnings:</strong><ul class="list-disc list-inside ml-2">`;
                    result.warnings.forEach(warning => {
                        const escapedWarning = String(warning).replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                        validationStatusHtml += `<li>${escapedWarning}</li>`;
                    });
                    validationStatusHtml += `</ul></div>`;
                }
                
                if (result.rule_info) {
                    validationStatusHtml += `<div class="text-sm text-gray-600">`;
                    validationStatusHtml += `<strong>Rule Info:</strong> ${result.rule_info.title || 'Untitled'} `;
                    if (result.rule_info.level) {
                        validationStatusHtml += `(${result.rule_info.level})`;
                    }
                    validationStatusHtml += `</div>`;
                }
                
                validationStatusHtml += `</div>`;
            });
            
            validationStatusHtml += '</div>';
        }
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-6xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium text-gray-900">üîç SIGMA Detection Rules</h3>
                    <div class="flex items-center space-x-2">
                        <button onclick="showSigmaHelp()" class="text-blue-500 hover:text-blue-700 text-sm px-2 py-1 rounded border border-blue-300 hover:bg-blue-50">
                            <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            Help
                        </button>
                        <button onclick="closeSigmaRulesModal()" class="text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="mb-4 text-sm text-gray-600">
                    <span class="font-medium">Generated by:</span> ${modelUsed} | 
                    <span class="font-medium">Generated at:</span> ${generatedAt} |
                    <span class="font-medium">Temperature:</span> ${temperature}
                    ${data?.cached ? ' | <span class="font-medium text-blue-600">(Cached)</span>' : ''}
                </div>
                
                ${data?.optimization ? `
                <div class="mb-4 p-3 bg-green-50 border border-green-200 rounded-md">
                    <div class="flex items-center mb-2">
                        <span class="text-green-600 font-medium">üöÄ Content Optimization Applied</span>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-2 text-xs">
                        ${modelUsed.includes('gpt') || modelUsed.includes('chatgpt') ? `
                        <div>
                            <span class="font-medium text-gray-700">Cost Savings:</span>
                            <span class="text-green-600 font-medium">$${data.optimization.cost_savings.toFixed(4)}</span>
                        </div>
                        ` : ''}
                        <div>
                            <span class="font-medium text-gray-700">Tokens Saved:</span>
                            <span class="text-green-600 font-medium">${data.optimization.tokens_saved.toLocaleString()}</span>
                        </div>
                        <div>
                            <span class="font-medium text-gray-700">Chunks Removed:</span>
                            <span class="text-green-600 font-medium">${data.optimization.chunks_removed}</span>
                        </div>
                    </div>
                </div>
                ` : ''}
                
                ${errorBannerHtml}
                ${hasFailure ? '' : `
                <div class="mt-4">
                    <h4 class="text-md font-medium text-gray-900 mb-2">üìù SIGMA Rules</h4>
                    <div class="bg-blue-50 p-4 rounded-lg max-h-96 overflow-y-auto">
                        <pre class="text-sm font-mono whitespace-pre-wrap text-gray-800">${sigmaRulesText}</pre>
                    </div>
                </div>
                `}

                ${validationStatusHtml}

                <div class="mt-4">
                    <div class="flex items-center justify-between mb-2">
                        <h4 class="text-md font-medium text-gray-900">üîÑ LLM ‚Üî pySigma Conversation Log</h4>
                        <button id="toggleSigmaConversation" class="text-sm text-blue-600 hover:text-blue-800 px-3 py-1 border border-blue-300 rounded hover:bg-blue-50">
                            Show Log
                        </button>
                    </div>
                    <div class="text-xs text-gray-600 mb-2">Shows the iterative validation process between the LLM and pySigma validator</div>
                    <div id="sigmaConversationContent" style="display: none;">
                        <div id="sigmaConversation" class="space-y-4 max-h-96 overflow-y-auto p-4 bg-gray-50 rounded border">
                            <!-- Filled by script below -->
                        </div>
                    </div>
                </div>
                
                <div class="mt-4 flex justify-between items-center">
                    <div class="flex space-x-2">
                        <button onclick="regenerateSigmaRules()" 
                                class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors">
                            üîÑ Regenerate
                        </button>
                        <button id="checkSimilarRulesBtn" onclick="checkSimilarSigmaRules()" 
                                class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                                title="Search for similar rules in SigmaHQ repository"
                                disabled>
                            üîç Check Similar Rules
                        </button>
                        <button id="embedArticleBtn" onclick="generateArticleEmbedding()" 
                                class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                                title="Generate article embedding for semantic search"
                                disabled>
                            üß¨ Embed Article
                        </button>
                    </div>
                    <button onclick="closeSigmaRulesModal()" 
                            class="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);

        // Check if article has embeddings and enable/disable buttons
        const checkBtn = document.getElementById('checkSimilarRulesBtn');
        const embedBtn = document.getElementById('embedArticleBtn');
        const articleId = {{ article.id }};
        
        // Fetch embedding status from API
        fetch(`/api/articles/${articleId}`)
            .then(response => response.json())
            .then(data => {
                const hasEmbedding = data.embedding && data.embedding.length > 0;
                
                if (checkBtn) {
                    if (hasEmbedding) {
                        checkBtn.disabled = false;
                        checkBtn.title = 'Search for similar rules in SigmaHQ repository';
                    } else {
                        checkBtn.disabled = true;
                        checkBtn.title = 'Article embeddings required. Click "Embed Article" below to generate.';
                    }
                }
                
                if (embedBtn) {
                    if (hasEmbedding) {
                        embedBtn.disabled = true;
                        embedBtn.textContent = '‚úì Embedded';
                        embedBtn.title = 'Article already has embedding';
                    } else {
                        embedBtn.disabled = false;
                        embedBtn.title = 'Generate article embedding for semantic search';
                    }
                }
            })
            .catch(error => {
                console.error('Failed to check embedding status:', error);
                if (checkBtn) {
                    checkBtn.disabled = true;
                    checkBtn.title = 'Unable to verify embedding status';
                }
                if (embedBtn) {
                    embedBtn.disabled = false;
                }
            });

        // Add toggle functionality for conversation log
        const toggleButton = document.getElementById('toggleSigmaConversation');
        const conversationContent = document.getElementById('sigmaConversationContent');
        if (toggleButton && conversationContent) {
            toggleButton.addEventListener('click', function() {
                if (conversationContent.style.display === 'none') {
                    conversationContent.style.display = 'block';
                    toggleButton.textContent = 'Hide Log';
                } else {
                    conversationContent.style.display = 'none';
                    toggleButton.textContent = 'Show Log';
                }
            });
        }
        
        // Render conversation entries if present
        try {
            console.log('DEBUG: data object:', data);
            console.log('DEBUG: data.metadata:', data && data.metadata);
            console.log('DEBUG: data.metadata.conversation:', data && data.metadata && data.metadata.conversation);
            const convo = (data && data.metadata && data.metadata.conversation) ? data.metadata.conversation : []; // Corrected data path
            console.log('DEBUG: convo array:', convo);
            const container = document.getElementById('sigmaConversation');
            if (container) {
                if (!convo.length) {
                    container.innerHTML = '<div class="text-sm text-gray-600 text-center py-4">‚ö†Ô∏è No conversation log available. This might be cached data from an older version.</div>';
                } else {
                    container.innerHTML = convo.map((entry, idx) => {
                        const attempt = entry.attempt || (idx + 1);
                        const attemptBadgeColor = idx === convo.length - 1 ? 'bg-green-500' : 'bg-blue-500';
                        const attemptIcon = idx === convo.length - 1 ? '‚úÖ' : 'üîÑ';
                        
                        // Format the messages (system + user prompts)
                        const messages = entry.messages || [];
                        const messagesHtml = messages.map((msg, msgIdx) => {
                            const role = msg.role || 'user';
                            const content = String(msg.content || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            const roleIcon = role === 'system' ? '‚öôÔ∏è' : 'üë§';
                            const roleColor = role === 'system' ? 'text-purple-700' : 'text-blue-700';
                            const preview = content.substring(0, 200) + (content.length > 200 ? '...' : '');
                            const collapsibleId = 'msg-' + idx + '-' + msgIdx;
                            
                            return '<div class="mb-2">' +
                                '<div class="flex items-center mb-1">' +
                                    '<span class="mr-2">' + roleIcon + '</span>' +
                                    '<span class="font-semibold ' + roleColor + ' text-sm uppercase">' + role + '</span>' +
                                    '<button onclick="toggleCollapse(\'' + collapsibleId + '\')" class="ml-2 text-xs text-blue-600 hover:text-blue-800 underline">' +
                                        '[toggle full content]' +
                                    '</button>' +
                                '</div>' +
                                '<div class="bg-gray-100 p-2 rounded border border-gray-300">' +
                                    '<div id="' + collapsibleId + '-preview" class="text-xs text-gray-700">' + preview + '</div>' +
                                    '<pre id="' + collapsibleId + '-full" class="text-xs whitespace-pre-wrap text-gray-800 hidden">' + content + '</pre>' +
                                '</div>' +
                            '</div>';
                        }).join('');
                        
                        // Format LLM response
                        const llmResponse = entry.llm_response || '';
                        const llmContent = String(llmResponse).replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        const llmPreview = llmContent.substring(0, 200) + (llmContent.length > 200 ? '...' : '');
                        const llmCollapsibleId = 'llm-' + idx;
                        
                        // Format validation results
                        const validation = entry.validation || [];
                        const hasErrors = validation.some(v => !v.is_valid);
                        const validationIcon = hasErrors ? '‚ùå' : '‚úÖ';
                        const validationColor = hasErrors ? 'text-red-700' : 'text-green-700';
                        
                        const validationHtml = validation.map((v, vIdx) => {
                            const errs = (v.errors || []).map(e => '<li class="text-red-700 text-xs">' + String(e).replace(/</g,'&lt;').replace(/>/g,'&gt;') + '</li>').join('');
                            const warns = (v.warnings || []).map(w => '<li class="text-yellow-700 text-xs">' + String(w).replace(/</g,'&lt;').replace(/>/g,'&gt;') + '</li>').join('');
                            const statusBadge = v.is_valid 
                                ? '<span class="px-2 py-1 text-xs bg-green-100 text-green-800 rounded">‚úÖ VALID</span>'
                                : '<span class="px-2 py-1 text-xs bg-red-100 text-red-800 rounded">‚ùå INVALID</span>';
                            const borderClass = v.is_valid ? 'border-green-300' : 'border-red-300';
                            const errsHtml = errs ? '<div class="mt-2"><strong class="text-sm text-red-800">Errors:</strong><ul class="list-disc ml-5 mt-1">' + errs + '</ul></div>' : '';
                            const warnsHtml = warns ? '<div class="mt-2"><strong class="text-sm text-yellow-800">Warnings:</strong><ul class="list-disc ml-5 mt-1">' + warns + '</ul></div>' : '';
                            
                            return '<div class="mb-3 p-3 bg-white border ' + borderClass + ' rounded">' +
                                '<div class="flex items-center justify-between mb-2">' +
                                    '<span class="font-semibold text-sm">Rule #' + (vIdx + 1) + '</span>' +
                                    statusBadge +
                                '</div>' +
                                errsHtml +
                                warnsHtml +
                            '</div>';
                        }).join('');
                        
                        return '<div class="mb-4 p-3 border rounded ' + (hasErrors ? 'bg-red-50 border-red-200' : 'bg-green-50 border-green-200') + '">' +
                            '<div class="flex items-center mb-2">' +
                                '<span class="mr-2">' + attemptIcon + '</span>' +
                                '<span class="font-medium">Attempt ' + attempt + ':</span>' +
                            '</div>' +
                            '<div class="space-y-3">' +
                                '<div class="border-l-4 border-blue-500 pl-3">' +
                                    '<div class="font-semibold text-sm text-gray-700 mb-2">üìù Prompts Sent to LLM</div>' +
                                    messagesHtml +
                                '</div>' +
                                '<div class="border-l-4 border-purple-500 pl-3">' +
                                    '<div class="flex items-center mb-2">' +
                                        '<span class="mr-2">ü§ñ</span>' +
                                        '<span class="font-semibold text-sm text-gray-700">LLM Response</span>' +
                                        '<button onclick="toggleCollapse(\'' + llmCollapsibleId + '\')" class="ml-2 text-xs text-blue-600 hover:text-blue-800 underline">' +
                                            '[toggle full response]' +
                                        '</button>' +
                                    '</div>' +
                                    '<div class="bg-purple-50 p-3 rounded border border-purple-200">' +
                                        '<div id="' + llmCollapsibleId + '-preview" class="text-xs text-gray-700">' + llmPreview + '</div>' +
                                        '<pre id="' + llmCollapsibleId + '-full" class="text-xs whitespace-pre-wrap text-gray-800 hidden">' + llmContent + '</pre>' +
                                    '</div>' +
                                '</div>' +
                                '<div class="border-l-4 ' + (hasErrors ? 'border-red-500' : 'border-green-500') + ' pl-3">' +
                                    '<div class="flex items-center mb-2">' +
                                        '<span class="mr-2">' + validationIcon + '</span>' +
                                        '<span class="font-semibold text-sm ' + validationColor + '">pySigma Validation</span>' +
                                    '</div>' +
                                    '<div class="space-y-2">' +
                                        validationHtml +
                                    '</div>' +
                                '</div>' +
                            '</div>' +
                        '</div>';
                    }).join('');
                }
            }
        } catch (e) {
            console.error('Failed to render sigma conversation', e);
            const container = document.getElementById('sigmaConversation');
            if (container) {
                container.innerHTML = '<div class="text-sm text-red-600">Error rendering conversation log. Check console for details.</div>';
            }
        }
    }
    
    // Helper function to toggle collapsible sections
    function toggleCollapse(id) {
        const preview = document.getElementById(id + '-preview');
        const full = document.getElementById(id + '-full');
        if (preview && full) {
            preview.classList.toggle('hidden');
            full.classList.toggle('hidden');
        }
    }
    
    function closeSigmaRulesModal() {
        const modal = document.getElementById('sigmaRulesModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function showIOCsModal(iocsJson, data) {
        // Remove any existing modal
        closeIOCsModal();
        
        const modal = document.createElement('div');
        modal.id = 'iocsModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeIOCsModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeIOCsModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        const modelUsed = data?.ai_model || data?.model_name || 'gpt-4';
        const extractedAt = data?.extracted_at ? new Date(data.extracted_at).toLocaleString() : 'Unknown';
        
        // Try to parse the JSON for better display
        let iocsData = {};
        let jsonError = null;
        try {
            // If iocsJson is already an array, use it directly
            if (Array.isArray(iocsJson)) {
                iocsData = iocsJson;
            } else {
                // Try to extract JSON from the response if it contains text before JSON
                let jsonText = iocsJson.trim();
                
                // If the response starts with text, try to find JSON within it
                if (!jsonText.startsWith('{') && !jsonText.startsWith('[')) {
                    const jsonMatch = jsonText.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
                    if (jsonMatch) {
                        jsonText = jsonMatch[0];
                    }
                }
                
                iocsData = JSON.parse(jsonText);
            }
        } catch (e) {
            jsonError = e.message;
        }
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-6xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium text-gray-900">üîç Extracted IOCs</h3>
                    <div class="flex items-center space-x-2">
                        <button onclick="showIOCHelp()" class="text-blue-500 hover:text-blue-700 text-sm px-2 py-1 rounded border border-blue-300 hover:bg-blue-50">
                            <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            Help
                        </button>
                        <button onclick="closeIOCsModal()" class="text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="mb-4 text-sm text-gray-600">
                    ${data?.use_llm_validation ? `<span class="font-medium">Generated by:</span> ${modelUsed} (LLM Validated) | ` : ''}
                    <span class="font-medium">Extracted at:</span> ${extractedAt}
                    ${data?.cached ? ' | <span class="font-medium text-blue-600">(Cached)</span>' : ''}
                </div>
                
                ${jsonError ? `
                <div class="bg-red-50 p-4 rounded-lg mb-4">
                    <div class="text-red-800">
                        <strong>JSON Parse Error:</strong> ${jsonError}
                    </div>
                    <div class="mt-2">
                        <strong>Raw Response:</strong>
                        <pre class="text-sm mt-1 bg-gray-100 p-2 rounded overflow-x-auto">${iocsJson}</pre>
                    </div>
                </div>
                ` : `
                <div class="bg-gray-50 p-4 rounded-lg max-h-96 overflow-y-auto">
                    ${Array.isArray(iocsData) ? `
                    <div class="space-y-3">
                        <div class="text-sm text-gray-600 mb-2">
                            <strong>Total IOCs found:</strong> ${iocsData.length}
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            ${iocsData.map(ioc => `
                            <div class="bg-white p-3 rounded border">
                                <div class="flex justify-between items-start mb-2">
                                    <span class="inline-block px-2 py-1 text-xs font-medium bg-blue-100 text-blue-800 rounded capitalize">${ioc.type}</span>
                                    <span class="text-xs text-gray-500">${(ioc.confidence * 100).toFixed(0)}%</span>
                                </div>
                                <div class="font-mono text-sm text-gray-900 break-all">${ioc.value}</div>
                                ${ioc.context ? `<div class="text-xs text-gray-600 mt-1 italic">${ioc.context.substring(0, 100)}${ioc.context.length > 100 ? '...' : ''}</div>` : ''}
                            </div>
                            `).join('')}
                        </div>
                    </div>
                    ` : `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        ${Object.entries(iocsData).map(([category, items]) => `
                        <div class="bg-white p-3 rounded border">
                            <h4 class="font-medium text-gray-900 mb-2 capitalize">${category.replace(/_/g, ' ')}</h4>
                            ${items && items.length > 0 ? `
                            <ul class="text-sm text-gray-700 space-y-1">
                                ${items.map(item => `<li class="font-mono text-xs bg-gray-50 px-2 py-1 rounded">${item}</li>`).join('')}
                            </ul>
                            ` : '<p class="text-gray-500 text-sm">No items found</p>'}
                        </div>
                        `).join('')}
                    </div>
                    `}
                </div>
                `}
                
                ${(data?.llm_prompt || data?.metadata?.prompt) ? `
                <div class="mt-6 border-t pt-4">
                    <div class="flex items-center justify-between mb-2">
                        <h4 class="font-medium text-gray-900">LLM Prompt & Response</h4>
                        <button id="toggleIocLlmLog" class="text-sm text-blue-600 hover:text-blue-800 px-3 py-1 border border-blue-300 rounded hover:bg-blue-50">
                            Show Log
                        </button>
                    </div>
                    <div id="iocLlmLogContent" style="display: none;">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="bg-blue-50 p-3 rounded border border-blue-200">
                                <h5 class="font-medium text-blue-900 mb-2">Prompt</h5>
                                <pre class="text-xs text-blue-800 bg-white p-2 rounded overflow-x-auto max-h-64">${(data.llm_prompt || data.metadata.prompt).substring(0, 1000)}...</pre>
                            </div>
                            <div class="bg-green-50 p-3 rounded border border-green-200">
                                <h5 class="font-medium text-green-900 mb-2">Response</h5>
                                <pre class="text-xs text-green-800 bg-white p-2 rounded overflow-x-auto max-h-64">${(data.llm_response || data.metadata.response)?.substring(0, 1000)}...</pre>
                            </div>
                        </div>
                    </div>
                </div>
                ` : ''}
                
                <div class="mt-4 flex justify-between items-center">
                    <div class="flex items-center space-x-4">
                        <label class="flex items-center">
                            <input type="checkbox" id="llmValidationToggle" class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50" ${data?.use_llm_validation ? 'checked' : ''}>
                            <span class="ml-2 text-sm text-gray-700">Use LLM Validation</span>
                            <div class="relative group ml-1">
                                <svg class="w-4 h-4 text-gray-400 hover:text-gray-600 cursor-help" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                                <div class="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 text-white text-xs rounded-lg opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-50" style="width: 280px; white-space: normal;">
                                    <div>
                                        <strong>LLM Validation:</strong> Uses AI to validate and categorize IOCs, removing false positives and improving accuracy. Requires API key.
                                    </div>
                                    <div class="absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-gray-900"></div>
                                </div>
                            </div>
                        </label>
                        <button onclick="regenerateIOCs()" 
                                class="px-4 py-2 bg-orange-600 text-white rounded-md hover:bg-orange-700 transition-colors">
                            üîÑ Regenerate
                        </button>
                    </div>
                    <button onclick="closeIOCsModal()" 
                            class="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Add toggle functionality for IOC LLM log
        const iocLlmToggleButton = document.getElementById('toggleIocLlmLog');
        const iocLlmLogContent = document.getElementById('iocLlmLogContent');
        if (iocLlmToggleButton && iocLlmLogContent) {
            iocLlmToggleButton.addEventListener('click', function() {
                if (iocLlmLogContent.style.display === 'none') {
                    iocLlmLogContent.style.display = 'block';
                    iocLlmToggleButton.textContent = 'Hide Log';
                } else {
                    iocLlmLogContent.style.display = 'none';
                    iocLlmToggleButton.textContent = 'Show Log';
                }
            });
        }
    }
    
    function closeIOCsModal() {
        const modal = document.getElementById('iocsModal');
        if (modal) {
            modal.remove();
        }
    }
    function showGPT4oRankingModal(analysis, data) {
        // Remove any existing modal
        closeGPT4oRankingModal();
        
        const modal = document.createElement('div');
        modal.id = 'gpt4oRankingModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeGPT4oRankingModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeGPT4oRankingModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        // Format the analysis for display
        const formattedAnalysis = analysis.replace(/\n/g, '<br>');
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-6xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium text-gray-900">üìä ${data && (data.ai_model || data.model_name || data.model) ? (() => {
                        const model = data.ai_model || data.model_name || data.model;
                        if (model.includes('claude')) return 'CLAUDE';
                        if (model.includes('gpt')) return 'GPT-4O';
                        return model.toUpperCase();
                    })() : 'LLM'} SIGMA Huntability Analysis</h3>
                    <div class="flex items-center space-x-2">
                        <button onclick="showRankingHelp()" class="text-blue-500 hover:text-blue-700 text-sm px-2 py-1 rounded border border-blue-300 hover:bg-blue-50">
                            <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            Help
                        </button>
                        <button onclick="closeGPT4oRankingModal()" class="text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="mb-4">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <div class="text-sm text-blue-800 whitespace-pre-wrap">${formattedAnalysis}</div>
                    </div>
                </div>
                
                ${data ? `
                <div class="mt-4 text-xs text-gray-500">
                    <div class="flex justify-between">
                        <span>Generated: ${data.analyzed_at ? new Date(data.analyzed_at).toLocaleString() : 'Unknown'}</span>
                        <span>Model: ${data.ai_model || data.model_name || data.model || 'gpt-4o'}</span>
                    </div>
                </div>
                ` : ''}
                
                <div class="mt-6 flex justify-between">
                    <button onclick="regenerateGPT4oRanking()" 
                            class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
                        üîÑ Regenerate Analysis
                    </button>
                    <button onclick="closeGPT4oRankingModal()" 
                            class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
    }
    
    function closeGPT4oRankingModal() {
        const modal = document.getElementById('gpt4oRankingModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function regenerateSigmaRules() {
        // Close current modal
        closeSigmaRulesModal();
        
        // Call generateAIAnalysis with force regeneration
        generateAIAnalysis('sigma', true);
    }
    
    async function checkSimilarSigmaRules() {
        // Get the currently displayed Sigma rules
        const sigmaRulesModal = document.getElementById('sigmaRulesModal');
        
        // Get the generated rules from multiple sources
        let generatedRules = currentGeneratedSigmaRules; // Try global variable first
        
        // Try to get from modal data attribute
        if (generatedRules.length === 0 && sigmaRulesModal) {
            try {
                const modalRules = sigmaRulesModal.dataset.generatedRules;
                if (modalRules) {
                    generatedRules = JSON.parse(modalRules);
                }
            } catch (e) {
                console.warn('Could not parse modal data', e);
            }
        }
        
        // If not found, fetch from article metadata
        if (generatedRules.length === 0) {
            const articleId = {{ article.id }};
            try {
                const articleResponse = await fetch(`/api/articles/${articleId}`);
                if (articleResponse.ok) {
                    const articleData = await articleResponse.json();
                    if (articleData.article_metadata?.sigma_rules?.rules) {
                        generatedRules = articleData.article_metadata.sigma_rules.rules;
                        currentGeneratedSigmaRules = generatedRules; // Store globally
                    }
                }
            } catch (e) {
                console.warn('Could not fetch article metadata', e);
            }
        }
        
        if (generatedRules.length === 0) {
            showNotification('No generated SIGMA rules found. Please generate rules first.', 'error');
            return;
        }
        
        const articleId = {{ article.id }};
        
        // Show loading indicator
        showNotification('Searching for similar rules in SigmaHQ repository...', 'info');
        
        try {
            // Fetch similar rules from the API
            const response = await fetch(`/api/articles/${articleId}/sigma-matches`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.success) {
                showSimilarRulesModal(data.matches, data.coverage_summary, generatedRules);
            } else {
                showNotification('Failed to find similar rules', 'error');
            }
        } catch (error) {
            console.error('Error checking similar rules:', error);
            showNotification('Error checking similar rules: ' + error.message, 'error');
        }
    }
    
    async function generateArticleEmbedding() {
        const articleId = {{ article.id }};
        
        // Disable button during generation
        const embedBtn = document.getElementById('embedArticleBtn');
        if (embedBtn) {
            embedBtn.disabled = true;
            embedBtn.textContent = '‚è≥ Generating...';
        }
        
        showNotification('Generating article embedding...', 'info');
        
        try {
            const response = await fetch(`/api/articles/${articleId}/embed`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.status === 'task_submitted' || data.status === 'already_embedded') {
                showNotification('‚úì Article embedding generated successfully!', 'success');
                
                // Re-enable Check Similar Rules button
                const checkBtn = document.getElementById('checkSimilarRulesBtn');
                if (checkBtn) {
                    checkBtn.disabled = false;
                }
                
                // Keep embed button disabled (already embedded)
                if (embedBtn) {
                    embedBtn.disabled = true;
                    embedBtn.textContent = '‚úì Embedded';
                }
            } else {
                throw new Error(data.error || data.message || 'Failed to generate embedding');
            }
        } catch (error) {
            console.error('Error generating embedding:', error);
            showNotification('Error: ' + error.message, 'error');
            
            if (embedBtn) {
                embedBtn.disabled = false;
                embedBtn.textContent = 'üß¨ Embed Article';
            }
        }
    }
    
    function showSimilarRulesModal(matches, coverageSummary, generatedRules = []) {
        // Remove any existing modal
        closeSimilarRulesModal();
        
        const modal = document.createElement('div');
        modal.id = 'similarRulesModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeSimilarRulesModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeSimilarRulesModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        // Build coverage summary HTML
        let coverageHtml = '';
        if (coverageSummary && coverageSummary.total > 0) {
            const coveredPercent = ((coverageSummary.covered / coverageSummary.total) * 100).toFixed(1);
            const extendPercent = ((coverageSummary.extend / coverageSummary.total) * 100).toFixed(1);
            const newPercent = ((coverageSummary.new / coverageSummary.total) * 100).toFixed(1);
            
            coverageHtml = `
                <div class="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-md">
                    <h4 class="text-sm font-medium text-blue-900 mb-2">üìä Coverage Summary</h4>
                    <div class="grid grid-cols-3 gap-2 text-sm">
                        <div class="text-center p-2 bg-green-100 rounded">
                            <div class="font-bold text-green-700">${coverageSummary.covered}</div>
                            <div class="text-xs text-green-600">Covered (${coveredPercent}%)</div>
                        </div>
                        <div class="text-center p-2 bg-yellow-100 rounded">
                            <div class="font-bold text-yellow-700">${coverageSummary.extend}</div>
                            <div class="text-xs text-yellow-600">Extend (${extendPercent}%)</div>
                        </div>
                        <div class="text-center p-2 bg-purple-100 rounded">
                            <div class="font-bold text-purple-700">${coverageSummary.new}</div>
                            <div class="text-xs text-purple-600">New (${newPercent}%)</div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Build matches HTML
        let matchesHtml = '';
        if (!matches || matches.length === 0) {
            matchesHtml = `
                <div class="text-center py-8 text-gray-500">
                    <svg class="w-16 h-16 mx-auto mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <p>No similar rules found in SigmaHQ repository</p>
                    <p class="text-sm mt-2">This may indicate a novel detection opportunity!</p>
                </div>
            `;
        } else {
            // Get parsed data from first generated rule
            let newRuleLogsource = null;
            let newRuleDetection = null;
            if (generatedRules.length > 0) {
                const firstRule = generatedRules[0];
                
                // Check if already parsed (should have direct logsource/detection fields)
                if (firstRule.logsource || firstRule.detection) {
                    newRuleLogsource = firstRule.logsource;
                    newRuleDetection = firstRule.detection;
                } else if (firstRule.content) {
                    // Parse YAML content using regex (simple parser for logsource and detection blocks)
                    try {
                        const content = firstRule.content;
                        
                        // Backend should provide parsed fields, but if not available, log warning
                        console.warn('Generated rule missing parsed logsource/detection fields. Backend should provide these.', firstRule);
                        // Set to null - will show N/A in UI
                        newRuleLogsource = null;
                        newRuleDetection = null;
                    } catch (e) {
                        console.warn('Could not parse generated rule YAML:', e);
                    }
                }
            }
            
            matchesHtml = matches.map((match, index) => {
                const similarityPercent = (match.similarity_score * 100).toFixed(1);
                const coverageStatus = match.coverage_status || 'unknown';
                const statusColor = coverageStatus === 'covered' ? 'green' : 
                                   coverageStatus === 'extend' ? 'yellow' : 'purple';
                const statusIcon = coverageStatus === 'covered' ? '‚úì' : 
                                  coverageStatus === 'extend' ? '‚ö°' : '‚ú®';
                // Escape rule_id for JavaScript
                const escapedRuleId = match.rule_id ? match.rule_id.replace(/'/g, "\\'") : '';
                // Escape logsource and detection for safe JSON display (escape HTML entities, keep JSON quotes)
                const logsourceJson = match.logsource ? JSON.stringify(match.logsource, null, 2).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : 'N/A';
                const detectionJson = match.detection ? JSON.stringify(match.detection, null, 2).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : 'N/A';
                // Escape new rule logsource and detection
                const newRuleLogsourceJson = newRuleLogsource ? JSON.stringify(newRuleLogsource, null, 2).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : 'N/A';
                const newRuleDetectionJson = newRuleDetection ? JSON.stringify(newRuleDetection, null, 2).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : 'N/A';
                
                return `
                    <div class="border border-gray-200 rounded-lg p-4 hover:bg-gray-50 transition-colors cursor-pointer" 
                         onclick="showFullSigmaRule('${escapedRuleId}')"
                         title="Click to view full rule details">
                        <div class="flex items-start justify-between">
                            <div class="flex-1">
                                <h5 class="font-medium text-gray-900">${match.title || 'Untitled Rule'}</h5>
                                <p class="text-sm text-gray-600 mt-1">${match.description || 'No description'}</p>
                            </div>
                            <div class="ml-4 flex flex-col items-end">
                                <div class="text-2xl font-bold text-${statusColor}-600">${similarityPercent}%</div>
                                <div class="text-xs text-${statusColor}-600 bg-${statusColor}-100 px-2 py-1 rounded mt-1">
                                    ${statusIcon} ${coverageStatus.toUpperCase()}
                                </div>
                            </div>
                        </div>
                        
                        <div class="mt-3 grid grid-cols-2 gap-2 text-xs">
                            <div><span class="font-medium">Rule ID:</span> <code class="text-xs bg-gray-100 px-1 rounded">${match.rule_id || 'N/A'}</code></div>
                            <div><span class="font-medium">Level:</span> <span class="px-2 py-0.5 rounded text-xs ${
                                match.level === 'critical' ? 'bg-red-100 text-red-700' :
                                match.level === 'high' ? 'bg-orange-100 text-orange-700' :
                                match.level === 'medium' ? 'bg-yellow-100 text-yellow-700' :
                                'bg-blue-100 text-blue-700'
                            }">${match.level || 'N/A'}</span></div>
                            <div><span class="font-medium">Status:</span> ${match.status || 'N/A'}</div>
                            <div><span class="font-medium">Match Type:</span> ${match.match_level || 'article'}</div>
                        </div>
                        
                        ${match.tags && match.tags.length > 0 ? `
                            <div class="mt-2">
                                <div class="text-xs font-medium text-gray-700">Tags:</div>
                                <div class="flex flex-wrap gap-1 mt-1">
                                    ${match.tags.slice(0, 5).map(tag => 
                                        `<span class="text-xs px-2 py-0.5 bg-indigo-100 text-indigo-700 rounded">${tag}</span>`
                                    ).join('')}
                                    ${match.tags.length > 5 ? `<span class="text-xs text-gray-500">+${match.tags.length - 5} more</span>` : ''}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${match.matched_discriminators && match.matched_discriminators.length > 0 ? `
                            <div class="mt-2">
                                <div class="text-xs font-medium text-gray-700">Matched Behaviors:</div>
                                <div class="flex flex-wrap gap-1 mt-1">
                                    ${match.matched_discriminators.slice(0, 5).map(d => 
                                        `<span class="text-xs px-2 py-1 bg-blue-100 text-blue-700 rounded">${d}</span>`
                                    ).join('')}
                                    ${match.matched_discriminators.length > 5 ? `<span class="text-xs text-gray-500">+${match.matched_discriminators.length - 5} more</span>` : ''}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${match.coverage_reasoning ? `
                            <div class="mt-2 p-2 bg-gray-50 rounded text-xs text-gray-600 italic">
                                üí° ${match.coverage_reasoning}
                            </div>
                        ` : ''}
                        
                        ${(match.logsource || match.detection || (generatedRules.length > 0 && (generatedRules[0].logsource || generatedRules[0].detection))) ? `
                            <div class="mt-3 border-t border-gray-200 pt-3">
                                <button onclick="event.stopPropagation(); toggleRuleDetails('rule-details-${index}', 'toggle-icon-${index}')" 
                                        class="text-xs text-blue-600 hover:text-blue-800 font-medium flex items-center">
                                    <svg id="toggle-icon-${index}" class="w-4 h-4 mr-1 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                    </svg>
                                    <span>Show Logsource & Detection Comparison</span>
                                </button>
                                <div id="rule-details-${index}" class="hidden mt-2">
                                    ${generatedRules.length > 0 ? `
                                        <div class="mb-4 p-2 bg-yellow-50 border border-yellow-200 rounded">
                                            <h6 class="text-xs font-bold text-yellow-900 mb-1">üìù New Rule: ${generatedRules[0].title || 'Untitled'}</h6>
                                        </div>
                                    ` : ''}
                                    <div class="space-y-4">
                                        <!-- Logsource Comparison -->
                                        <div>
                                            <h6 class="text-xs font-bold text-gray-700 mb-2">üìã Logsource Comparison</h6>
                                            <div class="grid grid-cols-2 gap-4">
                                                <div class="border border-gray-200 rounded p-2 bg-yellow-50">
                                                    <h6 class="text-xs font-bold text-yellow-900 mb-2">New Rule</h6>
                                                    <pre class="text-xs bg-white p-2 rounded border border-gray-200 overflow-x-auto whitespace-pre-wrap font-mono max-h-48">${newRuleLogsourceJson}</pre>
                                                </div>
                                                <div class="border border-gray-200 rounded p-2 bg-blue-50">
                                                    <h6 class="text-xs font-bold text-blue-900 mb-2">Similar Rule</h6>
                                                    <pre class="text-xs bg-white p-2 rounded border border-gray-200 overflow-x-auto whitespace-pre-wrap font-mono max-h-48">${logsourceJson}</pre>
                                                </div>
                                            </div>
                                        </div>
                                        <!-- Detection Comparison -->
                                        <div>
                                            <h6 class="text-xs font-bold text-gray-700 mb-2">üîç Detection Comparison</h6>
                                            <div class="grid grid-cols-2 gap-4">
                                                <div class="border border-gray-200 rounded p-2 bg-yellow-50">
                                                    <h6 class="text-xs font-bold text-yellow-900 mb-2">New Rule</h6>
                                                    <pre class="text-xs bg-white p-2 rounded border border-gray-200 overflow-x-auto whitespace-pre-wrap font-mono max-h-64">${newRuleDetectionJson}</pre>
                                                </div>
                                                <div class="border border-gray-200 rounded p-2 bg-green-50">
                                                    <h6 class="text-xs font-bold text-green-900 mb-2">Similar Rule</h6>
                                                    <pre class="text-xs bg-white p-2 rounded border border-gray-200 overflow-x-auto whitespace-pre-wrap font-mono max-h-64">${detectionJson}</pre>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ` : ''}
                        
                        <div class="mt-2 text-xs text-gray-500">
                            üìÅ ${match.file_path || 'N/A'} | <span class="text-blue-600 font-medium">üîç View full rule ‚Üí</span>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-6xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium text-gray-900">üîç Similar Rules in SigmaHQ Repository</h3>
                    <button onclick="closeSimilarRulesModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-4 text-sm text-gray-600">
                    Found ${matches ? matches.length : 0} most similar rules (sorted by similarity)
                </div>
                
                ${coverageHtml}
                
                <div class="space-y-3 max-h-96 overflow-y-auto">
                    ${matchesHtml}
                </div>
                
                <div class="mt-6 flex justify-end">
                    <button onclick="closeSimilarRulesModal()" 
                            class="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
    }
    
    function closeSimilarRulesModal() {
        const modal = document.getElementById('similarRulesModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function toggleRuleDetails(detailsId, iconId) {
        const detailsDiv = document.getElementById(detailsId);
        const iconSvg = document.getElementById(iconId);
        const button = iconSvg ? iconSvg.closest('button') : null;
        
        if (!detailsDiv || !iconSvg) {
            return;
        }
        
        const isHidden = detailsDiv.classList.contains('hidden');
        
        if (isHidden) {
            detailsDiv.classList.remove('hidden');
            iconSvg.style.transform = 'rotate(180deg)';
            if (button) {
                const span = button.querySelector('span');
                if (span) span.textContent = 'Hide Logsource & Detection Comparison';
            }
        } else {
            detailsDiv.classList.add('hidden');
            iconSvg.style.transform = 'rotate(0deg)';
            if (button) {
                const span = button.querySelector('span');
                if (span) span.textContent = 'Show Logsource & Detection Comparison';
            }
        }
    }
    
    async function showFullSigmaRule(ruleId) {
        // Show loading indicator
        showNotification('Loading rule details...', 'info');
        
        try {
            // Fetch the full rule details
            const response = await fetch(`/api/articles/sigma-rules/${ruleId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.success && data.rule) {
                displaySigmaRuleDetails(data.rule);
            } else {
                showNotification('Failed to load rule details', 'error');
            }
        } catch (error) {
            console.error('Error fetching sigma rule:', error);
            showNotification('Error loading rule details: ' + error.message, 'error');
        }
    }
    
    function displaySigmaRuleDetails(rule) {
        // Remove any existing modal
        closeSigmaRuleDetailsModal();
        
        const modal = document.createElement('div');
        modal.id = 'sigmaRuleDetailsModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeSigmaRuleDetailsModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeSigmaRuleDetailsModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        // Format detection logic
        const detectionHtml = rule.detection ? `
            <div class="mb-4">
                <h4 class="text-sm font-medium text-gray-900 mb-2">Detection Logic:</h4>
                <pre class="bg-gray-50 p-3 rounded text-xs overflow-x-auto border border-gray-200">
${JSON.stringify(rule.detection, null, 2)}
                </pre>
            </div>
        ` : '';
        
        // Format logsource
        const logsourceHtml = rule.logsource ? `
            <div class="mb-4">
                <h4 class="text-sm font-medium text-gray-900 mb-2">Log Source:</h4>
                <pre class="bg-gray-50 p-3 rounded text-xs overflow-x-auto border border-gray-200">
${JSON.stringify(rule.logsource, null, 2)}
                </pre>
            </div>
        ` : '';
        
        // Format tags
        const tagsHtml = rule.tags && rule.tags.length > 0 ? `
            <div class="mb-4">
                <h4 class="text-sm font-medium text-gray-900 mb-2">Tags:</h4>
                <div class="flex flex-wrap gap-2">
                    ${rule.tags.map(tag => 
                        `<span class="px-3 py-1 bg-indigo-100 text-indigo-700 rounded text-sm">${tag}</span>`
                    ).join('')}
                </div>
            </div>
        ` : '';
        
        // Format false positives
        const falsePositivesHtml = rule.false_positives && rule.false_positives.length > 0 ? `
            <div class="mb-4">
                <h4 class="text-sm font-medium text-gray-900 mb-2">False Positives:</h4>
                <ul class="list-disc list-inside text-sm text-gray-700">
                    ${rule.false_positives.map(fp => `<li>${fp}</li>`).join('')}
                </ul>
            </div>
        ` : '';
        
        // Format references
        const referencesHtml = rule.rule_references && rule.rule_references.length > 0 ? `
            <div class="mb-4">
                <h4 class="text-sm font-medium text-gray-900 mb-2">References:</h4>
                <ul class="list-disc list-inside text-sm text-gray-700">
                    ${rule.rule_references.map(ref => `<li>${ref}</li>`).join('')}
                </ul>
            </div>
        ` : '';
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-6xl shadow-lg rounded-md bg-white max-h-[90vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-4 sticky top-0 bg-white border-b pb-4">
                    <div>
                        <h3 class="text-lg font-medium text-gray-900">üîç Sigma Rule Details</h3>
                        <p class="text-sm text-gray-600 mt-1">${rule.rule_id}</p>
                    </div>
                    <button onclick="closeSigmaRuleDetailsModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="space-y-4">
                    <!-- Title and Description -->
                    <div>
                        <h4 class="text-xl font-bold text-gray-900 mb-2">${rule.title || 'Untitled Rule'}</h4>
                        <p class="text-sm text-gray-700">${rule.description || 'No description available'}</p>
                    </div>
                    
                    <!-- Metadata Grid -->
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                        ${rule.level ? `
                            <div>
                                <div class="text-xs text-gray-500 uppercase">Level</div>
                                <div class="text-sm font-medium ${
                                    rule.level === 'critical' ? 'text-red-700' :
                                    rule.level === 'high' ? 'text-orange-700' :
                                    rule.level === 'medium' ? 'text-yellow-700' :
                                    'text-blue-700'
                                }">${rule.level}</div>
                            </div>
                        ` : ''}
                        
                        ${rule.status ? `
                            <div>
                                <div class="text-xs text-gray-500 uppercase">Status</div>
                                <div class="text-sm font-medium">${rule.status}</div>
                            </div>
                        ` : ''}
                        
                        ${rule.author ? `
                            <div>
                                <div class="text-xs text-gray-500 uppercase">Author</div>
                                <div class="text-sm font-medium">${rule.author}</div>
                            </div>
                        ` : ''}
                        
                        ${rule.date ? `
                            <div>
                                <div class="text-xs text-gray-500 uppercase">Date</div>
                                <div class="text-sm font-medium">${new Date(rule.date).toLocaleDateString()}</div>
                            </div>
                        ` : ''}
                    </div>
                    
                    ${logsourceHtml}
                    ${detectionHtml}
                    ${tagsHtml}
                    ${falsePositivesHtml}
                    ${referencesHtml}
                    
                    <!-- File Path -->
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <div class="text-xs text-gray-500">
                            <strong>File Path:</strong> ${rule.file_path || 'N/A'}
                        </div>
                        ${rule.repo_commit_sha ? `
                            <div class="text-xs text-gray-500 mt-1">
                                <strong>Commit:</strong> <code class="bg-gray-100 px-1 rounded">${rule.repo_commit_sha}</code>
                            </div>
                        ` : ''}
                    </div>
                </div>
                
                <div class="mt-6 flex justify-end">
                    <button onclick="closeSigmaRuleDetailsModal()" 
                            class="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
    }
    
    function closeSigmaRuleDetailsModal() {
        const modal = document.getElementById('sigmaRuleDetailsModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function regenerateIOCs() {
        // Get LLM validation setting from checkbox
        const llmValidationToggle = document.getElementById('llmValidationToggle');
        const useLLMValidation = llmValidationToggle ? llmValidationToggle.checked : false;
        
        // Close current modal
        closeIOCsModal();
        
        // Call generateAIAnalysis with force regeneration and LLM validation setting
        generateAIAnalysis('iocs', true, useLLMValidation);
    }
    
    function regenerateGPT4oRanking() {
        // Close current modal
        closeGPT4oRankingModal();
        
        // Call generateAIAnalysis with force regeneration
        generateAIAnalysis('ranking', true);
    }
    
    // Text annotation system now handled by LayeredTextManager
    
    // Delete article function
    function deleteArticle(articleId) {
        if (confirm('Are you sure you want to delete this article? This action cannot be undone and will also delete all annotations for this article.')) {
            fetch(`/api/articles/${articleId}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Article deleted successfully!');
                    // Redirect to articles page
                    window.location.href = '/articles';
                } else {
                    alert('Failed to delete article: ' + (data.message || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Failed to delete article: ' + error.message);
            });
        }
    }
    
    // Check for pending completion notifications from other pages
    function checkPendingCompletions() {
        const pendingCompletions = JSON.parse(localStorage.getItem('pendingCompletions') || '[]');
        
        pendingCompletions.forEach(completion => {
            // Show completion banner
            showCompletionBanner(completion.type, completion.typeText, completion.typeIcon, completion.articleId, completion.articleTitle);
        });
        
        // Clear pending completions after showing them
        localStorage.removeItem('pendingCompletions');
    }
    // Handle URL fragments to auto-open results
    console.log('Setting up URL fragment handler...');
    
    function processUrlHash() {
        console.log('Processing URL hash...');
        
        const hash = window.location.hash.substring(1); // Remove the #
        console.log('URL hash:', hash);
        
        if (hash === 'sigma') {
            console.log('Processing sigma hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasSigmaRules = {{ 'true' if article.article_metadata and article.article_metadata.get('sigma_rules') else 'false' }};
                console.log('Has sigma rules (template):', hasSigmaRules);
                
                if (hasSigmaRules) {
                    const sigmaData = {{ article.article_metadata.get('sigma_rules') | tojson if article.article_metadata and article.article_metadata.get('sigma_rules') else 'null' }};
                    console.log('Sigma data (template):', sigmaData);
                    
                    // Parse conversation log if it's a string
                    if (sigmaData && sigmaData.metadata && sigmaData.metadata.conversation && typeof sigmaData.metadata.conversation === 'string') {
                        try {
                            sigmaData.metadata.conversation = JSON.parse(sigmaData.metadata.conversation);
                        } catch (e) {
                            console.error('Failed to parse conversation log:', e);
                            sigmaData.metadata.conversation = [];
                        }
                    }
                    
                    if (sigmaData) {
                        console.log('Auto-opening SIGMA modal from URL fragment (template)');
                        setTimeout(() => showSigmaRulesModal(sigmaData.rules, sigmaData), 500);
                    }
                } else {
                    console.log('No SIGMA rules found in template data');
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching SIGMA data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for SIGMA:', data);
                        if (data.article_metadata && data.article_metadata.sigma_rules) {
                            // Parse conversation log if it's a string
                            if (data.article_metadata.sigma_rules.metadata && data.article_metadata.sigma_rules.metadata.conversation && typeof data.article_metadata.sigma_rules.metadata.conversation === 'string') {
                                try {
                                    data.article_metadata.sigma_rules.metadata.conversation = JSON.parse(data.article_metadata.sigma_rules.metadata.conversation);
                                } catch (e) {
                                    console.error('Failed to parse conversation log:', e);
                                    data.article_metadata.sigma_rules.metadata.conversation = [];
                                }
                            }
                            console.log('Auto-opening SIGMA modal from URL fragment (API)');
                            setTimeout(() => showSigmaRulesModal(data.article_metadata.sigma_rules.rules, data.article_metadata.sigma_rules), 500);
                        } else {
                            console.log('No SIGMA rules found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for sigma:', error);
                    });
            }
        } else if (hash === 'iocs') {
            console.log('Processing iocs hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasIOCs = {{ 'true' if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'false' }};
                console.log('Has iocs (template):', hasIOCs);
                
                if (hasIOCs) {
                    const iocData = {{ article.article_metadata.get('extracted_iocs') | tojson if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'null' }};
                    console.log('IOCs data (template):', iocData);
                    
                    if (iocData) {
                        console.log('Auto-opening IOCs modal from URL fragment (template)');
                        setTimeout(() => showIOCsModal(JSON.stringify(iocData.iocs, null, 2), iocData), 500);
                    }
                } else {
                    console.log('No IOCs found in template data');
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching IOCs data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for IOCs:', data);
                        if (data.article_metadata && data.article_metadata.extracted_iocs) {
                            console.log('Auto-opening IOCs modal from URL fragment (API)');
                            setTimeout(() => showIOCsModal(JSON.stringify(data.article_metadata.extracted_iocs.iocs, null, 2), data.article_metadata.extracted_iocs), 500);
                        } else {
                            console.log('No IOCs found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for IOCs:', error);
                    });
            }
        } else if (hash === 'ranking') {
            console.log('Processing ranking hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasRanking = {{ 'true' if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'false' }};
                console.log('Has ranking (template):', hasRanking);
                
                if (hasRanking) {
                    const rankingData = {{ article.article_metadata.get('gpt4o_ranking') | tojson if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'null' }};
                    console.log('Ranking data (template):', rankingData);
                    
                    if (rankingData && rankingData.analysis) {
                        console.log('Auto-opening GPT4o ranking from URL fragment (template)');
                        setTimeout(() => {
                            showGPT4oRankingModal(rankingData.analysis, rankingData);
                        }, 500);
                    }
                } else {
                    console.log('No ranking found in template data');
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching ranking data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for ranking:', data);
                        if (data.article_metadata && data.article_metadata.gpt4o_ranking && data.article_metadata.gpt4o_ranking.analysis) {
                            console.log('Auto-opening GPT4o ranking from URL fragment (API)');
                            setTimeout(() => {
                                showGPT4oRankingModal(data.article_metadata.gpt4o_ranking.analysis, data.article_metadata.gpt4o_ranking);
                            }, 500);
                        } else {
                            console.log('No ranking found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for ranking:', error);
                    });
            }
        }
        
        // Clear the hash from URL after handling (with delay to allow modal to open)
        if (hash) {
            console.log('Clearing URL hash:', hash);
            setTimeout(() => {
                window.history.replaceState(null, null, window.location.pathname);
            }, 1000);
        }
    }
    
    // Set up event listeners for URL hash changes
    window.addEventListener('load', function() {
        console.log('Page loaded, checking URL fragments...');
        checkPendingCompletions();
        processUrlHash();
    });
    
    window.addEventListener('hashchange', function() {
        console.log('URL hash changed');
        processUrlHash();
    });

    // Handle URL fragments to auto-open results
    console.log('Setting up URL fragment handler...');
    window.addEventListener('load', function() {
        console.log('Page loaded, checking URL fragments...');
        
        // Check for pending completions first
        checkPendingCompletions();
        
        const hash = window.location.hash.substring(1); // Remove the #
        console.log('URL hash:', hash);
        
        if (hash === 'sigma') {
            console.log('Processing sigma hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasSigma = {{ 'true' if article.article_metadata and article.article_metadata.get('sigma_rules') else 'false' }};
                console.log('Has sigma (template):', hasSigma);
                
                if (hasSigma) {
                    const sigmaData = {{ article.article_metadata.get('sigma_rules') | tojson if article.article_metadata and article.article_metadata.get('sigma_rules') else 'null' }};
                    console.log('Sigma data (template):', sigmaData);
                    
                    // Parse conversation log if it's a string
                    if (sigmaData && sigmaData.metadata && sigmaData.metadata.conversation && typeof sigmaData.metadata.conversation === 'string') {
                        try {
                            sigmaData.metadata.conversation = JSON.parse(sigmaData.metadata.conversation);
                        } catch (e) {
                            console.error('Failed to parse conversation log:', e);
                            sigmaData.metadata.conversation = [];
                        }
                    }
                    
                    if (sigmaData) {
                        console.log('Auto-opening sigma modal from URL fragment (template)');
                        setTimeout(() => showSigmaRulesModal(sigmaData.rules, sigmaData), 500);
                    }
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching sigma data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for sigma:', data);
                        if (data.metadata && data.metadata.sigma_rules) {
                            // Parse conversation log if it's a string
                            if (data.metadata.sigma_rules.metadata && data.metadata.sigma_rules.metadata.conversation && typeof data.metadata.sigma_rules.metadata.conversation === 'string') {
                                try {
                                    data.metadata.sigma_rules.metadata.conversation = JSON.parse(data.metadata.sigma_rules.metadata.conversation);
                                } catch (e) {
                                    console.error('Failed to parse conversation log:', e);
                                    data.metadata.sigma_rules.metadata.conversation = [];
                                }
                            }
                            console.log('Auto-opening sigma modal from URL fragment (API)');
                            setTimeout(() => showSigmaRulesModal(data.metadata.sigma_rules.rules, data.metadata.sigma_rules), 500);
                        } else {
                            console.log('No sigma data found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for sigma:', error);
                    });
            }
        } else if (hash === 'iocs') {
            console.log('Processing iocs hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasIOCs = {{ 'true' if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'false' }};
                console.log('Has iocs (template):', hasIOCs);
                
                if (hasIOCs) {
                    const iocData = {{ article.article_metadata.get('extracted_iocs') | tojson if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'null' }};
                    console.log('IOCs data (template):', iocData);
                    
                    if (iocData) {
                        console.log('Auto-opening IOCs modal from URL fragment (template)');
                        setTimeout(() => showIOCsModal(JSON.stringify(iocData.iocs, null, 2), iocData), 500);
                    }
                } else {
                    console.log('No IOCs found in template data');
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching IOCs data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for IOCs:', data);
                        if (data.article_metadata && data.article_metadata.extracted_iocs) {
                            console.log('Auto-opening IOCs modal from URL fragment (API)');
                            setTimeout(() => showIOCsModal(JSON.stringify(data.article_metadata.extracted_iocs.iocs, null, 2), data.article_metadata.extracted_iocs), 500);
                        } else {
                            console.log('No IOCs found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for IOCs:', error);
                    });
            }
        } else if (hash === 'ranking') {
            console.log('Processing ranking hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasRanking = {{ 'true' if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'false' }};
                console.log('Has ranking (template):', hasRanking);
                
                if (hasRanking) {
                    const rankingData = {{ article.article_metadata.get('gpt4o_ranking') | tojson if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'null' }};
                    console.log('Ranking data (template):', rankingData);
                    
                    if (rankingData && rankingData.analysis) {
                        console.log('Auto-opening GPT4o ranking from URL fragment (template)');
                        setTimeout(() => {
                            showGPT4oRankingModal(rankingData.analysis, rankingData);
                        }, 500);
                    }
                } else {
                    console.log('No ranking found in template data');
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching ranking data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for ranking:', data);
                        if (data.article_metadata && data.article_metadata.gpt4o_ranking && data.article_metadata.gpt4o_ranking.analysis) {
                            console.log('Auto-opening GPT4o ranking from URL fragment (API)');
                            setTimeout(() => {
                                showGPT4oRankingModal(data.article_metadata.gpt4o_ranking.analysis, data.article_metadata.gpt4o_ranking);
                            }, 500);
                        } else {
                            console.log('No ranking found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for ranking:', error);
                    });
            }
        }
        
        // Clear the hash from URL after handling (with delay to allow modal to open)
        if (hash) {
            console.log('Clearing URL hash:', hash);
            setTimeout(() => {
                window.history.replaceState(null, null, window.location.pathname);
            }, 1000);
        }
    });
    
    // Chunk Debug Modal Functions
    async function showChunkDebugModal() {
        closeAIAssistantModal();
        
        // Show loading modal
        const loadingModal = document.createElement('div');
        loadingModal.id = 'chunkDebugLoadingModal';
        loadingModal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        loadingModal.innerHTML = `
            <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-blue-100">
                        <svg class="animate-spin h-6 w-6 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <h3 class="text-lg font-medium text-gray-900 mt-4">Analyzing Chunks</h3>
                    <p class="text-sm text-gray-500 mt-2">Processing article content and analyzing chunking decisions...</p>
                </div>
            </div>
        `;
        document.body.appendChild(loadingModal);
        
        // Add ESC key handler to close loading modal
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('chunkDebugLoadingModal');
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleEsc);
                showNotification('Chunk debug analysis cancelled', 'info');
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        try {
            // Create a timeout promise - shorter for faster response
            const chunkDebugTimeoutMs = 180000;
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Request timed out after 180 seconds')), chunkDebugTimeoutMs);
            });
            
            // Create the fetch promise
            const fetchPromise = (async () => {
                const currentThreshold = window.chunkDebugThreshold || 0.7;
                const response = await fetch(`/api/articles/{{ article.id }}/chunk-debug?chunk_size=1000&overlap=200&min_confidence=${currentThreshold}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            })();
            
            // Race between fetch and timeout
            const debugData = await Promise.race([fetchPromise, timeoutPromise]);
            
            // Remove loading modal
            if (loadingModal && loadingModal.parentNode) {
                loadingModal.remove();
            }
            
            // Clean up ESC handler
            document.removeEventListener('keydown', handleEsc);
            
            // Show chunk debug modal
            showChunkDebugResults(debugData);
            
        } catch (error) {
            console.error('Chunk debug error:', error);
            if (loadingModal && loadingModal.parentNode) {
                loadingModal.remove();
            }
            document.removeEventListener('keydown', handleEsc);
            
            if (error.message.includes('timed out')) {
                showNotification('Chunk debug analysis timed out after 180 seconds. Showing partial results.', 'warning');
            } else {
                showNotification('Failed to load chunk debug data: ' + error.message, 'error');
            }
        }
    }
    function generateProcessingSummary(summary) {
        if (!summary) {
            return '';
        }
        
        const {
            processed_chunks = 0,
            total_chunks = 0,
            chunk_limit_applied = false,
            concurrency_limit = 1,
            per_chunk_timeout_seconds = 0,
            full_analysis = false,
            remaining_chunks = null
        } = summary;
        const timeoutSeconds = Number(per_chunk_timeout_seconds || 0);
        const remaining = remaining_chunks !== null ? remaining_chunks : Math.max(total_chunks - processed_chunks, 0);
        const showFinishButton = chunk_limit_applied && !full_analysis;
        
        const statusClass = chunk_limit_applied 
            ? 'bg-yellow-100 border-yellow-200 text-yellow-800' 
            : 'bg-green-100 border-green-200 text-green-800';
        const statusLabel = chunk_limit_applied ? '‚ö†Ô∏è Partial Analysis' : '‚úÖ Full Analysis';
        const details = chunk_limit_applied
            ? `Processed ${processed_chunks} of ${total_chunks} chunks (${remaining} remaining).`
            : `Processed all ${processed_chunks} chunks.`;
        
        const buttonHtml = showFinishButton ? `
            <div class="mt-3">
                <button id="chunkFinishAnalysisButton"
                        onclick="runFullChunkAnalysis()"
                        class="inline-flex items-center gap-2 px-4 py-2 bg-blue-600 text-white text-xs font-semibold rounded hover:bg-blue-700 transition-colors">
                    <span class="finish-text">Finish Full Analysis</span>
                    <svg class="finish-spinner hidden animate-spin h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </button>
            </div>
        ` : '';
        
        return `
            <div class="mb-6 p-4 ${statusClass} rounded-lg border">
                <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-2">
                    <div>
                        <div class="text-sm font-semibold">${statusLabel}</div>
                        <div class="text-xs mt-1">${details}</div>
                        ${buttonHtml}
                    </div>
                    <div class="text-xs text-gray-700 md:text-right">
                        <div>Concurrency: ${concurrency_limit}</div>
                        <div>Chunk timeout: ${timeoutSeconds.toFixed(1)}s</div>
                    </div>
                </div>
            </div>
        `;
    }
    
    async function runFullChunkAnalysis() {
        if (!window.chunkDebugData || window.chunkDebugFullAnalysisInProgress) {
            return;
        }
        
        window.chunkDebugFullAnalysisInProgress = true;
        
        const button = document.getElementById('chunkFinishAnalysisButton');
        const spinner = button ? button.querySelector('.finish-spinner') : null;
        const text = button ? button.querySelector('.finish-text') : null;
        if (button) {
            button.disabled = true;
            if (spinner) {
                spinner.classList.remove('hidden');
            }
            if (text) {
                text.textContent = 'Analyzing...';
            }
        }
        
        try {
            const articleId = window.chunkDebugData.article_id;
            const chunkSize = window.chunkDebugData.chunk_size || 1000;
            const overlap = window.chunkDebugData.overlap || 200;
            const currentThreshold = window.chunkDebugThreshold || window.chunkDebugData.min_confidence || 0.7;
            
            showNotification('Completing full chunk analysis...', 'info');
            
            const params = new URLSearchParams({
                chunk_size: String(chunkSize),
                overlap: String(overlap),
                min_confidence: String(currentThreshold),
                full_analysis: 'true'
            });
            
            const response = await fetch(`/api/articles/${articleId}/chunk-debug?${params.toString()}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const debugData = await response.json();
            updateChunkDebugResults(debugData);
            
            showNotification('Full chunk analysis completed successfully.', 'success');
        } catch (error) {
            console.error('Full chunk analysis error:', error);
            showNotification('Failed to complete full analysis: ' + error.message, 'error');
        } finally {
            if (button) {
                button.disabled = false;
                if (spinner) {
                    spinner.classList.add('hidden');
                }
                if (text) {
                    text.textContent = 'Finish Full Analysis';
                }
            }
            window.chunkDebugFullAnalysisInProgress = false;
        }
    }
    
    function showChunkDebugResults(data) {
        // Create modal
        const modal = document.createElement('div');
        modal.id = 'chunkDebugModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeChunkDebugModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeChunkDebugModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        // Generate chunk visualization
        const chunkVisualization = generateChunkVisualization(data);
        
        modal.innerHTML = `
            <div class="relative top-4 mx-auto p-6 border w-11/12 max-w-7xl shadow-lg rounded-md bg-white max-h-[90vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-6">
                    <h3 class="text-2xl font-bold text-gray-900">üîç Chunk ML Feedback</h3>
                    <button onclick="closeChunkDebugModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <!-- Threshold Selector -->
                <div class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                    <div class="flex items-center justify-between">
                        <div>
                            <h4 class="text-lg font-semibold text-blue-900 mb-2">üéØ ML Confidence Threshold</h4>
                            <p class="text-sm text-blue-700">Adjust the minimum ML model confidence required to keep chunks for the LLM</p>
                        </div>
                        <div class="flex items-center space-x-4">
                            <label for="thresholdSlider" class="text-sm font-medium text-blue-900">Threshold:</label>
                            <input type="range" id="thresholdSlider" min="0" max="2" step="1" value="1" 
                                   class="w-32 h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer"
                                   onchange="updateThresholdFromSlider(this.value)">
                            <span id="thresholdValue" class="text-lg font-bold text-blue-900">0.7</span>
                        </div>
                    </div>
                    <div class="mt-3 grid grid-cols-3 gap-2 text-xs">
                        <div class="text-center p-2 bg-white rounded border">
                            <div class="font-semibold text-green-600">0.5 (Aggressive)</div>
                            <div class="text-gray-600">Keeps more chunks</div>
                        </div>
                        <div class="text-center p-2 bg-white rounded border">
                            <div class="font-semibold text-blue-600">0.7 (Balanced)</div>
                            <div class="text-gray-600">Current setting</div>
                        </div>
                        <div class="text-center p-2 bg-white rounded border">
                            <div class="font-semibold text-red-600">0.8 (Conservative)</div>
                            <div class="text-gray-600">Removes more chunks</div>
                        </div>
                    </div>
                </div>

                <!-- Statistics Overview -->
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <div id="totalChunksCount" class="text-2xl font-bold text-blue-600">${data.total_chunks}</div>
                        <div class="text-sm text-blue-800">Total Chunks</div>
                    </div>
                    <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                        <div id="keptChunksCount" class="text-2xl font-bold text-green-600">${data.kept_chunks}</div>
                        <div class="text-sm text-green-800">Kept for LLM</div>
                    </div>
                    <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                        <div id="removedChunksCount" class="text-2xl font-bold text-red-600">${data.removed_chunks}</div>
                        <div class="text-sm text-red-800">Filtered Out</div>
                    </div>
                    <div class="bg-purple-50 border border-purple-200 rounded-lg p-4">
                        <div id="contentReductionPercent" class="text-2xl font-bold text-purple-600">${data.filtering_stats.reduction_percent.toFixed(1)}%</div>
                        <div class="text-sm text-purple-800">Content Reduction</div>
                    </div>
                </div>
                
                <div id="chunkProcessingSummary">
                    ${generateProcessingSummary(data.processing_summary)}
                </div>
                
                <!-- ML Accuracy Statistics -->
                <div class="bg-indigo-50 border border-indigo-200 rounded-lg p-4 mb-6">
                    <h4 class="text-lg font-semibold text-indigo-900 mb-3">ü§ñ ML Model Performance</h4>
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                        <div>
                            <div class="text-sm text-indigo-600">ML Predictions</div>
                            <div class="text-lg font-semibold">${data.ml_stats.total_predictions}</div>
                        </div>
               <div>
                   <div class="text-sm text-indigo-600">Matching Predictions</div>
                   <div class="text-lg font-semibold text-green-600">${data.ml_stats.correct_predictions}</div>
               </div>
                        <div>
                            <div class="text-sm text-indigo-600">Accuracy</div>
                            <div class="text-lg font-semibold ${data.ml_stats.accuracy_percent >= 80 ? 'text-green-600' : data.ml_stats.accuracy_percent >= 60 ? 'text-yellow-600' : 'text-red-600'}">${data.ml_stats.accuracy_percent.toFixed(1)}%</div>
                        </div>
                        <div>
                            <div class="text-sm text-indigo-600">Mismatches</div>
                            <div class="text-lg font-semibold text-yellow-600">${data.ml_stats.mismatches}</div>
                        </div>
                    </div>
                </div>
                
                <!-- Cost Analysis -->
                <div class="bg-gray-50 border border-gray-200 rounded-lg p-4 mb-6">
                    <div class="flex items-center justify-between mb-3">
                        <h4 class="text-lg font-semibold text-gray-900">üí∞ Cost Analysis</h4>
                        <div class="relative group">
                            <button class="text-gray-400 hover:text-gray-600 focus:outline-none" onclick="showCostAnalysisHelp()">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"></path>
                                </svg>
                            </button>
                            <div id="costAnalysisTooltip" class="absolute right-0 top-8 w-64 p-3 bg-gray-800 text-white text-sm rounded-lg shadow-lg opacity-0 invisible transition-all duration-200 z-50">
                                <div class="absolute -top-1 right-4 w-2 h-2 bg-gray-800 transform rotate-45"></div>
                                These estimates are based on OpenAI API call costs and are not literal when using Local LLM. They represent potential savings if using OpenAI's GPT-4o service.
                            </div>
                        </div>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div>
                            <div class="text-sm text-gray-600">Original Content</div>
                            <div id="originalContentLength" class="text-lg font-semibold">${data.content_length.toLocaleString()} chars</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Estimated Cost Savings per Article</div>
                            <div id="costSavings" class="text-lg font-semibold text-green-600">$${data.filtering_stats.cost_savings.toFixed(4)}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Tokens Saved</div>
                            <div id="tokensSaved" class="text-lg font-semibold text-blue-600">${data.filtering_stats.tokens_saved.toLocaleString()}</div>
                        </div>
                    </div>
                </div>
                
                <!-- Chunk Visualization -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-gray-900 mb-3">üìä Chunk Visualization</h4>
                    <div class="bg-white border border-gray-200 rounded-lg p-4">
                        <div id="chunkVisualizationContainer">
                            ${chunkVisualization}
                        </div>
                    </div>
                </div>
                
                <!-- Filter Controls -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-gray-900 mb-3">üéõÔ∏è Filter Controls</h4>
                    <div class="flex flex-wrap gap-4">
                        <button onclick="filterChunks('all')" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors">
                            Show All Chunks
                        </button>
                        <button onclick="filterChunks('kept')" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors">
                            Show Kept Only
                        </button>
                        <button onclick="filterChunks('removed')" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors">
                            Show Removed Only
                        </button>
                        <button onclick="filterChunks('threat')" class="px-4 py-2 bg-orange-600 text-white rounded-md hover:bg-orange-700 transition-colors">
                            Show Threat Keywords
                        </button>
                        <button onclick="filterChunks('perfect')" class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition-colors">
                            Show Perfect Discriminators
                        </button>
                        <button onclick="filterChunks('ml')" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors">
                            Show ML Predictions
                        </button>
                        <button onclick="filterChunks('confidenceBand')" class="px-4 py-2 bg-teal-600 text-white rounded-md hover:bg-teal-700 transition-colors" title="Show chunks with confidence between 40% and 60%">
                            Show 40-60% Confidence
                        </button>
                        <button onclick="filterChunks('mismatch')" class="px-4 py-2 bg-yellow-600 text-white rounded-md hover:bg-yellow-700 transition-colors" title="Show chunks where ML prediction differs from actual decision">
                            Show ML Mismatches
                        </button>
                    </div>
                </div>
                
                <!-- Chunk Details -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-gray-900 mb-3">üìù Chunk Details</h4>
                    <div id="chunkDetails" class="space-y-4">
                        ${generateChunkDetails(data.chunk_analysis)}
                    </div>
                </div>
                
                <div class="flex justify-end">
                    <button onclick="closeChunkDebugModal()" 
                            class="px-6 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Store debug data globally for filtering
        window.chunkDebugData = data;
        window.chunkDebugFullAnalysisInProgress = false;
        
        if (data.processing_summary?.chunk_limit_applied) {
            showNotification(
                `Processed ${data.processing_summary.processed_chunks} of ${data.processing_summary.total_chunks} chunks (analysis limit applied).`,
                'warning'
            );
        }
        
        // Initialize slider position based on current threshold
        const thresholdSlider = document.getElementById('thresholdSlider');
        if (thresholdSlider) {
            thresholdSlider.value = getSliderFromThreshold(data.min_confidence);
        }
        
        // Load existing feedback for all chunks
        for (let i = 0; i < data.chunk_analysis.length; i++) {
            loadExistingFeedback(i);
        }
    }
    
    function generateChunkVisualization(data) {
        const totalLength = data.content_length;
        const chunks = data.chunk_analysis;
        
        let html = '<div class="relative bg-gray-100 rounded-lg p-2 mb-4" style="height: 60px;">';
        
        chunks.forEach((chunk, index) => {
            const width = (chunk.length / totalLength) * 100;
            const left = (chunk.start / totalLength) * 100;
            const color = chunk.is_kept ? 'bg-green-500' : 'bg-red-500';
            const opacity = chunk.is_kept ? 'opacity-80' : 'opacity-60';
            
            // Add mismatch indicator
            const mismatchClass = chunk.ml_mismatch ? 'ring-2 ring-yellow-400' : '';
            const mismatchTitle = chunk.ml_mismatch ? ' (ML MISMATCH)' : '';
            
            html += `
                <div class="absolute ${color} ${opacity} ${mismatchClass} rounded cursor-pointer hover:opacity-100 transition-opacity"
                     style="left: ${left}%; width: ${width}%; height: 100%;"
                     title="Chunk ${chunk.chunk_id}: ${chunk.length} chars (${chunk.is_kept ? 'KEPT' : 'REMOVED'})${mismatchTitle}"
                     onclick="highlightChunk(${index})">
                </div>
            `;
        });
        
        html += '</div>';
        
        // Add legend
        html += `
            <div class="flex items-center space-x-4 text-sm">
                <div class="flex items-center">
                    <div class="w-4 h-4 bg-green-500 rounded mr-2"></div>
                    <span>Kept for LLM</span>
                </div>
                <div class="flex items-center">
                    <div class="w-4 h-4 bg-red-500 rounded mr-2"></div>
                    <span>Filtered Out</span>
                </div>
                <div class="flex items-center">
                    <div class="w-4 h-4 bg-yellow-400 rounded mr-2 ring-2 ring-yellow-400"></div>
                    <span>ML Mismatch</span>
                </div>
            </div>
        `;
        
        return html;
    }
    function generateChunkDetails(chunks) {
        return chunks.map((chunk, index) => `
            <div class="chunk-detail border rounded-lg p-4 ${chunk.is_kept ? 'bg-green-50 border-green-200' : 'bg-red-50 border-red-200'}" data-chunk-id="${index}">
                <div class="flex justify-between items-start mb-2">
                    <div class="flex items-center space-x-2">
                        <span class="font-semibold text-gray-900">Chunk ${chunk.chunk_id}</span>
                        <span class="px-2 py-1 text-xs rounded-full ${chunk.is_kept ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">
                            ${chunk.is_kept ? 'KEPT' : 'REMOVED'}
                        </span>
                        ${chunk.has_threat_keywords ? '<span class="px-2 py-1 text-xs rounded-full bg-orange-100 text-orange-800">THREAT</span>' : ''}
                        ${chunk.has_command_patterns ? '<span class="px-2 py-1 text-xs rounded-full bg-blue-100 text-blue-800">COMMAND</span>' : ''}
                        ${chunk.has_perfect_discriminators ? '<span class="px-2 py-1 text-xs rounded-full bg-purple-100 text-purple-800">PERFECT</span>' : ''}
                        ${chunk.ml_mismatch ? '<span class="px-2 py-1 text-xs rounded-full bg-yellow-100 text-yellow-800">ML MISMATCH</span>' : ''}
                    </div>
                    <div class="text-sm text-gray-500">
                        ${chunk.length} chars (${chunk.start}-${chunk.end})
                    </div>
                </div>
                
                <!-- ML Prediction Details -->
                ${chunk.ml_details && !chunk.ml_details.error ? `
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-3">
                        <div class="flex items-center justify-between mb-2">
                            <h5 class="font-semibold text-blue-900">ü§ñ Random Forest Prediction</h5>
                            <span class="px-2 py-1 text-xs rounded-full ${chunk.ml_details.prediction_label === 'Huntable' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">
                                ${chunk.ml_details.prediction_label}
                            </span>
                        </div>
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <div>
                                <div class="text-gray-600">Confidence:</div>
                                <div class="font-semibold">${(() => {
                                    let conf = chunk.ml_details.confidence;
                                    if (conf === undefined || conf === null) {
                                        conf = Math.max(chunk.ml_details.probabilities.huntable, chunk.ml_details.probabilities.not_huntable);
                                    }
                                    return (conf * 100).toFixed(1);
                                })()}%</div>
                            </div>
                            <div>
                                <div class="text-gray-600">Probabilities:</div>
                                <div class="font-semibold">
                                    Huntable: ${(chunk.ml_details.probabilities.huntable * 100).toFixed(1)}% | 
                                    Not Huntable: ${(chunk.ml_details.probabilities.not_huntable * 100).toFixed(1)}%
                                </div>
                            </div>
                        </div>
                        
                        <!-- Top Features -->
                        ${chunk.ml_details.top_features ? `
                            <div class="mt-3">
                                <div class="text-gray-600 text-sm mb-1">Top Contributing Features:</div>
                                <div class="flex flex-wrap gap-1">
                                    ${Object.entries(chunk.ml_details.top_features).slice(0, 5).map(([feature, importance]) => `
                                        <span class="px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded" title="Contribution: ${importance.toFixed(3)}">
                                            ${feature}: ${importance.toFixed(3)}
                                        </span>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                ` : chunk.ml_details && chunk.ml_details.error ? `
                    <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-3 mb-3">
                        <div class="text-yellow-800 text-sm">
                            <strong>ML Error:</strong> ${chunk.ml_details.error}
                        </div>
                    </div>
                ` : `
                    <div class="bg-gray-50 border border-gray-200 rounded-lg p-3 mb-3">
                        <div class="text-gray-600 text-sm">
                            <strong>Pattern-based Classification</strong> (ML model not available)
                        </div>
                    </div>
                `}
                
                <div class="text-sm text-gray-700 mb-2">
                    <strong>Reason:</strong> ${chunk.reason}
                    ${chunk.confidence && !isNaN(chunk.confidence) && chunk.confidence > 0 ? ` | <strong>Confidence:</strong> ${(chunk.confidence * 100).toFixed(1)}%` : ''}
                </div>
                
                <!-- Feedback Section (only show when ML model is available) -->
                ${chunk.ml_details && !chunk.ml_details.error ? `
                <div class="mb-3 p-3 bg-gray-50 rounded-lg border">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm font-medium text-gray-700">Was this ML classification correct?</span>
                        <div class="flex gap-2">
                            <button onclick="submitChunkFeedback(${index}, true)" 
                                    class="px-3 py-1 text-xs bg-green-100 text-green-800 rounded hover:bg-green-200 transition-colors">
                                ‚úÖ Correct - ${chunk.ml_details.prediction_label}
                            </button>
                            <button onclick="submitChunkFeedback(${index}, false)" 
                                    class="px-3 py-1 text-xs bg-red-100 text-red-800 rounded hover:bg-red-200 transition-colors">
                                ‚ùå Incorrect - ${chunk.ml_details.prediction_label === 'Huntable' ? 'Not Huntable' : 'Huntable'}
                            </button>
                        </div>
                    </div>
                    <div id="feedbackSubmitted${index}" class="hidden text-xs text-green-600">
                        ‚úÖ Feedback submitted - Thank you!
                    </div>
                    <div id="existingFeedback${index}" class="hidden mt-2">
                        <!-- Previous feedback will be loaded here -->
                    </div>
                </div>
                ` : ''}
                
                <!-- Feature Details -->
                <div class="mb-3">
                    <button onclick="toggleFeatureDetails(${index})" class="text-sm text-blue-600 hover:text-blue-800 font-medium">
                        üìä Show Feature Details
                    </button>
                    <div id="featureDetails${index}" class="hidden mt-2 bg-gray-50 rounded p-3 text-xs">
                        <div class="grid grid-cols-2 gap-2">
                            ${Object.entries(chunk.features).map(([key, value]) => `
                                <div class="flex justify-between">
                                    <span class="text-gray-600">${key}:</span>
                                    <span class="font-mono">${typeof value === 'number' ? value.toFixed(3) : value}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
                
                <div class="text-sm text-gray-600 bg-white rounded p-2 border">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-xs text-gray-500">Chunk Content (${chunk.length} chars)</span>
                        <button onclick="toggleChunkContent(${index})" class="text-xs text-blue-600 hover:text-blue-800 font-medium">
                            üìÑ ${chunk.text.length > 200 ? 'Show Full Text' : 'View Text'}
                        </button>
                    </div>
                    <div id="chunkContent${index}" class="max-h-32 overflow-y-auto">
                        ${chunk.text.substring(0, 200)}${chunk.text.length > 200 ? '...' : ''}
                    </div>
                    <div id="chunkContentFull${index}" class="hidden max-h-96 overflow-y-auto text-xs font-mono whitespace-pre-wrap">
                        ${chunk.text}
                    </div>
                </div>
            </div>
        `).join('');
    }
    
    function getNormalizedConfidence(chunkData) {
        if (!chunkData) {
            return null;
        }
        
        let confidence = null;
        
        // First try to get confidence from ml_details.confidence
        if (chunkData.ml_details && typeof chunkData.ml_details.confidence !== 'undefined' && chunkData.ml_details.confidence !== null) {
            confidence = parseFloat(chunkData.ml_details.confidence);
        }
        
        // If not found, calculate from probabilities
        if ((confidence === null || Number.isNaN(confidence)) && chunkData.ml_details && chunkData.ml_details.probabilities) {
            const probs = chunkData.ml_details.probabilities;
            if (probs.huntable !== undefined && probs.not_huntable !== undefined) {
                confidence = Math.max(parseFloat(probs.huntable), parseFloat(probs.not_huntable));
            }
        }
        
        // Fallback to chunk confidence
        if ((confidence === null || Number.isNaN(confidence)) && typeof chunkData.confidence !== 'undefined' && chunkData.confidence !== null) {
            confidence = parseFloat(chunkData.confidence);
        }
        
        if (confidence === null || Number.isNaN(confidence)) {
            return null;
        }
        
        // Normalize percentage values into 0-1 range
        if (confidence > 1) {
            confidence = confidence / 100;
        }
        
        // Clamp to [0,1]
        confidence = Math.min(Math.max(confidence, 0), 1);
        return confidence;
    }
    
    function filterChunks(filter) {
        const chunkDetails = document.getElementById('chunkDetails');
        const chunks = chunkDetails.querySelectorAll('.chunk-detail');
        
        chunks.forEach(chunk => {
            const chunkId = parseInt(chunk.dataset.chunkId);
            const chunkData = window.chunkDebugData.chunk_analysis[chunkId];
            
            let show = false;
            
            switch(filter) {
                case 'all':
                    show = true;
                    break;
                case 'kept':
                    show = chunkData.is_kept;
                    break;
                case 'removed':
                    show = !chunkData.is_kept;
                    break;
                case 'threat':
                    show = chunkData.has_threat_keywords || chunkData.has_command_patterns;
                    break;
                case 'perfect':
                    show = chunkData.has_perfect_discriminators;
                    break;
                case 'ml':
                    show = chunkData.ml_details && !chunkData.ml_details.error;
                    break;
                case 'confidenceBand': {
                    const confidence = getNormalizedConfidence(chunkData);
                    if (confidence !== null && confidence >= 0.4 && confidence <= 0.6) {
                        show = true;
                    }
                    break;
                }
                case 'mismatch':
                    show = chunkData.ml_mismatch === true;
                    break;
            }
            
            chunk.style.display = show ? 'block' : 'none';
        });
    }
    
    function highlightChunk(chunkIndex) {
        // Scroll to chunk detail
        const chunkDetail = document.querySelector(`[data-chunk-id="${chunkIndex}"]`);
        if (chunkDetail) {
            chunkDetail.scrollIntoView({ behavior: 'smooth', block: 'center' });
            chunkDetail.classList.add('ring-2', 'ring-blue-500');
            setTimeout(() => {
                chunkDetail.classList.remove('ring-2', 'ring-blue-500');
            }, 2000);
        }
    }
    
    function closeChunkDebugModal() {
        const modal = document.getElementById('chunkDebugModal');
        if (modal) {
            modal.remove();
        }
        // Clear global data
        window.chunkDebugData = null;
    }
    
    // Threshold mapping function
    function getThresholdFromSlider(sliderValue) {
        const thresholds = [0.5, 0.7, 0.8];
        return thresholds[parseInt(sliderValue)];
    }
    
    function getSliderFromThreshold(threshold) {
        const thresholds = [0.5, 0.7, 0.8];
        return thresholds.indexOf(threshold);
    }
    
    // Update threshold from slider position
    async function updateThresholdFromSlider(sliderValue) {
        const threshold = getThresholdFromSlider(sliderValue);
        await updateThreshold(threshold);
    }
    // Threshold update function
    async function updateThreshold(newThreshold) {
        try {
            // Update the display value
            const thresholdValueEl = document.getElementById('thresholdValue');
            if (thresholdValueEl) {
                thresholdValueEl.textContent = newThreshold;
            }
            
            // Update slider position
            const thresholdSlider = document.getElementById('thresholdSlider');
            if (thresholdSlider) {
                thresholdSlider.value = getSliderFromThreshold(parseFloat(newThreshold));
                thresholdSlider.disabled = true; // Show loading state
            }
            
            // Store the threshold globally
            window.chunkDebugThreshold = parseFloat(newThreshold);
            
            // Reload chunk debug data with new threshold
            const chunkSize = window.chunkDebugData?.chunk_size || 1000;
            const overlap = window.chunkDebugData?.overlap || 200;
            const fullAnalysis = window.chunkDebugData?.processing_summary?.full_analysis ? 'true' : 'false';
            
            const params = new URLSearchParams({
                chunk_size: String(chunkSize),
                overlap: String(overlap),
                min_confidence: String(newThreshold),
                full_analysis: fullAnalysis
            });
            
            const response = await fetch(`/api/articles/{{ article.id }}/chunk-debug?${params.toString()}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const debugData = await response.json();
            
            // Update the modal with new data
            updateChunkDebugResults(debugData);
            
        } catch (error) {
            console.error('Threshold update error:', error);
            showNotification('Failed to update threshold: ' + error.message, 'error');
        } finally {
            // Re-enable slider
            const thresholdSlider = document.getElementById('thresholdSlider');
            if (thresholdSlider) {
                thresholdSlider.disabled = false;
            }
        }
    }
    
    function showCostAnalysisHelp() {
        const tooltip = document.getElementById('costAnalysisTooltip');
        if (tooltip) {
            tooltip.classList.toggle('opacity-0');
            tooltip.classList.toggle('invisible');
            tooltip.classList.toggle('opacity-100');
            tooltip.classList.toggle('visible');
        }
    }

    function updateChunkDebugResults(data) {
        // Update statistics cards using IDs
        const totalChunksEl = document.getElementById('totalChunksCount');
        const keptChunksEl = document.getElementById('keptChunksCount');
        const removedChunksEl = document.getElementById('removedChunksCount');
        const reductionEl = document.getElementById('contentReductionPercent');
        
        if (totalChunksEl) totalChunksEl.textContent = data.total_chunks;
        if (keptChunksEl) keptChunksEl.textContent = data.kept_chunks;
        if (removedChunksEl) removedChunksEl.textContent = data.removed_chunks;
        if (reductionEl) reductionEl.textContent = `${data.filtering_stats.reduction_percent.toFixed(1)}%`;
        
        // Update cost analysis
        const originalContentEl = document.getElementById('originalContentLength');
        const costSavingsEl = document.getElementById('costSavings');
        const tokensSavedEl = document.getElementById('tokensSaved');
        
        if (originalContentEl) originalContentEl.textContent = `${data.content_length.toLocaleString()} chars`;
        if (costSavingsEl) costSavingsEl.textContent = `$${data.filtering_stats.cost_savings.toFixed(4)}`;
        if (tokensSavedEl) tokensSavedEl.textContent = `${data.filtering_stats.tokens_saved.toLocaleString()}`;
        
        // Update chunk details
        const chunkDetails = document.getElementById('chunkDetails');
        if (chunkDetails) {
            chunkDetails.innerHTML = generateChunkDetails(data.chunk_analysis);
        }
        
        // Update chunk visualization
        const chunkVisualizationContainer = document.getElementById('chunkVisualizationContainer');
        if (chunkVisualizationContainer) {
            chunkVisualizationContainer.innerHTML = generateChunkVisualization(data);
        }
        
        // Update processing summary
        const summaryContainer = document.getElementById('chunkProcessingSummary');
        if (summaryContainer) {
            summaryContainer.innerHTML = generateProcessingSummary(data.processing_summary);
        }
        
        // Update global data
        window.chunkDebugData = data;
        window.chunkDebugFullAnalysisInProgress = false;
        
        // Show notification
        showNotification(`Threshold updated to ${window.chunkDebugThreshold}. ${data.kept_chunks} chunks kept, ${data.removed_chunks} removed.`, 'success');
        if (data.processing_summary?.chunk_limit_applied) {
            showNotification(
                `Processed ${data.processing_summary.processed_chunks} of ${data.processing_summary.total_chunks} chunks after threshold update (limit applied).`,
                'warning'
            );
        }
    }
    
    // Feedback Functions
    async function submitChunkFeedback(chunkIndex, isCorrect) {
        const chunkData = window.chunkDebugData.chunk_analysis[chunkIndex];
        
        await submitFeedback(chunkIndex, {
            is_correct: isCorrect,
            user_classification: isCorrect ? 
                (chunkData.is_kept ? 'Huntable' : 'Not Huntable') : 
                (chunkData.is_kept ? 'Not Huntable' : 'Huntable'),
            comment: isCorrect ? 'User confirmed classification is correct' : 'User marked classification as incorrect'
        });
    }
    
    async function loadExistingFeedback(chunkIndex) {
        try {
            const response = await fetch(`/api/feedback/chunk-classification/${window.chunkDebugData.article_id}/${chunkIndex}`);
            const result = await response.json();
            
            if (result.success && result.feedback) {
                const feedbackDiv = document.getElementById(`existingFeedback${chunkIndex}`);
                if (feedbackDiv) {
                    const feedback = result.feedback;
                    const timestamp = new Date(feedback.timestamp).toLocaleString();
                    const statusIcon = feedback.is_correct ? '‚úÖ' : '‚ùå';
                    const statusText = feedback.is_correct ? 'Correct' : 'Incorrect';
                    
                    feedbackDiv.innerHTML = `
                        <div class="text-xs text-blue-600 bg-blue-50 p-2 rounded border-l-2 border-blue-400">
                            <div class="font-medium">${statusIcon} Feedback provided (${timestamp})</div>
                        </div>
                    `;
                    feedbackDiv.classList.remove('hidden');
                }
            }
        } catch (error) {
            console.error('Failed to load existing feedback:', error);
        }
    }
    
    async function submitFeedback(chunkIndex, feedbackData) {
        try {
            const chunkData = window.chunkDebugData.chunk_analysis[chunkIndex];
            
            // Get the huntable probability specifically
            let huntable_probability = chunkData.confidence;
            if (chunkData.ml_details && chunkData.ml_details.probabilities) {
                huntable_probability = chunkData.ml_details.probabilities.huntable;
            } else if (chunkData.ml_details && chunkData.ml_details.confidence) {
                // If we only have max confidence, assume it's huntable if is_kept is true
                huntable_probability = chunkData.is_kept ? chunkData.ml_details.confidence : (1.0 - chunkData.ml_details.confidence);
            } else {
                // Fallback: assume confidence is huntable if is_kept is true
                huntable_probability = chunkData.is_kept ? chunkData.confidence : (1.0 - chunkData.confidence);
            }
            
            const payload = {
                article_id: window.chunkDebugData.article_id,
                chunk_id: chunkIndex,
                chunk_text: chunkData.text,
                model_classification: chunkData.is_kept ? 'Huntable' : 'Not Huntable',
                model_confidence: huntable_probability,
                model_reason: chunkData.reason,
                ...feedbackData,
                timestamp: new Date().toISOString()
            };
            
            const response = await fetch('/api/feedback/chunk-classification', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });
            
            if (response.ok) {
                // Show success message
                const feedbackSubmitted = document.getElementById(`feedbackSubmitted${chunkIndex}`);
                if (feedbackSubmitted) {
                    feedbackSubmitted.classList.remove('hidden');
                }
                
                // Reload existing feedback to show updated status
                await loadExistingFeedback(chunkIndex);
                
                showNotification('Feedback submitted successfully!', 'success');
            } else {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }
            
        } catch (error) {
            console.error('Feedback submission error:', error);
            let errorMessage = 'Failed to submit feedback';
            
            if (error.message) {
                errorMessage += ': ' + error.message;
            } else if (error instanceof TypeError) {
                errorMessage += ': Network error or server unavailable';
            } else {
                errorMessage += ': Unknown error occurred';
            }
            
            showNotification(errorMessage, 'error');
        }
    }
    
    async function triggerModelRetraining() {
        try {
            // Show confirmation dialog
            const confirmed = confirm('This will retrain the ML model using collected user feedback. This may take a few minutes. Continue?');
            if (!confirmed) {
                return;
            }
            
            // Show loading state
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'üîÑ Retraining...';
            button.disabled = true;
            
            const response = await fetch('/api/model/retrain', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            const result = await response.json();
            
            if (response.ok) {
                showNotification('Model retraining completed successfully!', 'success');
                
                // Check if comparison data is available
                if (result.has_comparison) {
                    // Show comparison modal
                    await showComparisonModal();
                } else {
                    // Ask if user wants to reload the page to see updated model
                    const reload = confirm('Model retraining complete! Reload the page to see the updated model in action?');
                    if (reload) {
                        window.location.reload();
                    }
                }
            } else {
                throw new Error(result.detail || 'Retraining failed');
            }
            
        } catch (error) {
            console.error('Retraining error:', error);
            showNotification('Failed to retrain model: ' + error.message, 'error');
        } finally {
            // Restore button state
            button.textContent = originalText;
            button.disabled = false;
        }
    }
    
    function toggleFeatureDetails(chunkIndex) {
        const featureDetails = document.getElementById(`featureDetails${chunkIndex}`);
        if (featureDetails) {
            featureDetails.classList.toggle('hidden');
        }
    }
    
    function toggleChunkContent(chunkIndex) {
        const preview = document.getElementById(`chunkContent${chunkIndex}`);
        const full = document.getElementById(`chunkContentFull${chunkIndex}`);
        const button = preview.parentElement.querySelector('button');
        
        if (preview && full && button) {
            const isHidden = full.classList.contains('hidden');
            
            if (isHidden) {
                // Show full content
                preview.classList.add('hidden');
                full.classList.remove('hidden');
                button.textContent = 'üìÑ Hide Text';
            } else {
                // Show preview
                preview.classList.remove('hidden');
                full.classList.add('hidden');
                button.textContent = 'üìÑ Show Full Text';
            }
        }
    }

    // Check AL/ML Assistant button state on page load
    document.addEventListener('DOMContentLoaded', function() {
        checkAIAssistantButtonState();
    });
    
    function checkAIAssistantButtonState() {
        const button = document.getElementById('aiAssistantBtn');
        if (!button) return;
        
        // Get AI model from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const aiModel = settings.aiModel || 'chatgpt';
        
        // Check content size limits
        const contentLength = {{ article.content|length if article.content else 0 }};
        const contentLimit = aiModel === 'chatgpt' ? {{ chatgpt_content_limit }} : 
                           aiModel === 'anthropic' ? {{ anthropic_content_limit }} : {{ ollama_content_limit }};
        
        if (contentLength > contentLimit) {
            // Disable button and add explanation
            button.disabled = true;
            button.className = button.className.replace('bg-purple-600 hover:bg-purple-700', 'bg-gray-400 cursor-not-allowed');
            button.removeAttribute('title'); // Remove tooltip to avoid grey box
            
            // Add warning icon
            const icon = button.querySelector('span');
            if (icon) {
                icon.textContent = '‚ö†Ô∏è';
            }
            
            // Update popover content
            const popover = document.getElementById('aiAssistantPopover');
            const popoverContent = document.getElementById('popoverContent');
            if (popover && popoverContent) {
                popoverContent.textContent = `${contentLength.toLocaleString()} characters (limit: ${contentLimit.toLocaleString()})`;
                
                // Add hover event listeners to wrapper
                const wrapper = document.getElementById('aiAssistantWrapper');
                if (wrapper) {
                    wrapper.addEventListener('mouseenter', function() {
                        popover.classList.remove('hidden');
                    });
                    
                    wrapper.addEventListener('mouseleave', function() {
                        popover.classList.add('hidden');
                    });
                }
            }
        }
    }
    
    // Model Comparison Modal Functions
    async function showComparisonModal() {
        try {
            // Get the latest model version for comparison
            const response = await fetch('/api/model/versions');
            const data = await response.json();
            
            if (!data.success || data.versions.length < 2) {
                // No comparison available, just reload
                const reload = confirm('Model retraining complete! Reload the page to see the updated model in action?');
                if (reload) {
                    window.location.reload();
                }
                return;
            }
            
            // Get the latest version (first in the list)
            const latestVersion = data.versions[0];
            
            // Get comparison data
            const compareResponse = await fetch(`/api/model/compare/${latestVersion.id}`);
            const compareData = await compareResponse.json();
            
            if (!compareData.success) {
                throw new Error('Failed to get comparison data');
            }
            
            // Show the comparison modal
            displayComparisonModal(compareData.comparison, latestVersion);
            
        } catch (error) {
            console.error('Error showing comparison modal:', error);
            // Fallback to reload prompt
            const reload = confirm('Model retraining complete! Reload the page to see the updated model in action?');
            if (reload) {
                window.location.reload();
            }
        }
    }
    
    function displayComparisonModal(comparison, version) {
        // Create modal HTML
        const modalHTML = `
            <div id="comparisonModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div class="bg-white rounded-lg p-6 max-w-4xl max-h-[90vh] overflow-y-auto">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold text-gray-900">ü§ñ Model Performance Comparison</h2>
                        <button onclick="closeComparisonModal()" class="text-gray-500 hover:text-gray-700">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    
                    <div class="mb-6">
                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                            <h3 class="text-lg font-semibold text-blue-900 mb-2">Model Version ${version.version_number}</h3>
                            <p class="text-blue-700">Trained on ${new Date(version.trained_at).toLocaleString()}</p>
                        </div>
                    </div>
                    
                    <!-- Metrics Comparison Table -->
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">Performance Metrics</h3>
                        <div class="overflow-x-auto">
                            <table class="min-w-full bg-white border border-gray-200">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Metric</th>
                                        <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase">Before</th>
                                        <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase">After</th>
                                        <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase">Change</th>
                                    </tr>
                                </thead>
                                <tbody class="divide-y divide-gray-200">
                                    <tr>
                                        <td class="px-4 py-2 font-medium">Accuracy</td>
                                        <td class="px-4 py-2 text-center">${(comparison.old_version.accuracy * 100).toFixed(1)}%</td>
                                        <td class="px-4 py-2 text-center">${(comparison.new_version.accuracy * 100).toFixed(1)}%</td>
                                        <td class="px-4 py-2 text-center ${comparison.improvements.accuracy_change >= 0 ? 'text-green-600' : 'text-red-600'}">
                                            ${comparison.improvements.accuracy_change >= 0 ? '+' : ''}${(comparison.improvements.accuracy_change * 100).toFixed(1)}%
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="px-4 py-2 font-medium">Precision (Huntable)</td>
                                        <td class="px-4 py-2 text-center">${(comparison.old_version.precision_huntable * 100).toFixed(1)}%</td>
                                        <td class="px-4 py-2 text-center">${(comparison.new_version.precision_huntable * 100).toFixed(1)}%</td>
                                        <td class="px-4 py-2 text-center ${comparison.improvements.precision_huntable_change >= 0 ? 'text-green-600' : 'text-red-600'}">
                                            ${comparison.improvements.precision_huntable_change >= 0 ? '+' : ''}${(comparison.improvements.precision_huntable_change * 100).toFixed(1)}%
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="px-4 py-2 font-medium">Recall (Huntable)</td>
                                        <td class="px-4 py-2 text-center">${(comparison.old_version.recall_huntable * 100).toFixed(1)}%</td>
                                        <td class="px-4 py-2 text-center">${(comparison.new_version.recall_huntable * 100).toFixed(1)}%</td>
                                        <td class="px-4 py-2 text-center ${comparison.improvements.recall_huntable_change >= 0 ? 'text-green-600' : 'text-red-600'}">
                                            ${comparison.improvements.recall_huntable_change >= 0 ? '+' : ''}${(comparison.improvements.recall_huntable_change * 100).toFixed(1)}%
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="px-4 py-2 font-medium">Training Data</td>
                                        <td class="px-4 py-2 text-center">${comparison.old_version.training_data_size}</td>
                                        <td class="px-4 py-2 text-center">${comparison.new_version.training_data_size}</td>
                                        <td class="px-4 py-2 text-center text-blue-600">
                                            +${comparison.improvements.training_data_increase}
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="px-4 py-2 font-medium">Feedback Samples</td>
                                        <td class="px-4 py-2 text-center">${comparison.old_version.feedback_samples_count}</td>
                                        <td class="px-4 py-2 text-center">${comparison.new_version.feedback_samples_count}</td>
                                        <td class="px-4 py-2 text-center text-blue-600">
                                            +${comparison.improvements.feedback_samples_added}
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Summary -->
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">Summary</h3>
                        ${comparison.summary.key_improvements.length > 0 ? `
                            <div class="mb-3">
                                <h4 class="font-medium text-green-700 mb-2">‚úÖ Key Improvements:</h4>
                                <ul class="list-disc list-inside text-green-600">
                                    ${comparison.summary.key_improvements.map(improvement => `<li>${improvement}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                        ${comparison.summary.areas_of_concern.length > 0 ? `
                            <div class="mb-3">
                                <h4 class="font-medium text-yellow-700 mb-2">‚ö†Ô∏è Areas of Concern:</h4>
                                <ul class="list-disc list-inside text-yellow-600">
                                    ${comparison.summary.areas_of_concern.map(concern => `<li>${concern}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                    
                    <!-- Actions -->
                    <div class="flex justify-end space-x-3">
                        <button onclick="showFeedbackComparison()" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">
                            View Feedback Impact
                        </button>
                        <button onclick="closeComparisonModal()" class="px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400">
                            Close
                        </button>
                        <button onclick="reloadWithNewModel()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
                            Reload Page with New Model
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        // Add modal to page
        document.body.insertAdjacentHTML('beforeend', modalHTML);
    }
    
    function closeComparisonModal() {
        const modal = document.getElementById('comparisonModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function reloadWithNewModel() {
        closeComparisonModal();
        window.location.reload();
    }
    
    async function showFeedbackComparison() {
        try {
            const response = await fetch('/api/model/feedback-comparison');
            const data = await response.json();
            
            if (!data.success) {
                throw new Error(data.message || 'Failed to get feedback comparison');
            }
            
            displayFeedbackComparisonModal(data);
            
        } catch (error) {
            console.error('Error showing feedback comparison:', error);
            showNotification('Failed to load feedback comparison: ' + error.message, 'error');
        }
    }
    function displayFeedbackComparisonModal(data) {
        // Close the current modal
        closeComparisonModal();
        
        // Filter to current article by default
        const currentArticleId = window.chunkDebugData?.article_id;
        const filteredData = {
            ...data,
            feedback_comparisons: data.feedback_comparisons.filter(c => c.article_id == currentArticleId)
        };
        
        // Create feedback comparison modal
        const modalHTML = `
            <div id="feedbackComparisonModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div class="bg-white rounded-lg p-6 max-w-6xl max-h-[90vh] overflow-y-auto">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold text-gray-900">üìä Feedback Impact Analysis</h2>
                        <button onclick="closeFeedbackComparisonModal()" class="text-gray-500 hover:text-gray-700">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    
                    <div class="mb-6">
                        <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                            <h3 class="text-lg font-semibold text-green-900 mb-2">Model Version ${filteredData.model_version} vs ${filteredData.previous_model_version}</h3>
                            <p class="text-green-700">Showing confidence changes for ${filteredData.feedback_comparisons.length} chunks from the latest retraining</p>
                            <div class="mt-2 text-sm text-green-600">
                                <strong>Comparison Period:</strong> ${filteredData.comparison_period}
                            </div>
                            <div class="mt-1 text-sm text-green-600">
                                <strong>Current Article (${currentArticleId || 'N/A'}):</strong> 
                                ${filteredData.feedback_comparisons.length} chunks
                            </div>
                        </div>
                    </div>
                    
                    
                    <!-- Feedback Comparison Table -->
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">Confidence Changes for Your Feedback</h3>
                        <div class="overflow-x-auto">
                            <table class="min-w-full bg-white border border-gray-200">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Chunk Text</th>
                                        <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase">Old Huntable Confidence</th>
                                        <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase">New Huntable Confidence</th>
                                        <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase">Change</th>
                                        <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase">Your Feedback</th>
                                    </tr>
                                </thead>
                                <tbody class="divide-y divide-gray-200">
                                    ${filteredData.feedback_comparisons.map(comparison => `
                                        <tr>
                                            <td class="px-4 py-2 text-sm" data-article-id="${comparison.article_id}">
                                                <div class="max-w-xs truncate" title="${comparison.chunk_text}">
                                                    ${comparison.chunk_text}
                                                </div>
                                            </td>
                                            <td class="px-4 py-2 text-center">
                                                <span class="text-sm">${(comparison.old_huntable_probability * 100).toFixed(1)}%</span>
                                                <div class="text-xs text-gray-500">${comparison.old_classification}</div>
                                            </td>
                                            <td class="px-4 py-2 text-center">
                                                <span class="text-sm font-medium">${(comparison.new_huntable_probability * 100).toFixed(1)}%</span>
                                                <div class="text-xs text-gray-500">${comparison.new_classification}</div>
                                            </td>
                                            <td class="px-4 py-2 text-center">
                                                <span class="text-sm font-bold ${comparison.huntable_probability_change >= 0 ? 'text-green-600' : 'text-red-600'}">
                                                    ${comparison.huntable_probability_change >= 0 ? '+' : ''}${(comparison.huntable_probability_change * 100).toFixed(1)}%
                                                </span>
                                            </td>
                                            <td class="px-4 py-2 text-center">
                                                <span class="text-xs px-2 py-1 rounded ${comparison.is_correct ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">
                                                    ${comparison.is_correct ? '‚úÖ Correct' : '‚ùå Incorrect'}
                                                </span>
                                                <div class="text-xs text-gray-500 mt-1">${comparison.user_classification}</div>
                                            </td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Summary Statistics -->
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">Summary</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                <div class="text-sm text-blue-600">Average Huntable Confidence Change</div>
                                <div class="text-lg font-semibold text-blue-900">
                                    ${(filteredData.feedback_comparisons.reduce((sum, c) => sum + c.huntable_probability_change, 0) / filteredData.feedback_comparisons.length * 100).toFixed(1)}%
                                </div>
                            </div>
                            <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                                <div class="text-sm text-green-600">Chunks with Improved Huntable Confidence</div>
                                <div class="text-lg font-semibold text-green-900">
                                    ${filteredData.feedback_comparisons.filter(c => c.huntable_probability_change > 0).length}
                                </div>
                            </div>
                            <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                                <div class="text-sm text-red-600">Chunks with Decreased Huntable Confidence</div>
                                <div class="text-lg font-semibold text-red-900">
                                    ${filteredData.feedback_comparisons.filter(c => c.huntable_probability_change < 0).length}
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Actions -->
                    <div class="flex justify-end space-x-3">
                        <button onclick="closeFeedbackComparisonModal()" class="px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400">
                            Close
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        // Add modal to page
        document.body.insertAdjacentHTML('beforeend', modalHTML);
    }
    
    function closeFeedbackComparisonModal() {
        const modal = document.getElementById('feedbackComparisonModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function filterFeedbackTable() {
        const checkbox = document.getElementById('filterCurrentArticle');
        const table = document.querySelector('#feedbackComparisonModal table tbody');
        const currentArticleId = window.chunkDebugData?.article_id;
        
        if (!table || !currentArticleId) return;
        
        const rows = table.querySelectorAll('tr');
        
        rows.forEach(row => {
            const articleIdCell = row.querySelector('td[data-article-id]');
            if (articleIdCell) {
                const rowArticleId = parseInt(articleIdCell.getAttribute('data-article-id'));
                if (checkbox.checked) {
                    // Show only current article
                    row.style.display = rowArticleId === currentArticleId ? '' : 'none';
                } else {
                    // Show all articles
                    row.style.display = '';
                }
            }
        });
    }


    // Toggle Keyword Matches panel
    function toggleKeywordMatches() {
        const content = document.getElementById('keyword-matches-content');
        const chevron = document.getElementById('keyword-matches-chevron');
        const button = chevron.closest('button');
        
        if (content.classList.contains('hidden')) {
            content.classList.remove('hidden');
            chevron.style.transform = 'rotate(180deg)';
            button.setAttribute('aria-expanded', 'true');
        } else {
            content.classList.add('hidden');
            chevron.style.transform = 'rotate(0deg)';
            button.setAttribute('aria-expanded', 'false');
        }
    }
</script>
{% endblock %}