{% extends "base.html" %}

{% block title %}{{ article.title[:50] }}... - Huntable CTI Studio{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <script src="/static/js/components/similarity-display.js"></script>
    <script>
        // Pre-set annotation mode attribute before paint to avoid flashes of the rich container
        (function() {
            const mode = localStorage.getItem('annotationMode') || 'huntability';
            document.documentElement.setAttribute('data-annotation-mode', mode);
            document.body?.setAttribute('data-annotation-mode', mode);
        })();
        
        // Define triggerWorkflowForArticle early to ensure it's available for inline handlers
        async function triggerWorkflowForArticle(articleId) {
            const btn = document.getElementById('triggerWorkflowBtn');
            const btnText = document.getElementById('triggerWorkflowBtnText');
            
            // Disable button and show loading state
            if (btn) {
                btn.disabled = true;
                btn.classList.add('opacity-50', 'cursor-not-allowed');
            }
            if (btnText) {
                btnText.textContent = 'Triggering...';
            }
            
            try {
                // showNotification might not be defined yet, use console as fallback
                if (typeof showNotification === 'function') {
                    showNotification('Triggering workflow...', 'info');
                }
                
                const response = await fetch(`/api/workflow/articles/${articleId}/trigger`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const message = `Workflow triggered successfully! Execution ID: ${data.execution_id || 'N/A'}`;
                    if (typeof showNotification === 'function') {
                        showNotification(message, 'success');
                    } else {
                        alert(message);
                    }
                    
                    // Redirect to workflow executions page
                    window.location.href = '/workflow#executions';
                } else {
                    let errorData;
                    try {
                        errorData = await response.json();
                    } catch (e) {
                        errorData = { detail: `HTTP ${response.status}: ${response.statusText}` };
                    }
                    
                    const errorMessage = errorData.detail || errorData.message || 'Failed to trigger workflow';
                    if (typeof showNotification === 'function') {
                        showNotification(`Error: ${errorMessage}`, 'error');
                    } else {
                        alert(`Error: ${errorMessage}`);
                    }
                    
                    // If there's an existing execution, offer to view it
                    if (errorMessage.includes('already has an active workflow execution')) {
                        const execIdMatch = errorMessage.match(/execution \(ID: (\d+)\)/);
                        if (execIdMatch) {
                            const execId = execIdMatch[1];
                            setTimeout(() => {
                                if (confirm(`${errorMessage}\n\nWould you like to view the existing execution?`)) {
                                    window.location.href = `/workflow#executions`;
                                }
                            }, 100);
                        }
                    }
                }
            } catch (error) {
                console.error('Error triggering workflow:', error);
                const errorMsg = `Error: ${error.message}`;
                if (typeof showNotification === 'function') {
                    showNotification(errorMsg, 'error');
                } else {
                    alert(errorMsg);
                }
            } finally {
                // Re-enable button
                if (btn) {
                    btn.disabled = false;
                    btn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
                if (btnText) {
                    btnText.textContent = 'Send to Workflow';
                }
            }
        }
        
        // Explicitly attach to window for inline onclick handlers
        window.triggerWorkflowForArticle = triggerWorkflowForArticle;
    </script>
    <style>
        /* Hard switch between rich and plain surfaces to prevent legacy span bleed */
        html[data-annotation-mode="observables"] #article-content,
        body[data-annotation-mode="observables"] #article-content {
            display: none !important;
            pointer-events: none !important;
            visibility: hidden !important;
            position: absolute !important;
            left: -99999px !important;
            height: 1px !important;
            overflow: hidden !important;
            opacity: 0 !important;
        }
        html[data-annotation-mode="observables"] #article-content-plain,
        body[data-annotation-mode="observables"] #article-content-plain {
            display: block !important;
            pointer-events: auto !important;
            visibility: visible !important;
            position: static !important;
            left: auto !important;
            height: auto !important;
            overflow: visible !important;
            opacity: 1 !important;
        }
        html[data-annotation-mode="huntability"] #article-content-plain,
        body[data-annotation-mode="huntability"] #article-content-plain {
            display: none !important;
            pointer-events: none !important;
            visibility: hidden !important;
            position: absolute !important;
            left: -99999px !important;
            height: 1px !important;
            overflow: hidden !important;
            opacity: 0 !important;
        }
        html[data-annotation-mode="huntability"] #article-content,
        body[data-annotation-mode="huntability"] #article-content {
            display: block !important;
            pointer-events: auto !important;
            visibility: visible !important;
            position: static !important;
            left: auto !important;
            height: auto !important;
            overflow: visible !important;
            opacity: 1 !important;
        }
        
        /* CSS changes from browser preview - text color only */
        dd.text-sm {
            color: #d1d5db !important;
        }
        
        dd.text-sm * {
            color: #d1d5db !important;
        }
        
        dd.text-sm.font-mono code {
            color: #d1d5db !important;
        }
        
        /* JSON metadata pre element - make all text light grey */
        pre.bg-\[#0a0e1a\],
        pre[class*="bg-[#0a0e1a]"],
        pre.font-mono.bg-\[#0a0e1a\],
        pre.font-mono[class*="bg-[#0a0e1a]"] {
            color: #d1d5db !important;
        }
        
        pre.bg-\[#0a0e1a\] *,
        pre[class*="bg-[#0a0e1a]"] *,
        pre.font-mono.bg-\[#0a0e1a\] *,
        pre.font-mono[class*="bg-[#0a0e1a]"] *,
        pre.bg-\[#0a0e1a\]::before,
        pre.bg-\[#0a0e1a\]::after,
        pre[class*="bg-[#0a0e1a]"]::before,
        pre[class*="bg-[#0a0e1a]"]::after {
            color: #d1d5db !important;
        }
        
        /* Override any syntax highlighting or Tailwind text color classes */
        pre.bg-\[#0a0e1a\] span,
        pre.bg-\[#0a0e1a\] code,
        pre.bg-\[#0a0e1a\] mark,
        pre[class*="bg-[#0a0e1a]"] span,
        pre[class*="bg-[#0a0e1a]"] code,
        pre[class*="bg-[#0a0e1a]"] mark,
        pre.font-mono.bg-\[#0a0e1a\] span,
        pre.font-mono.bg-\[#0a0e1a\] code,
        pre.font-mono.bg-\[#0a0e1a\] mark {
            color: #d1d5db !important;
        }
        
        /* Universal override for any element inside the pre */
        pre[class*="bg-[#0a0e1a]"] *,
        pre.bg-\[#0a0e1a\] * {
            color: #d1d5db !important;
        }
        
        /* Mobile Annotation card styling */
        #mobile-annotation-instructions {
            background-color: rgba(201, 189, 182, 1) !important;
            border-color: rgba(29, 22, 22, 1) !important;
            border-width: 1px !important;
            border-style: solid !important;
            box-shadow: 0px 4px 12px 0px rgba(0, 0, 0, 0.15) !important;
            color: #ffffff !important;
        }
        
        code[class*="bg-[#0a0e1a]"] {
            color: #d1d5db !important;
        }
        
        dd.text-sm code {
            color: #d1d5db !important;
        }
    </style>
    <!-- Breadcrumb -->
    <nav class="flex mb-8" aria-label="Breadcrumb">
        <ol class="inline-flex items-center space-x-1 md:space-x-3">
            <li class="inline-flex items-center">
                <a href="/" class="inline-flex items-center text-sm font-medium text-gray-700 dark:text-gray-300 hover:text-blue-600 dark:hover:text-blue-400">
                    <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"></path>
                    </svg>
                    Dashboard
                </a>
            </li>
            <li>
                <div class="flex items-center">
                    <svg class="w-6 h-6 text-gray-400 dark:text-gray-500" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path>
                    </svg>
                    <a href="/articles" class="ml-1 text-sm font-medium text-gray-700 dark:text-gray-300 hover:text-blue-600 dark:hover:text-blue-400 md:ml-2">Articles</a>
                </div>
            </li>
            <li aria-current="page">
                <div class="flex items-center">
                    <svg class="w-6 h-6 text-gray-400 dark:text-gray-500" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path>
                    </svg>
                    <span class="ml-1 text-sm font-medium text-gray-500 dark:text-gray-400 md:ml-2">Article #{{ article.id }}</span>
                </div>
            </li>
        </ol>
    </nav>

    <!-- Article Header -->
    <div class="bg-gray-800 border border-gray-700 rounded-lg shadow p-6 mb-8">
        <div class="flex items-start justify-between">
            <div class="flex-1">
                <h1 class="text-3xl font-bold text-gray-900 dark:text-white mb-6 leading-tight">{{ article.title }}</h1>
                
                <div class="flex items-center space-x-6 text-sm text-gray-600 dark:text-gray-400 mb-6">
                    <div class="flex items-center">
                        <span class="mr-2">üì∞</span>
                        <span>Source: 
                            {% if article.canonical_url %}
                                <a href="{{ article.canonical_url }}" target="_blank" class="text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 hover:underline">
                                    {{ source.name if source else article.source_id }}
                                </a>
                            {% else %}
                                {{ source.name if source else article.source_id }}
                            {% endif %}
                        </span>
                    </div>
                    {% if article.published_at %}
                    <div class="flex items-center">
                        <span class="mr-2">üìÖ</span>
                        <span>{{ article.published_at.strftime('%Y-%m-%d %H:%M:%S') }}</span>
                    </div>
                    {% endif %}
                    <div class="flex items-center">
                        <span class="mr-2">üìä</span>
                        <span>{{ article.content|length }} characters</span>
                    </div>
                    <div class="flex items-center">
                        <span class="mr-2">üÜî</span>
                        <span>#{{ article.id }}</span>
                    </div>
                    {% if article.article_metadata and article.article_metadata.get('threat_hunting_score') is not none %}
                    <div class="flex items-center">
                        <span class="mr-2">üéØ</span>
                        <span>RegexHuntScore: 
                            {% set score = article.article_metadata.get('threat_hunting_score', 0) %}
                            {% if score >= 80 %}
                                <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 border border-green-200 dark:border-green-700">
                                    üéØ {{ "%.1f"|format(score) }}
                                </span>
                            {% elif score >= 60 %}
                                <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 border border-yellow-200 dark:border-yellow-700">
                                    üü° {{ "%.1f"|format(score) }}
                                </span>
                            {% elif score >= 40 %}
                                <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-orange-100 dark:bg-orange-900 text-orange-800 dark:text-orange-200 border border-orange-200 dark:border-orange-700">
                                    üü† {{ "%.1f"|format(score) }}
                                </span>
                            {% else %}
                                <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 border border-red-200 dark:border-red-700">
                                    üî¥ {{ "%.1f"|format(score) }}
                                </span>
                            {% endif %}
                        </span>
                    </div>
                    {% endif %}
                    <div class="flex items-center">
                        <span class="mr-2">ü§ñ</span>
                        <span>MLHuntScore: 
                            {% if article.article_metadata and article.article_metadata.get('ml_hunt_score') is not none %}
                                {% set ml_score = article.article_metadata.get('ml_hunt_score', 0) %}
                                {% if ml_score >= 80 %}
                                    <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 border border-green-200 dark:border-green-700">
                                        ü§ñ {{ "%.1f"|format(ml_score) }}
                                    </span>
                                {% elif ml_score >= 60 %}
                                    <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 border border-yellow-200 dark:border-yellow-700">
                                        üü° {{ "%.1f"|format(ml_score) }}
                                    </span>
                                {% elif ml_score >= 40 %}
                                    <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-orange-100 dark:bg-orange-900 text-orange-800 dark:text-orange-200 border border-orange-200 dark:border-orange-700">
                                        üü† {{ "%.1f"|format(ml_score) }}
                                    </span>
                                {% else %}
                                    <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 border border-red-200 dark:border-red-700">
                                        üî¥ {{ "%.1f"|format(ml_score) }}
                                    </span>
                                {% endif %}
                            {% else %}
                                <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-400 border border-gray-200 dark:border-gray-700 relative group cursor-help">
                                    TBD
                                    <span class="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 dark:bg-gray-700 text-white text-xs rounded-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible pointer-events-none whitespace-pre-line z-50 w-72 text-left shadow-lg">
                                        <strong>ML Hunt Score: To Be Determined</strong><br><br>
                                        This score requires chunk analysis to be run first.<br><br>
                                        <strong>How to generate:</strong><br>
                                        1. Scroll down to "Chunk Analysis" section and click "Run Full Analysis"<br>
                                        2. Or run CLI: <code class="bg-gray-800 px-1 rounded text-xs">./run_cli.sh rescore-ml --article-id {{ article.id }}</code>
                                    </span>
                                </span>
                            {% endif %}
                        </span>
                    </div>
                </div>

                <div class="mb-4 flex flex-wrap items-center gap-3">
                    {% if article.canonical_url %}
                    <a href="{{ article.canonical_url }}" target="_blank"
                       class="inline-flex items-center px-4 py-2 border border-gray-600 hover:bg-gray-800 text-gray-300 text-sm font-medium rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition-colors">
                        <span class="mr-2">üîó</span>
                        View Original Source
                    </a>
                    {% endif %}

                    <button onclick="triggerWorkflowForArticle({{ article.id|default(0)|int }})" 
                            id="triggerWorkflowBtn"
                            class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-lg text-white bg-purple-500 hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition-colors">
                        <span class="mr-2">‚ö°</span>
                        <span id="triggerWorkflowBtnText">Send to Workflow</span>
                    </button>

                    <div class="relative inline-block" id="aiAssistantWrapper">
                        <button id="aiAssistantBtn" onclick="showAIAssistant()" 
                                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-[#4b4e77] hover:bg-[#7C3AED] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                            <span class="mr-2">ü§ñ</span>
                            AL/ML Assistant
                        </button>
                        <div id="aiAssistantPopover" class="absolute z-10 top-full left-0 mt-2 hidden w-64">
                            <div class="text-sm text-amber-700 bg-amber-50 border border-amber-200 rounded-md p-3 shadow-lg">
                                <div class="flex items-start">
                                    <span class="mr-2 mt-0.5">‚ö†Ô∏è</span>
                                    <div>
                                        <div class="font-medium">Article too large for AI processing</div>
                                        <div class="text-xs text-amber-600 mt-1" id="popoverContent">
                                            Loading...
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <button onclick="deleteArticle({{ article.id }})" 
                            class="inline-flex items-center px-4 py-2 border border-red-500 text-red-400 hover:bg-red-500/10 text-sm font-medium rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition-colors">
                        <span class="mr-2">üóëÔ∏è</span>
                        Delete Article
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Keyword Matches Display -->
    {% if article.article_metadata %}
    <div class="bg-gray-800 border border-gray-700 rounded-lg shadow p-6 mb-8">
        <div 
            data-collapsible-panel="keyword-matches"
            class="flex items-center justify-between w-full text-left focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-lg cursor-pointer -m-6 py-6 px-6 hover:bg-gray-50 dark:hover:bg-gray-700/50 transition-colors"
        >
            <h2 class="text-xl font-bold text-gray-900 dark:text-white my-0 flex items-center">üéØ Keyword Matches</h2>
            <span id="keyword-matches-toggle">
                <svg 
                    id="keyword-matches-chevron" 
                    class="w-6 h-6 text-gray-500 dark:text-gray-400 transform transition-transform duration-200" 
                    fill="none" 
                    stroke="currentColor" 
                    viewBox="0 0 24 24"
                    aria-hidden="true"
                >
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </span>
        </div>
        
        <div id="keyword-matches-content" class="hidden mt-11">
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
            <!-- Perfect Discriminators -->
            <div class="card bg-green-100 dark:bg-green-800 border border-green-300 dark:border-green-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-green-800 dark:text-green-200 flex items-center">
                        <span class="mr-2">‚úÖ</span>
                        Perfect Discriminators
                    </h3>
                    <span class="text-xs font-bold text-white bg-emerald-600 dark:bg-emerald-600 px-2 py-1 rounded-full">
                        75 pts
                    </span>
                </div>
                <div class="flex flex-wrap gap-1">
                    {% for keyword in article.article_metadata.get('perfect_keyword_matches', []) %}
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200 border border-green-200 dark:border-green-600">
                        {{ keyword }}
                    </span>
                    {% endfor %}
                    {% if not article.article_metadata.get('perfect_keyword_matches') %}
                    <span class="text-xs text-gray-500 dark:text-gray-400 italic">No matches</span>
                    {% endif %}
                </div>
            </div>
            
            <!-- Good Discriminators -->
            <div class="card bg-purple-100 dark:bg-purple-800 border border-purple-300 dark:border-purple-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-purple-800 dark:text-purple-200 flex items-center">
                        <span class="mr-2">üü£</span>
                        Good Discriminators
                    </h3>
                    <span class="text-xs font-bold text-white bg-purple-600 dark:bg-purple-600 px-2 py-1 rounded-full">
                        5 pts
                    </span>
                </div>
                <div class="flex flex-wrap gap-1">
                    {% for keyword in article.article_metadata.get('good_keyword_matches', []) %}
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-purple-100 dark:bg-purple-800 text-purple-800 dark:text-purple-200 border border-purple-200 dark:border-purple-600">
                        {{ keyword }}
                    </span>
                    {% endfor %}
                    {% if not article.article_metadata.get('good_keyword_matches') %}
                    <span class="text-xs text-gray-500 dark:text-gray-400 italic">No matches</span>
                    {% endif %}
                </div>
            </div>
            
            <!-- LOLBAS Executables -->
            <div class="card bg-blue-100 dark:bg-blue-800 border border-blue-300 dark:border-blue-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-blue-800 dark:text-blue-200 flex items-center">
                        <span class="mr-2">üîß</span>
                        LOLBAS Executables
                    </h3>
                    <span class="text-xs font-bold text-white bg-blue-600 dark:bg-blue-600 px-2 py-1 rounded-full">
                        10 pts
                    </span>
                </div>
                <div class="flex flex-wrap gap-1">
                    {% for keyword in article.article_metadata.get('lolbas_matches', []) %}
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-blue-100 dark:bg-blue-800 text-blue-800 dark:text-blue-200 border border-blue-200 dark:border-blue-600">
                        {{ keyword }}
                    </span>
                    {% endfor %}
                    {% if not article.article_metadata.get('lolbas_matches') %}
                    <span class="text-xs text-gray-500 dark:text-gray-400 italic">No matches</span>
                    {% endif %}
                </div>
            </div>
            
            <!-- Intelligence Indicators -->
            <div class="card bg-red-100 dark:bg-red-800 border border-red-300 dark:border-red-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-red-800 dark:text-red-200 flex items-center">
                        <span class="mr-2">üéØ</span>
                        Intelligence Indicators
                    </h3>
                    <span class="text-xs font-bold text-white bg-red-600 dark:bg-red-600 px-2 py-1 rounded-full">
                        10 pts
                    </span>
                </div>
                <div class="flex flex-wrap gap-1">
                    {% for keyword in article.article_metadata.get('intelligence_matches', []) %}
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-red-100 dark:bg-red-800 text-red-800 dark:text-red-200 border border-red-200 dark:border-red-600">
                        {{ keyword }}
                    </span>
                    {% endfor %}
                    {% if not article.article_metadata.get('intelligence_matches') %}
                    <span class="text-xs text-gray-500 dark:text-gray-400 italic">No matches</span>
                    {% endif %}
                </div>
            </div>
            
            <!-- Negative Indicators -->
            <div class="card bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-gray-800 dark:text-gray-200 flex items-center">
                        <span class="mr-2">‚ö†Ô∏è</span>
                        Negative Indicators
                    </h3>
                    <span class="text-xs font-bold text-white bg-gray-600 dark:bg-gray-600 px-2 py-1 rounded-full">
                        -10 pts
                    </span>
                </div>
                <div class="flex flex-wrap gap-1">
                    {% for keyword in article.article_metadata.get('negative_matches', []) %}
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-gray-100 dark:bg-gray-800 text-gray-800 dark:text-gray-200 border border-gray-200 dark:border-gray-600">
                        {{ keyword }}
                    </span>
                    {% endfor %}
                    {% if not article.article_metadata.get('negative_matches') %}
                    <span class="text-xs text-gray-500 dark:text-gray-400 italic">No matches</span>
                    {% endif %}
                </div>
            </div>
            
            </div>
        </div>
        
    </div>
    {% endif %}

    <div class="bg-gray-800 border border-gray-700 rounded-lg shadow p-6 mb-8">
        <h2 class="text-xl font-bold text-gray-900 dark:text-white mb-6">üìÑ Article Content</h2>
        
        <div class="bg-gray-100 dark:bg-gray-900 rounded-lg p-6">
            <div class="flex items-center justify-between mb-6">
                <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200">Article Content</h3>
                <div class="flex items-center space-x-4">
                    <div class="flex items-center space-x-2">
                        <span class="text-sm text-gray-600 dark:text-gray-400">Select text to annotate</span>
                        <div class="flex items-center space-x-1">
                            <span class="w-3 h-3 bg-green-100 dark:bg-green-900 border border-green-300 dark:border-green-700 rounded"></span>
                            <span class="text-xs text-gray-600 dark:text-gray-400">Huntable</span>
                        </div>
                        <div class="flex items-center space-x-1">
                            <span class="w-3 h-3 bg-red-100 dark:bg-red-900 border border-red-300 dark:border-red-700 rounded"></span>
                            <span class="text-xs text-gray-600 dark:text-gray-400">Not Huntable</span>
                        </div>
                        </div>
                    </div>
                    <div class="flex flex-wrap items-center gap-3 mt-4 relative z-10">
                        <div class="inline-flex rounded-lg border border-gray-300 dark:border-gray-600 overflow-hidden">
                            <button id="annotation-mode-huntability" onclick="setAnnotationMode('huntability')" class="px-3 py-1 text-xs font-semibold text-gray-700 dark:text-gray-200 bg-white hover:bg-gray-50 dark:hover:bg-gray-700 cursor-pointer transition-colors relative z-10" style="pointer-events: auto; color: rgba(196, 171, 171, 1); background-color: var(--color-border);">
                                Huntability Mode
                            </button>
                            <button id="annotation-mode-observables" onclick="setAnnotationMode('observables')" class="px-3 py-1 text-xs font-semibold text-gray-700 dark:text-gray-200 bg-white border-l border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700 cursor-pointer transition-colors relative z-10" style="pointer-events: auto;">
                                Observables Mode
                            </button>
                        </div>
                        <div id="observable-type-picker" class="hidden items-center gap-2">
                            <span class="text-xs font-semibold text-gray-600 dark:text-gray-300">Observable Type:</span>
                            <div class="inline-flex rounded-lg border border-purple-300 dark:border-purple-700 overflow-hidden">
                                <button data-observable-type="CMD" onclick="setObservableType('CMD')" class="px-3 py-1 text-xs font-semibold text-gray-700 dark:text-gray-200 bg-white">
                                    CMD
                                </button>
                                <button data-observable-type="PROC_LINEAGE" onclick="setObservableType('PROC_LINEAGE')" class="px-3 py-1 text-xs font-semibold text-gray-700 dark:text-gray-200 bg-gray-400 border-l border-purple-200 dark:border-purple-600" style="background-color: var(--color-border-subtle);">
                                    PROC_LINEAGE
                                </button>
                            </div>
                        </div>
                        <div id="observable-usage-picker" class="hidden items-center gap-2">
                            <span class="text-xs font-semibold text-gray-600 dark:text-gray-300">Dataset:</span>
                            <div id="observableUsageButtons" class="inline-flex rounded-lg border border-purple-300 dark:border-purple-700 overflow-hidden">
                                <button data-dataset-usage="train" onclick="setObservableDatasetUsage('train')" class="px-3 py-1 text-xs font-semibold text-gray-700 dark:text-gray-200 bg-white">
                                    Training
                                </button>
                                <button data-dataset-usage="eval" onclick="setObservableDatasetUsage('eval')" class="px-3 py-1 text-xs font-semibold text-gray-700 dark:text-gray-200 bg-gray-400 border-l border-purple-200 dark:border-purple-600">
                                    Evaluation
                                </button>
                                <button data-dataset-usage="gold" onclick="setObservableDatasetUsage('gold')" class="px-3 py-1 text-xs font-semibold text-gray-600 dark:text-gray-300 bg-white border-l border-purple-200 dark:border-purple-600">
                                    Gold <span class="text-[10px] text-gray-400">(locked)</span>
                                </button>
                            </div>
                        </div>
                        <button id="mark-observable-reviewed" class="hidden px-3 py-1 text-xs font-semibold bg-[#4b4e77] text-white rounded-lg hover:bg-[#7C3AED] transition-colors" onclick="markObservablesReviewed({{ article.id }})">
                            Reviewed (No Observables)
                        </button>
                    </div>
                </div>
                <div class="prose max-w-none relative">
                <div class="absolute top-4 right-4 flex items-center space-x-2 z-50">
                    <button id="toggle-annotations-btn" onclick="toggleAnnotationSystem()" 
                            class="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition-colors rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 bg-gray-800 border border-gray-700 shadow-md border border-gray-200 dark:border-gray-700"
                            title="Toggle annotation system">
                        <svg id="toggle-annotations-icon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"></path>
                        </svg>
                    </button>
                    <button onclick="copyArticleContentToClipboard()" 
                            class="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition-colors rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700"
                            title="Copy article content">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                    </button>
                    <button onclick="exportArticleToPDF()" 
                            class="p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition-colors rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700"
                            title="Export to PDF and print">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 17h2a2 2 0 002-2v-4a2 2 0 00-2-2H5a2 2 0 00-2 2v4a2 2 0 002 2h2m2 4h6a2 2 0 002-2v-4a2 2 0 00-2-2H9a2 2 0 00-2 2v4a2 2 0 002 2zm8-12V5a2 2 0 00-2-2H9a2 2 0 00-2 2v4h10z"></path>
                        </svg>
                    </button>
                </div>
                <div id="article-content" class="whitespace-pre-wrap text-base text-gray-900 dark:text-gray-100 font-mono leading-relaxed select-text bg-stone-100 dark:bg-gray-800 px-6 pt-20 pb-6 rounded-lg border-2 border-gray-300 dark:border-gray-600 shadow-inner" style="color: #111827;">{{ article.content|highlight_keywords(article.article_metadata)|safe }}</div>
                <div id="article-content-plain" class="hidden whitespace-pre-wrap text-base text-gray-900 dark:text-gray-100 font-mono leading-relaxed select-text bg-stone-100 dark:bg-gray-800 px-6 pt-20 pb-6 rounded-lg border-2 border-gray-300 dark:border-gray-600 shadow-inner" style="color: rgb(0, 0, 0); background-color: rgba(182, 181, 175, 1); border: 1px solid rgb(245, 158, 11); box-shadow: 0px 0px 0px 0px rgba(0, 0, 0, 0), 0px 0px 0px 0px rgba(0, 0, 0, 0), inset 0px 2px 4px 0px rgba(0, 0, 0, 0.05);">{{ article.content|e }}</div>
            </div>
        </div>
    </div>

    <!-- Article Metadata -->
    <div class="bg-gray-800 border border-gray-700 rounded-lg shadow p-6 mb-8">
        <div 
            data-collapsible-panel="article-metadata"
            class="flex items-center justify-between w-full text-left focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-lg cursor-pointer -m-6 py-6 px-6 hover:bg-gray-50 dark:hover:bg-gray-700/50 transition-colors"
        >
            <h2 class="text-xl font-bold text-gray-900 dark:text-white my-0 flex items-center">üìã Article Metadata</h2>
            <span id="article-metadata-toggle">
                <svg 
                    id="article-metadata-chevron" 
                    class="w-6 h-6 text-gray-500 dark:text-gray-400 transform transition-transform duration-200" 
                    fill="none" 
                    stroke="currentColor" 
                    viewBox="0 0 24 24"
                >
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </span>
        </div>
        
        <div id="article-metadata-content" class="hidden">
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
                <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4">Basic Information</h3>
                <dl class="space-y-3">
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Article ID</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">#{{ article.id }}</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Source ID</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.source_id }}</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Published At</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.published_at.strftime('%Y-%m-%d %H:%M:%S') if article.published_at else 'N/A' }}</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Discovered At</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.discovered_at.strftime('%Y-%m-%d %H:%M:%S') if article.discovered_at else 'N/A' }}</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Processing Status</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.processing_status }}</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Word Count</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.word_count or 'N/A' }}</dd>
                    </div>
                </dl>
            </div>
            
            <div>
                <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4">Content Details</h3>
                <dl class="space-y-3">
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Content Length</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.content|length }} characters</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-400">Content Hash</dt>
                        <dd class="text-sm font-mono">
                            <code class="bg-[#0a0e1a] text-gray-300 px-2 py-1 rounded font-mono text-sm cursor-pointer hover:bg-gray-700 transition-colors" onclick="navigator.clipboard.writeText('{{ article.content_hash }}').then(() => { const el = event.target; const orig = el.textContent; el.textContent = 'Copied!'; setTimeout(() => el.textContent = orig, 1000); })" title="Click to copy">{{ article.content_hash[:20] }}...</code>
                        </dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Authors</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">
                            {% if article.authors %}
                                {{ article.authors|join(', ') }}
                            {% else %}
                                N/A
                            {% endif %}
                        </dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Tags</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">
                            {% if article.tags %}
                                {{ article.tags|join(', ') }}
                            {% else %}
                                N/A
                            {% endif %}
                        </dd>
                    </div>
                </dl>
            </div>
        </div>
        
        {% if article.article_metadata %}
        <pre class="bg-[#0a0e1a] border border-gray-700 p-4 rounded-lg text-sm overflow-x-auto font-mono" style="background-color: rgba(28, 22, 8, 1); color: #d1d5db !important;">{{ article.article_metadata|tojson(indent=2) }}</pre>
        {% endif %}
        </div>
    </div>

    <!-- Navigation -->
    <div class="flex items-center justify-between">
        <a href="/articles" class="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 transition-colors">
            <span class="mr-2">‚Üê</span>
            Back to Articles
        </a>
        
        <div class="flex space-x-2">
            <button onclick="navigateToPrevious()" 
                    class="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 transition-colors">
                Previous Article
            </button>
            
            <button onclick="navigateToNext()" 
                    class="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 transition-colors">
                Next Article
                <span class="ml-2">‚Üí</span>
            </button>
        </div>
    </div>
</div>
{% endblock %}
{% block scripts %}
<!-- html2pdf.js library for PDF generation -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
<!-- CRITICAL: Early script block with essential functions - must load before main script -->
<script>
    // Essential functions that must be available immediately for onclick handlers
    // Defined in separate script block to ensure they load even if main script has errors
    
    function setAnnotationMode(mode) {
        try {
            if (window.simpleTextManager) {
                window.simpleTextManager.setAnnotationMode(mode);
            } else {
                console.warn('setAnnotationMode called before simpleTextManager initialized, mode:', mode);
                localStorage.setItem('annotationMode', mode);
            }
        } catch (error) {
            console.error('Error in setAnnotationMode:', error);
        }
    }
    window.setAnnotationMode = setAnnotationMode;
    
    function copyArticleContentToClipboard() {
        try {
            const contentElement = document.getElementById('article-content');
            if (!contentElement) {
                if (typeof showNotification === 'function') {
                    showNotification('Article content element not found', 'error');
                } else {
                    alert('Article content element not found');
                }
                return;
            }
            
            const textContent = contentElement.innerText || contentElement.textContent || '';
            
            if (!textContent.trim()) {
                if (typeof showNotification === 'function') {
                    showNotification('Article has no content to copy', 'error');
                } else {
                    alert('Article has no content to copy');
                }
                return;
            }
            
            navigator.clipboard.writeText(textContent).then(() => {
                if (typeof showNotification === 'function') {
                    showNotification('Article content copied to clipboard!', 'success');
                } else {
                    alert('Article content copied to clipboard!');
                }
            }).catch(error => {
                console.error('Error copying to clipboard:', error);
                if (typeof showNotification === 'function') {
                    showNotification('Failed to copy article content', 'error');
                } else {
                    alert('Failed to copy article content');
                }
            });
        } catch (error) {
            console.error('Error copying article content:', error);
            if (typeof showNotification === 'function') {
                showNotification('Failed to copy article content', 'error');
            } else {
                alert('Failed to copy article content');
            }
        }
    }
    window.copyArticleContentToClipboard = copyArticleContentToClipboard;
</script>

<!-- Main script block - rest of the application code -->
<script>
    // Global help functions - must be defined at top level for onclick handlers
    let previousModalElement = null;
    
    // Helper function to clean up existing modal before creating new one
    async function cleanupExistingModal(modalId) {
        const existingModal = document.getElementById(modalId);
        if (existingModal) {
            // Remove from ModalManager stack if present
            if (window.ModalManager) {
                const stack = window.ModalManager.getStack();
                while (stack.includes(modalId)) {
                    const index = stack.indexOf(modalId);
                    stack.splice(index, 1);
                }
            }
            // Remove from DOM
            existingModal.remove();
            // Small delay to ensure cleanup completes
            await new Promise(resolve => setTimeout(resolve, 10));
        }
    }
    
    async function showHelpModal(title, promptContent, modelInfo = null) {
        // Remove any existing help modal
        await cleanupExistingModal('helpModal');
        
        // Find and hide the currently visible modal (the one that opened the help)
        const visibleModals = document.querySelectorAll('#iocsModal, #sigmaRulesModal, #gpt4oRankingModal, #customPromptModal');
        previousModalElement = null;
        
        visibleModals.forEach(modal => {
            if (modal.style.display !== 'none' && modal.offsetParent !== null) {
                modal.style.display = 'none';
                previousModalElement = modal;
            }
        });
        
        const modal = document.createElement('div');
        modal.id = 'helpModal';
        modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-[9999]';
        
        document.body.appendChild(modal);
        
        // Ensure modal is visible
        modal.classList.remove('hidden');
        
        // Register and open with ModalManager
        if (window.ModalManager) {
            setTimeout(() => {
                window.ModalManager.register('helpModal', {
                    isDynamic: true,
                    hasInput: false
                });
                window.ModalManager.open('helpModal');
                modal.classList.remove('hidden');
            }, 50);
        }
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium text-gray-900">‚ÑπÔ∏è ${title}</h3>
                    <button onclick="closeHelpModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-4 text-sm text-gray-600">
                    <span class="font-medium">Prompt Template:</span> This is the canned prompt sent to the LLM for this analysis.
                </div>
                
                <div class="bg-gray-50 p-4 rounded-lg max-h-96 overflow-y-auto">
                    <pre class="text-sm text-gray-800 whitespace-pre-wrap font-mono" style="white-space: pre-wrap; word-wrap: break-word;">${promptContent}</pre>
                </div>
                
                <div class="mt-4 text-xs text-gray-500">
                    <strong>Note:</strong> Future versions will support custom prompts for different models.
                </div>
            </div>
        `;
    }
    
    function closeHelpModal() {
        if (window.ModalManager) {
            window.ModalManager.close('helpModal');
        } else {
            const modal = document.getElementById('helpModal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Restore the previously hidden modal
        if (previousModalElement) {
            previousModalElement.style.display = 'block';
            previousModalElement = null;
        }
    }

    function showIOCHelp() {
        const promptContent = `Extract Indicators of Compromise (IOCs) from this threat intelligence article.

**Article Title:** {title}
**Source:** {source}
**URL:** {url}

**Extraction Guidelines:**
1. **Focus on Actionable IOCs:** Extract IP addresses, domains, file hashes, email addresses, and URLs
2. **Context Matters:** Include surrounding context for each IOC to understand its significance
3. **Categorize Properly:** Classify each IOC by type (ip, domain, hash, email, url, etc.)
4. **Confidence Scoring:** Provide confidence scores (0.0-1.0) based on IOC clarity and context
5. **Avoid False Positives:** Only extract IOCs that are clearly malicious or suspicious

**IOC Types to Extract:**
- **IP Addresses:** IPv4 and IPv6 addresses
- **Domains:** Fully qualified domain names
- **File Hashes:** MD5, SHA1, SHA256 hashes
- **Email Addresses:** Malicious or suspicious email addresses
- **URLs:** Full URLs including paths and parameters
- **File Paths:** Suspicious file paths and filenames
- **Registry Keys:** Windows registry keys and values
- **Process Names:** Malicious process names and executables

**Output Format:**
Return a JSON array of IOC objects with the following structure:
[
  {
    "type": "ip",
    "value": "192.168.1.100",
    "context": "C2 server used for command and control",
    "confidence": 0.95
  },
  {
    "type": "domain",
    "value": "malicious.example.com",
    "context": "Domain used for data exfiltration",
    "confidence": 0.88
  }
]

**Important Notes:**
- Only extract IOCs that are clearly malicious or suspicious
- Provide meaningful context for each IOC
- Use appropriate confidence scores based on IOC clarity
- Return valid JSON format only

**Threat Intelligence Content:**
{content}`;
        showHelpModal('IOC Extraction Prompt', promptContent);
    }



    async function showSigmaHelp() {
        // Remove any existing help modal
        const existingModal = document.getElementById('helpModal');
        if (existingModal) {
            existingModal.remove();
        }
        
        // Find and hide the currently visible modal (the one that opened the help)
        const visibleModals = document.querySelectorAll('#iocsModal, #sigmaRulesModal, #gpt4oRankingModal, #customPromptModal');
        previousModalElement = null;
        
        visibleModals.forEach(modal => {
            if (modal.style.display !== 'none' && modal.offsetParent !== null) {
                modal.style.display = 'none';
                previousModalElement = modal;
            }
        });
        
        // Fetch current prompts from API
        let systemPrompt = "You are a SIGMA rule creation expert. Output ONLY valid YAML starting with 'title:'. Use exact 2-space indentation. logsource and detection must be nested dictionaries. No markdown, no explanations. IMPORTANT: If title or description contains special YAML characters (?, :, [, ], {, }, |, &, *, #, @, `), quote the value with double quotes, e.g., title: \"Rule Title with ?\".";
        let userPrompt = `Generate Sigma detection rules from the following threat intelligence. Produce multiple rules if the behaviors differ.

Threat Intel Input:
- title: {title}
- source: {source}
- url: {url}
- content: {content}

Objectives:
- Extract every distinct behavioral TTP (command execution, process lineage, persistence, defense evasion, system modification).
- Create 1 rule per behavior when possible.
- Extract all command-line patterns with arguments; include all unique process-creation observables.

Strict SIGMA Requirements:
- Focus on behaviors, not atomic IOCs.
- Use correct syntax and required fields.
- Avoid rules for single IPs, hashes, or filenames alone.
- Prefer command-line, parent/child relationships, LOLBins, system changes, scripting engine abuse, lateral movement, etc.
- Use correct logsource for each behavior (process_creation, network_connection, registry_event, file_event, etc.).

Output Rules:
- Output ONLY valid YAML.
- No prose or comments.
- No code fences.
- Start with YAML immediately.
- 2-space indentation only; no tabs.
- All field names lowercase.

Required Structure:
title: [descriptive rule title]
id: [UUID]
description: [behavior detected]
logsource:
  category: [process_creation/network_connection/registry_event/...]
  product: [windows/linux/macos]
detection:
  selection:
    [criteria]
  condition: selection
level: [low/medium/high/critical]
tags:
  - attack.[technique]
references:
  - {url}

Behavioral Extraction Rules:
- For process creation TTPs: include all command-line patterns with args; include parent-child relationships when inferable; include LOLBin/scripting abuse.
- For system modification: include registry, services, scheduled tasks.
- For defense evasion: include AV disablement, AMSI bypass, obfuscation flags.

Final Instruction:
Generate all applicable SIGMA rules from the threat intelligence above.`;
        
        try {
            const response = await fetch('/api/workflow/config/prompts');
            if (response.ok) {
                const data = await response.json();
                if (data.prompts && data.prompts.SigmaAgent) {
                    const sigmaData = data.prompts.SigmaAgent;
                    if (sigmaData.system_prompt) {
                        systemPrompt = sigmaData.system_prompt;
                    }
                    if (sigmaData.prompt) {
                        userPrompt = sigmaData.prompt;
                    }
                }
            }
        } catch (error) {
            console.warn('Failed to fetch prompts from database, using defaults:', error);
        }
        
        const modal = document.createElement('div');
        modal.id = 'helpModal';
        modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-[9999]';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeHelpModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeHelpModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-6 border w-11/12 max-w-6xl shadow-xl rounded-lg bg-gray-800 dark:bg-gray-900 border-gray-700 dark:border-gray-600">
                <div class="flex justify-between items-center mb-5 pb-3 border-b border-gray-700 dark:border-gray-600">
                    <h3 class="text-xl font-semibold text-gray-100 dark:text-white">üîç One Shot - SIGMA Generation Prompt</h3>
                    <button onclick="closeHelpModal()" class="text-gray-400 dark:text-gray-500 hover:text-gray-200 dark:hover:text-gray-300 transition-colors">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-5 text-sm text-gray-300 dark:text-gray-400 bg-gray-700/50 dark:bg-gray-800 p-3 rounded-md border border-gray-700 dark:border-gray-600">
                    <span class="font-semibold text-gray-200 dark:text-gray-300">Prompt Template:</span> Edit the System and User prompts below. Changes are saved to the workflow configuration.
                </div>
                
                <div class="space-y-5">
                    <div>
                        <label class="block text-sm font-semibold text-gray-200 dark:text-gray-300 mb-2">System Prompt</label>
                        <textarea id="sigmaSystemPrompt" class="w-full h-32 p-3 border-2 border-gray-600 dark:border-gray-700 rounded-md font-mono text-sm bg-gray-900 dark:bg-black text-gray-100 dark:text-gray-200 focus:border-blue-500 dark:focus:border-blue-400 focus:ring-2 focus:ring-blue-500/50 dark:focus:ring-blue-400/50 transition-colors" style="resize: vertical;">${escapeHtml(systemPrompt)}</textarea>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-semibold text-gray-200 dark:text-gray-300 mb-2">User Prompt</label>
                        <textarea id="sigmaUserPrompt" class="w-full h-96 p-3 border-2 border-gray-600 dark:border-gray-700 rounded-md font-mono text-sm bg-gray-900 dark:bg-black text-gray-100 dark:text-gray-200 focus:border-blue-500 dark:focus:border-blue-400 focus:ring-2 focus:ring-blue-500/50 dark:focus:ring-blue-400/50 transition-colors" style="resize: vertical;">${escapeHtml(userPrompt)}</textarea>
                    </div>
                </div>
                
                <div class="mt-6 flex justify-end space-x-3 pt-4 border-t border-gray-700 dark:border-gray-600">
                    <button onclick="closeHelpModal()" class="px-5 py-2.5 border-2 border-gray-600 dark:border-gray-700 rounded-md text-sm font-medium text-gray-200 dark:text-gray-300 hover:bg-gray-700 dark:hover:bg-gray-800 hover:border-gray-500 dark:hover:border-gray-600 transition-colors">
                        Cancel
                    </button>
                    <button onclick="saveSigmaPrompts()" class="px-5 py-2.5 bg-blue-600 dark:bg-blue-500 text-white rounded-md text-sm font-medium hover:bg-blue-700 dark:hover:bg-blue-600 shadow-sm hover:shadow transition-all">
                        Save Prompts
                    </button>
                </div>
                
                <div id="sigmaPromptSaveStatus" class="mt-3 text-sm text-gray-300 dark:text-gray-400"></div>
            </div>
        `;
        
        document.body.appendChild(modal);
    }
    
    async function saveSigmaPrompts() {
        const systemPrompt = document.getElementById('sigmaSystemPrompt').value;
        const userPrompt = document.getElementById('sigmaUserPrompt').value;
        const statusDiv = document.getElementById('sigmaPromptSaveStatus');
        
        if (!systemPrompt.trim() || !userPrompt.trim()) {
            statusDiv.innerHTML = '<span class="text-red-600">Both prompts are required.</span>';
            return;
        }
        
        statusDiv.innerHTML = '<span class="text-blue-600">Saving...</span>';
        
        try {
            // First, get current config to preserve other settings
            const getResponse = await fetch('/api/workflow/config');
            if (!getResponse.ok) {
                throw new Error('Failed to fetch current configuration');
            }
            
            const currentConfig = await getResponse.json();
            
            // Update agent_prompts with new SigmaAgent prompts
            const updatedAgentPrompts = currentConfig.agent_prompts || {};
            updatedAgentPrompts.SigmaAgent = {
                system_prompt: systemPrompt,
                prompt: userPrompt
            };
            
            // Update the config
            const updateResponse = await fetch('/api/workflow/config', {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    agent_prompts: updatedAgentPrompts
                })
            });
            
            if (updateResponse.ok) {
                statusDiv.innerHTML = '<span class="text-emerald-400">‚úÖ Prompts saved successfully!</span>';
                setTimeout(() => {
                    closeHelpModal();
                }, 1500);
            } else {
                const errorData = await updateResponse.json();
                throw new Error(errorData.detail || 'Failed to save prompts');
            }
        } catch (error) {
            console.error('Error saving prompts:', error);
            statusDiv.innerHTML = `<span class="text-red-600">Error: ${escapeHtml(error.message)}</span>`;
        }
    }

    function showRankingHelp() {
        const promptContent = `# Telemetry-First SIGMA Huntability Rubric

## Your Role

You are a detection engineer LLM. Your job is to evaluate a piece of threat intelligence (blog, vendor report, advisory) for how readily it maps to low-false-positive, telemetry-driven SIGMA detections and hunt queries.

## Objective

Score content on how directly it produces actionable telemetry observables (command-line, process chains, DNS/proxy patterns, Windows Event IDs, Syslog/auditd events, registry, services, file paths) and how easily a SIGMA rule can be drafted with low FP risk.

## CRITICAL: Atomic IOC Exclusion

**DO NOT award points for atomic IOCs:**
- Single IP addresses
- Single domains (one-off domains)
- File hashes (MD5, SHA1, SHA256)
- Single URLs without behavioral patterns or wildcards

**DO award points for:**
- Domain patterns (DGA patterns, repeated domain structures)
- URL path patterns and query parameter patterns
- Behavioral combinations (domain + path + User-Agent)
- Command-line patterns with variables
- Process chains and execution sequences
- Registry key patterns
- Service name patterns
- File path patterns (not specific files)

**Remember:** Single exact observables = atomic IOCs (no points). Patterns, combinations, and repeatable behaviors = huntable telemetry (award points).

## Scoring Methodology

1. Parse the document and extract candidate observables grouped by telemetry type
2. Assign sub-scores for each category below
3. Multiply each sub-score by its weight to get weighted score
4. Sum all weighted scores to compute raw_score
5. Normalize to 1-10 scale: score = round((raw_score / 21) * 10)
6. Apply behavioral bonuses if applicable

**Max Raw Score:** 21 points (before normalization and bonuses)

**Behavioral Bonuses:**
- **+1 point** if content describes Living-off-the-Land (LotL) usage paired with exact cmdline and parent-child relationships
- **+1 point** if content describes multi-stage chains (recon‚Üíexec‚Üípersistence) that can be chained across log types
- **+1 point** if 2+ independent vendors report similar telemetry (cross-vendor corroboration)

## Scoring Criteria

### Category 1: Process Command-Line and Arguments (Weight: 4, Points: 0-4)

**Data Sources:**
- Windows: Sysmon EventID 1 (Image, CommandLine), Security 4688
- Linux: auditd process events, Syslog
- macOS: Endpoint Security process events, unified logging (log show)
- Cloud: CLI commands in CloudTrail/Activity logs (aws, az, gcloud with parameters)

**Look For:**
- Exact command-line strings with switches/flags
- Evidence of encoded scripts or base64 blobs
- LOTL binaries (bitsadmin, rundll32, certutil) with full paths
- macOS-specific: osascript commands, launchctl usage, security framework calls
- Cloud CLI commands with specific parameters

**Grading:**
- **0:** None or only atomic observables
- **1:** Vague mention of binaries without args ("runs PowerShell", "uses AWS CLI")
- **2:** Partial arguments or generic examples
- **3:** Exact command-lines but limited variety/context
- **4:** Multiple exact command-lines with variables and execution context

### Category 2: Parent‚ÜíChild Process Relationships & Execution Sequences (Weight: 3, Points: 0-3)

**Data Sources:**
- Sysmon process creation (ParentImage ‚Üí Image)
- EDR process ancestry
- Windows Security event chains
- macOS Endpoint Security process chains

**Look For:**
- Explicit parent‚Üíchild pairs with full paths
- Multi-step sequences (3+ hops)
- Unusual parent processes (svchost, explorer) spawning LOTL tools

**Grading:**
- **0:** None
- **1:** Single parent hint mentioned
- **2:** Parent‚Üíchild pairs present
- **3:** Multiple chains or long sequences

### Category 3: Network Telemetry: DNS and Proxy/HTTP Patterns (Weight: 3, Points: 0-3)

**CRITICAL:** Only award points for patterns, combinations, or behavioral indicators. Single exact domains are atomic IOCs and receive 0 points.

**Data Sources:**
- DNS logs (recursive, resolver, passive DNS)
- Proxy logs (URL path, User-Agent, HTTP method)
- Firewall/Proxy metadata

**Look For:**
- Domain patterns (DGA patterns, repeated structures) - NOT single domains
- URL path fragments and uncommon query params (patterns, not single URLs)
- User-Agent anomalies (patterns or behavioral indicators)
- POST to uncommon endpoints (behavioral pattern)
- Combinations: domain pattern + path pattern + User-Agent pattern

**Grading:**
- **0:** None, or only single atomic domains/IPs/URLs (no patterns)
- **1:** Generic domain/URL pattern mentions (e.g., "uses random subdomains")
- **2:** Clear domain patterns (DGA regex patterns) OR URL path patterns OR behavioral combinations
- **3:** Multiple patterns combined: URL+User-Agent+method combos and tunneling indicators

### Category 4: Structured Windows/Linux/macOS Event Mapping (Weight: 3, Points: 0-3)

**Data Sources:**
- Windows Security/Sysmon Event IDs (e.g., 1, 3, 11, 4688, 4698, 4697)
- Linux auditd event types
- macOS unified logging fields
- Cloud: CloudTrail, Azure Activity, GCP Audit event types

**Look For:**
- Explicit EventIDs or log field names
- Field-level references (Image, CommandLine, TargetFilename)
- Correlation-friendly fields (AccountName, SourceIP)
- Cloud API event types and fields

**Grading:**
- **0:** None or only loose references
- **1:** Loose references to logs without specifics
- **2:** EventID or field names present
- **3:** Multiple event mappings with field examples

### Category 5: Persistence, Registry, Services, Scheduled Tasks (Weight: 3, Points: 0-3)

**Data Sources:**
- Windows Registry, Scheduled Tasks, Services events (Sysmon Event IDs 12/13/19/7045, Security 4697)
- Linux systemd, cron entries, auditd
- macOS LaunchDaemons/LaunchAgents, login items, authorization database
- Cloud: IAM roles, SNS topics, Lambda functions (AWS CloudTrail, Azure Activity)

**Look For:**
- Exact registry key patterns and value patterns (not single keys)
- Service name patterns and binary paths
- Cron/Task XML with command patterns or path patterns
- macOS: ~/Library/LaunchAgents, /Library/LaunchDaemons patterns
- Cloud service configuration patterns

**Grading:**
- **0:** None
- **1:** Generic persistence concept mentioned
- **2:** Specific mechanism named but missing exact keys/paths (patterns)
- **3:** Exact registry key patterns, service name patterns, or cron entry patterns

### Category 6: Obfuscation Handling / Value Modifiers Readiness (Weight: 2, Points: 0-2)

**Data Sources:** Any telemetry

**Look For:**
- Base64, URL encoding, chunked strings (patterns)
- Regex-friendly patterns or tokenizable fragments
- Recommendation of |base64offset, |contains, |re modifiers

**Grading:**
- **0:** None or only single encoded values (atomic)
- **1:** Obfuscation mentioned but no transform guidance
- **2:** Exact encoded patterns and recommended modifiers

### Category 7: Evidence Quality & Source Credibility (Weight: 3, Points: 0-3)

**Look For:**
- Primary threat research/vendor telemetry with samples or logs
- Reproducible examples and timestamps
- Cross-vendor corroboration

**Grading:**
- **0:** Unattributed or opinion-based
- **1:** Single vendor without telemetry
- **2:** Vendor report with some telemetry
- **3:** High-quality IR report with logs/snippets and multiple sources

## Scoring Bands (After Normalization)

- **1-2:** Strategic or high-level only. Not suitable for SIGMA without follow-up.
- **3-4:** Too generic. Large analyst work required to make rules.
- **5-6:** Partial huntables. Can produce detection candidates after enrichment.
- **7-8:** Good. Multiple rule-ready observables and low-to-medium FP risk.
- **9-10:** Excellent. Detections can be drafted immediately with low FP risk.

## Output Format

**SIGMA HUNTABILITY SCORE: [1-10]**

**RAW WEIGHTED SCORE: [0-21]** (before normalization)

**CATEGORY BREAKDOWN:**

- **Process Command-Line (0-4, weight 4):** [Score] - [Brief justification, max 20 words]
- **Parent-Child Process (0-3, weight 3):** [Score] - [Brief justification, max 20 words]
- **Network DNS/Proxy Patterns (0-3, weight 3):** [Score] - [Brief justification, max 20 words]
- **Structured Event Mapping (0-3, weight 3):** [Score] - [Brief justification, max 20 words]
- **Persistence/Registry/Services (0-3, weight 3):** [Score] - [Brief justification, max 20 words]
- **Obfuscation Handling (0-2, weight 2):** [Score] - [Brief justification, max 20 words]
- **Source Quality (0-3, weight 3):** [Score] - [Brief justification, max 20 words]

**BEHAVIORAL BONUSES AWARDED:**
[List any bonuses awarded: LotL usage, multi-stage chains, cross-vendor corroboration]

**TOP HUNTABLE OBSERVABLES:**
[List top 5 most actionable observables with exact strings/patterns, noting type: process_cmdline|dns_pattern|registry_pattern|service|event]

**EXAMPLE SIGMA RULE SKELETONS:**
[Provide 1-3 generic SIGMA rule skeletons showing how observables map to detection logic]

**RULE FEASIBILITY:**
[Can rules be written now? Yes/No - platform strengths/limitations]

**FALSE POSITIVE RISK:**
[Low/Medium/High] - [Mitigation steps]

## Multi-Platform Coverage

**Valid SIGMA Data Sources Include:**
- Windows: Event Logs, Sysmon
- Linux: auditd, Syslog
- macOS: Endpoint Security Framework, Unified Logging System, LaunchAgent/LaunchDaemon plists, Gatekeeper/XProtect logs
- Cloud: AWS CloudTrail, Azure Activity Logs, GCP Audit Logs

All platforms are valid. Do not dismiss macOS or cloud content. API calls, service configurations, and command execution are all huntable through structured logs.

## Instructions

Analyze the provided threat intelligence content using this telemetry-first rubric. Focus on behavioral patterns, execution sequences, and repeatable observables that map to structured logs. Ignore atomic IOCs (single IPs, single domains, file hashes). Preserve exact strings when extracting observables, but mark variable parts with placeholders like <hostname>, <username>, <domain>.

When extracting strings, preserve exact punctuation and mark variable parts with placeholders. Recommend value modifiers (|contains, |re, |base64offset) if indicators are encoded/obfuscated.

Please analyze the following content:

**Title:** {title}
**Source:** {source}
**URL:** {url}

**Content:**
{content}`;
        showHelpModal('LLM SIGMA Huntability Analysis Prompt', promptContent, 'LLM');
    }

    function showCustomHelp() {
        const promptContent = `You are a cybersecurity analyst with expertise in threat intelligence analysis. Analyze the provided article content and respond to the user's specific question or request.

**Article Title:** {title}
**Source:** {source}
**URL:** {url}

**Article Content:**
{content}

**User Request:** {user_prompt}

Please provide a detailed analysis based on the article content and the user's specific request. Focus on actionable insights, technical details, and practical recommendations where applicable.`;
        showHelpModal('Custom Prompt Template', promptContent, 'ChatGPT/Claude/Llama');
    }

    // Add syntax highlighting for matched text
    document.addEventListener('DOMContentLoaded', function() {
        
        // Syntax highlighting for matched text
        const matchedTexts = document.querySelectorAll('.font-mono');
        matchedTexts.forEach(element => {
            // Skip pre elements (JSON metadata)
            if (element.tagName === 'PRE') {
                element.style.setProperty('color', '#d1d5db', 'important');
                // Make all text inside light grey
                const allText = element.querySelectorAll('*');
                allText.forEach(el => {
                    el.style.setProperty('color', '#d1d5db', 'important');
                });
                // Also set on the element itself
                const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
                let node;
                while (node = walker.nextNode()) {
                    if (node.parentElement) {
                        node.parentElement.style.setProperty('color', '#d1d5db', 'important');
                    }
                }
                return;
            }
            element.style.backgroundColor = '#c9c7c9';
            element.style.border = '1px solid #f59e0b';
            element.style.color = '#000000';
        });
        
        // Force light grey text on JSON metadata pre element after a short delay
        setTimeout(() => {
            const preElements = document.querySelectorAll('pre[class*="bg-[#0a0e1a]"], pre.bg-\\[\\#0a0e1a\\]');
            preElements.forEach(pre => {
                pre.style.setProperty('color', '#d1d5db', 'important');
                const allElements = pre.querySelectorAll('*');
                allElements.forEach(el => {
                    el.style.setProperty('color', '#d1d5db', 'important');
                });
            });
        }, 100);
        
        // Initialize current article classification in localStorage
        const currentClassification = {{ (article.article_metadata.get("training_category", "") if article.article_metadata else "")|tojson }};
        localStorage.setItem('currentArticleClassification', currentClassification);
        
        // Load existing annotations
    });
    
    const HUNTABILITY_MODE = 'huntability';
    const OBSERVABLE_MODE = 'observables';
    const OBSERVABLE_TYPES = ['CMD', 'PROC_LINEAGE'];
    const OBSERVABLE_DATASET_USAGES = ['train', 'eval', 'gold'];
    const DATASET_USAGE_WARNING_KEY = 'observableDatasetUsageWarningShown';
    const ANNOTATION_STYLE_MAP = {
        huntable: {
            label: 'Huntable',
            highlightClass: 'bg-blue-100 dark:bg-blue-900 border-blue-300 dark:border-blue-700 text-blue-800 dark:text-blue-200'
        },
        not_huntable: {
            label: 'Not Huntable',
            highlightClass: 'bg-red-100 dark:bg-red-900 border-red-300 dark:border-red-700 text-red-800 dark:text-red-200'
        },
        CMD: {
            label: 'CMD',
            highlightClass: 'bg-purple-100 dark:bg-purple-900 border-purple-300 dark:border-purple-700 text-purple-800 dark:text-purple-200'
        },
        PROC_LINEAGE: {
            label: 'Process Lineage',
            highlightClass: 'bg-amber-100 dark:bg-amber-900 border-amber-300 dark:border-amber-600 text-amber-800 dark:text-amber-200'
        }
    };

    // Canonical article text (immutable, from database - before any DOM mutation)
    const CANONICAL_ARTICLE_TEXT = {{ article.content|tojson if article.content else '""' }};

    // Simple Text Management System - Single Source of Truth
    class SimpleTextManager {
        constructor() {
            this.richContentElement = document.getElementById('article-content');
            this.plainContentElement = document.getElementById('article-content-plain');
            this.contentElement = this.richContentElement;
            this.canonicalText = CANONICAL_ARTICLE_TEXT; // immutable buffer for offset calculations
            this.pendingObservableSelection = null; // Stores validated selection when modal opens
            this.userClassifications = new Map();
            this.previousStates = []; // Store previous HTML states for undo
            this.maxUndoStates = 10;
            this.isSubmitting = false; // Prevent duplicate submissions
            this.selectionListenersAttached = false; // Track if selection listeners are attached
            this.selectionTarget = null;
            this.mouseDownHandler = null;
            this.mouseMoveHandler = null;
            this.mouseUpHandler = null;
            this.annotationMode = localStorage.getItem('annotationMode') || HUNTABILITY_MODE;
            this.observableType = localStorage.getItem('observableType') || 'CMD';
            this.observableDatasetUsage = localStorage.getItem('observableDatasetUsage') || 'train';
            this.articleId = {{ article.id|default(0)|int }};
            this.lastObservableAnnotationKey = null;
            this.lastObservableAnnotationAt = 0;
            this.currentModal = null; // Store reference to current modal for reliable closing
            
            // Check localStorage for annotation system state (default: enabled)
            const storedState = localStorage.getItem('annotationsEnabled');
            this.annotationsEnabled = storedState === null ? true : storedState === 'true';
            
            this.init();
        }
        
        init() {
            // Load existing user classifications
            this.loadExistingClassifications();
            
            // Set active content element based on initial mode
            this.setActiveContentElement();
            this.applyContentVisibility();
            
            // Enable user text selection (only if annotations are enabled)
            if (this.annotationsEnabled) {
                this.enableUserSelection();
            }
            
            // Enable keyboard shortcuts
            this.enableKeyboardShortcuts();
            
            // Enable clicking on annotations to remove them
            this.enableAnnotationClicking();
            
            // Update button state
            this.updateToggleButton();
            this.updateModeUI();
        }
        
        updateToggleButton() {
            const btn = document.getElementById('toggle-annotations-btn');
            const icon = document.getElementById('toggle-annotations-icon');
            if (!btn || !icon) return;
            
            if (this.annotationsEnabled) {
                btn.title = 'Disable annotation system';
                btn.classList.remove('opacity-50');
                icon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"></path>';
            } else {
                btn.title = 'Enable annotation system';
                btn.classList.add('opacity-50');
                icon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"></path>';
            }
        }
        
        updateModeUI() {
            const huntabilityBtn = document.getElementById('annotation-mode-huntability');
            const observablesBtn = document.getElementById('annotation-mode-observables');
            const observablePicker = document.getElementById('observable-type-picker');
            const reviewedButton = document.getElementById('mark-observable-reviewed');
            const richContent = this.richContentElement;
            const plainContent = this.plainContentElement;

            if (huntabilityBtn) {
                if (this.annotationMode === HUNTABILITY_MODE) {
                    huntabilityBtn.classList.add('bg-blue-600', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
                    huntabilityBtn.classList.remove('bg-white', 'text-gray-700', 'dark:text-gray-200');
                } else {
                    huntabilityBtn.classList.remove('bg-blue-600', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
                    huntabilityBtn.classList.add('bg-white', 'text-gray-700', 'dark:text-gray-200');
                }
            }

            if (observablesBtn) {
                if (this.annotationMode === OBSERVABLE_MODE) {
                    observablesBtn.classList.add('bg-blue-600', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
                    observablesBtn.classList.remove('bg-white', 'text-gray-700', 'dark:text-gray-200');
                } else {
                    observablesBtn.classList.remove('bg-blue-600', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
                    observablesBtn.classList.add('bg-white', 'text-gray-700', 'dark:text-gray-200');
                }
            }

            if (observablePicker) {
                observablePicker.classList.toggle('hidden', this.annotationMode !== OBSERVABLE_MODE);
            }

            const usagePicker = document.getElementById('observable-usage-picker');
            if (usagePicker) {
                usagePicker.classList.toggle('hidden', this.annotationMode !== OBSERVABLE_MODE);
            }

            if (reviewedButton) {
                reviewedButton.classList.toggle('hidden', this.annotationMode !== OBSERVABLE_MODE);
            }

            this.updateObservableTypeButtons();

            // Ensure only the correct surface is visible and interactive
            this.applyContentVisibility();

            // Toggle content containers
            if (richContent && plainContent) {
                if (this.annotationMode === OBSERVABLE_MODE) {
                    richContent.classList.add('hidden');
                    plainContent.classList.remove('hidden');
                } else {
                    richContent.classList.remove('hidden');
                    plainContent.classList.add('hidden');
                }
            }
        }

        setActiveContentElement() {
            if (this.annotationMode === OBSERVABLE_MODE && this.plainContentElement) {
                this.contentElement = this.plainContentElement;
            } else if (this.richContentElement) {
                this.contentElement = this.richContentElement;
            }
        }

        applyContentVisibility() {
            const richContent = this.richContentElement;
            const plainContent = this.plainContentElement;
            if (!richContent || !plainContent) return;

            // Mark mode on body for CSS-level enforcement
            document.body.dataset.annotationMode = this.annotationMode;
            document.documentElement.dataset.annotationMode = this.annotationMode;

            if (this.annotationMode === OBSERVABLE_MODE) {
                // Force-hide the rich container so legacy spans never bleed through
                richContent.classList.add('hidden');
                richContent.style.setProperty('display', 'none', 'important');
                richContent.style.setProperty('pointer-events', 'none', 'important');
                richContent.style.setProperty('visibility', 'hidden', 'important');
                richContent.style.setProperty('position', 'absolute', 'important');
                richContent.style.setProperty('left', '-99999px', 'important');
                richContent.style.setProperty('height', '1px', 'important');
                richContent.style.setProperty('overflow', 'hidden', 'important');
                richContent.style.setProperty('opacity', '0', 'important');
                richContent.setAttribute('aria-hidden', 'true');
                // Show the plain surface only
                plainContent.classList.remove('hidden');
                plainContent.style.setProperty('display', 'block', 'important');
                plainContent.style.setProperty('pointer-events', 'auto', 'important');
                plainContent.style.setProperty('visibility', 'visible', 'important');
                plainContent.style.removeProperty('position');
                plainContent.style.removeProperty('left');
                plainContent.style.removeProperty('height');
                plainContent.style.removeProperty('overflow');
                plainContent.style.removeProperty('opacity');
                plainContent.removeAttribute('aria-hidden');
                this.contentElement = plainContent;
            } else {
                plainContent.classList.add('hidden');
                plainContent.style.setProperty('display', 'none', 'important');
                plainContent.style.setProperty('pointer-events', 'none', 'important');
                plainContent.style.setProperty('visibility', 'hidden', 'important');
                plainContent.style.setProperty('position', 'absolute', 'important');
                plainContent.style.setProperty('left', '-99999px', 'important');
                plainContent.style.setProperty('height', '1px', 'important');
                plainContent.style.setProperty('overflow', 'hidden', 'important');
                plainContent.style.setProperty('opacity', '0', 'important');
                plainContent.setAttribute('aria-hidden', 'true');
                richContent.classList.remove('hidden');
                richContent.style.setProperty('display', 'block', 'important');
                richContent.style.setProperty('pointer-events', 'auto', 'important');
                richContent.style.setProperty('visibility', 'visible', 'important');
                richContent.style.removeProperty('position');
                richContent.style.removeProperty('left');
                richContent.style.removeProperty('height');
                richContent.style.removeProperty('overflow');
                richContent.style.removeProperty('opacity');
                richContent.removeAttribute('aria-hidden');
                this.contentElement = richContent;
            }
        }

        updateObservableTypeButtons() {
            OBSERVABLE_TYPES.forEach(type => {
                const button = document.querySelector(`[data-observable-type="${type}"]`);
                if (button) {
                    if (this.observableType === type) {
                        button.classList.add('bg-[#4b4e77]', 'text-white');
                        button.classList.remove('bg-white', 'text-gray-700');
                    } else {
                        button.classList.remove('bg-[#4b4e77]', 'text-white');
                        button.classList.add('bg-white', 'text-gray-700');
                    }
                }
            });
        }

        setAnnotationMode(mode) {
            if (![HUNTABILITY_MODE, OBSERVABLE_MODE].includes(mode)) {
                return;
            }
            this.annotationMode = mode;
            localStorage.setItem('annotationMode', mode);
            this.updateModeUI();
            this.setActiveContentElement();
            this.applyContentVisibility();
            this.detachSelectionListeners();
            this.enableUserSelection();
            showNotification(`Switched to ${mode === HUNTABILITY_MODE ? 'Huntability' : 'Observables'} mode`, 'info');
        }

        setObservableType(type) {
            if (!OBSERVABLE_TYPES.includes(type)) {
                return;
            }
            this.observableType = type;
            localStorage.setItem('observableType', type);
            this.updateObservableTypeButtons();
            showNotification(`Observable type set to ${type}`, 'info');
        }

        setObservableDatasetUsage(usage) {
            const normalized = (usage || '').toLowerCase();
            if (!OBSERVABLE_DATASET_USAGES.includes(normalized)) {
                return;
            }
            this.observableDatasetUsage = normalized;
            localStorage.setItem('observableDatasetUsage', normalized);
            updateDatasetUsageButtons();
            if (normalized !== 'train') {
                showDatasetUsageWarningOnce();
            }
        }
        
        enableAnnotations() {
            this.annotationsEnabled = true;
            localStorage.setItem('annotationsEnabled', 'true');
            // Reset flag to allow re-attaching listeners
            this.selectionListenersAttached = false;
            this.enableUserSelection();
            this.updateToggleButton();
        }
        
        disableAnnotations() {
            this.annotationsEnabled = false;
            localStorage.setItem('annotationsEnabled', 'false');
            // Clear any active selection
            window.getSelection().removeAllRanges();
            // Hide any open annotation menus
            const menus = document.querySelectorAll('.annotation-menu');
            menus.forEach(menu => menu.remove());
            // Remove native selection handler if it exists
            if (this.nativeSelectionHandler) {
                document.removeEventListener('mouseup', this.nativeSelectionHandler);
                this.nativeSelectionHandler = null;
            }
            // Reset flag so listeners can be re-attached when re-enabled
            this.selectionListenersAttached = false;
            this.updateToggleButton();
        }
        
        async loadExistingClassifications() {
            try {
                // Loading existing classifications for article {{ article.id }}
                const response = await fetch(`/api/articles/{{ article.id }}/annotations`);
                const data = await response.json();
                
                // API response received
                
                if (data.success && data.annotations) {
                    // Found ${data.annotations.length} existing annotations
                    
                    // Wait a bit for the page to fully load before adding annotations
                    setTimeout(() => {
                        data.annotations.forEach(annotation => {
                            // Loading annotation: ${annotation.annotation_type}
                            this.addExistingClassification(
                                annotation.start_position,
                                annotation.end_position,
                                annotation.annotation_type,
                                annotation.selected_text
                            );
                        });
                    }, 100);
                } else {
                    // No existing annotations found
                }
            } catch (error) {
                console.error('Failed to load existing classifications:', error);
            }
        }
        
        addExistingClassification(start, end, classification, text) {
            // Do not render existing highlights on the plain observables surface
            if (this.annotationMode === OBSERVABLE_MODE) {
                return;
            }
            // Checking existing annotation: ${classification}
            
            // Check if this text is already highlighted by looking for spans with our classes
            const existingSpans = this.contentElement.querySelectorAll(`span[data-annotation-type="${classification}"]`);
            let alreadyHighlighted = false;
            
            for (const span of existingSpans) {
                // Check if this span contains our text (or vice versa for partial matches)
                const spanText = span.textContent.trim();
                const searchText = text.trim();
                
                // More precise matching - check if the span text matches our annotation text
                if (spanText === searchText || spanText.includes(searchText)) {
                    alreadyHighlighted = true;
                    console.log(`Text already highlighted in span: "${spanText.substring(0, 50)}..."`);
                    break;
                }
            }
            
            if (!alreadyHighlighted) {
                console.log('Text not yet highlighted, adding annotation');
                this.addUserClassification(start, end, classification, text);
            } else {
                console.log('Skipping duplicate annotation');
            }
        }
        
        addUserClassification(start, end, classification, text) {
            // Keep observables plain surface unmutated
            if (this.annotationMode === OBSERVABLE_MODE && this.contentElement === this.plainContentElement) {
                return;
            }
            console.log(`Attempting to add ${classification} classification for: "${text.substring(0, 100)}..."`);
            console.log(`Text length: ${text.length}, Start: ${start}, End: ${end}`);
            
            // Always use position-based highlighting to avoid text duplication issues
            // The text-based replacement was causing duplication when the same text appeared multiple times
            console.log('Using position-based highlighting to prevent text duplication');
            this.highlightTextAtPosition(start, end, classification, text);
        }
        
        highlightTextAtPosition(start, end, classification, text) {
            console.log('Using position-based highlighting:', { start, end, textLength: text.length });
            
            // Create a range to select the text at the exact position
            const range = document.createRange();
            const walker = document.createTreeWalker(
                this.contentElement,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let currentPos = 0;
            let startNode = null;
            let startOffset = 0;
            let endNode = null;
            let endOffset = 0;
            
            // Find the text nodes that contain our selection
            let node;
            while (node = walker.nextNode()) {
                const nodeLength = node.textContent.length;
                
                if (!startNode && currentPos + nodeLength >= start) {
                    startNode = node;
                    startOffset = start - currentPos;
                }
                
                if (!endNode && currentPos + nodeLength >= end) {
                    endNode = node;
                    endOffset = end - currentPos;
                    break;
                }
                
                currentPos += nodeLength;
            }
            
            if (startNode && endNode) {
                try {
                    range.setStart(startNode, startOffset);
                    range.setEnd(endNode, endOffset);
                    
                    // Create highlight span
                    const style = this.getTypeStyle(classification);
                    const highlightSpan = document.createElement('span');
                    highlightSpan.className = `px-1 py-0.5 rounded text-xs font-medium border ${style.highlightClass}`;
                    highlightSpan.title = `${style.label}: ${text.substring(0, 50)}...`;
                    highlightSpan.dataset.annotationType = classification;
                    highlightSpan.textContent = text;
                    
                    // Replace the range content with our highlight span
                    range.deleteContents();
                    range.insertNode(highlightSpan);
                    
                    console.log('Position-based highlighting successful');
                    
                    // Save state for undo
                    this.saveState();
                    
                } catch (error) {
                    console.error('Error in position-based highlighting:', error);
                    // Fallback: just add a visual indicator
                    this.addVisualIndicator(start, end, classification, text);
                }
            } else {
                console.error('Could not find text nodes for position-based highlighting');
                this.addVisualIndicator(start, end, classification, text);
            }
        }
        
        addVisualIndicator(start, end, classification, text) {
            console.log('Adding visual indicator as last resort');
            
            // Create a simple visual indicator at the top of the content
            const indicator = document.createElement('div');
            const style = this.getTypeStyle(classification);
            let containerClass = 'bg-gray-50 border-gray-400';
            let textClass = 'text-gray-800';
            if (classification === 'huntable') {
                containerClass = 'bg-blue-50 border-blue-400';
                textClass = 'text-blue-800';
            } else if (classification === 'not_huntable') {
                containerClass = 'bg-red-50 border-red-400';
                textClass = 'text-red-800';
            } else if (classification === 'CMD') {
                containerClass = 'bg-purple-50 border-purple-400';
                textClass = 'text-purple-800';
            } else if (classification === 'PROC_LINEAGE') {
                containerClass = 'bg-amber-50 border-amber-400';
                textClass = 'text-amber-800';
            }
            indicator.className = `p-2 mb-2 rounded border-l-4 ${containerClass}`;
            indicator.innerHTML = `
                <div class="text-sm font-medium ${textClass}">
                    ${style.label} Text Annotated
                </div>
                <div class="text-xs text-gray-600 mt-1">
                    "${text.substring(0, 100)}${text.length > 100 ? '...' : ''}"
                </div>
            `;
            
            // Insert at the beginning of the content
            this.contentElement.insertBefore(indicator, this.contentElement.firstChild);
            
            // Save state for undo
            this.saveState();
        }
        
        addLongTextClassification(start, end, classification, text) {
            // For very long text, try to highlight multiple parts of it
            const style = this.getTypeStyle(classification);
            
            // Get the current HTML content
            const content = this.contentElement.innerHTML;
            
            // Try to highlight the first 500 characters and add an indicator
            const shortText = text.substring(0, Math.min(500, text.length));
            const highlightSpan = `<span class="px-1 py-0.5 rounded text-xs font-medium border ${style.highlightClass}" data-annotation-type="${classification}" title="${style.label}: Long selection (${text.length} chars)">${shortText}${text.length > 500 ? '...' : ''}</span>`;
            
            // Try to find and replace the text
            if (content.includes(shortText)) {
                let newContent = content.replace(shortText, highlightSpan);
                
                // Also try to highlight the end of the selection if it's very long
                if (text.length > 1000) {
                    const endText = text.substring(text.length - 100);
                    const endHighlightSpan = `<span class="px-1 py-0.5 rounded text-xs font-medium border ${style.highlightClass}" data-annotation-type="${classification}" title="End of long ${style.label} selection">...${endText}</span>`;
                    
                    if (newContent.includes(endText) && !newContent.includes(endHighlightSpan)) {
                        newContent = newContent.replace(endText, endHighlightSpan);
                    }
                }
                
                this.contentElement.innerHTML = newContent;
                console.log(`Added ${classification} highlight for long text selection (${text.length} chars)`);
            } else {
                // Fallback to shorter text
                const veryShortText = text.substring(0, Math.min(100, text.length));
                if (content.includes(veryShortText)) {
                    const shortHighlightSpan = `<span class="px-1 py-0.5 rounded text-xs font-medium border ${style.highlightClass}" data-annotation-type="${classification}" title="${style.label}: Long selection (${text.length} chars)">${veryShortText}...</span>`;
                    const newContent = content.replace(veryShortText, shortHighlightSpan);
                    this.contentElement.innerHTML = newContent;
                    console.log(`Added ${classification} highlight for part of long text selection`);
                } else {
                    console.log(`Could not find text for long selection highlighting`);
                }
            }
        }
        
        saveState() {
            // Save current HTML state for undo functionality
            this.previousStates.push(this.contentElement.innerHTML);
            
            // Keep only the last maxUndoStates
            if (this.previousStates.length > this.maxUndoStates) {
                this.previousStates.shift();
            }
        }
        
        async undo() {
            if (this.previousStates.length > 0) {
                const previousState = this.previousStates.pop();
                this.contentElement.innerHTML = previousState;
                
                // Delete the last annotation from database
                try {
                    const response = await fetch(`/api/articles/{{ article.id }}/annotations`, {
                        method: 'GET'
                    });
                    const data = await response.json();
                    
                    if (data.success && data.annotations.length > 0) {
                        // Get the most recent annotation (highest ID)
                        const lastAnnotation = data.annotations.reduce((prev, current) => 
                            (prev.id > current.id) ? prev : current
                        );
                        
                        // Delete it from database
                        const deleteResponse = await fetch(`/api/articles/{{ article.id }}/annotations/${lastAnnotation.id}`, {
                            method: 'DELETE'
                        });
                        
                        if (deleteResponse.ok) {
                            console.log(`Undid last classification and removed annotation ID ${lastAnnotation.id} from database`);
                        } else {
                            console.error('Failed to remove annotation from database');
                        }
                    }
                } catch (error) {
                    console.error('Error removing annotation from database:', error);
                }
                
                console.log('Undid last classification');
                return true;
            } else {
                console.log('No previous states to undo');
                return false;
            }
        }
        
        
        enableKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ctrl+Z for undo
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    this.undo();
                }
            });
        }
        
        enableAnnotationClicking() {
            // Use event delegation to handle clicks on annotation spans
            // Always bind to current contentElement; if switching surfaces, remove old listener first
            if (this.annotationClickHandler && this.contentElement) {
                this.contentElement.removeEventListener('click', this.annotationClickHandler);
            }
            this.annotationClickHandler = (e) => {
                // Check if clicked element is an annotation span
                const clickedSpan = e.target.closest('span.px-1.py-0\\.5.rounded.text-xs.font-medium.border');
                
                if (clickedSpan) {
                    const annotationType = clickedSpan.dataset.annotationType;
                    if (!annotationType) return;
                    e.preventDefault();
                    e.stopPropagation();
                    const annotationText = clickedSpan.textContent;
                    this.showRemoveAnnotationModal(clickedSpan, annotationType, annotationText);
                }
            };
            this.contentElement.addEventListener('click', this.annotationClickHandler);
        }

        detachSelectionListeners() {
            if (this.selectionTarget && this.mouseDownHandler) {
                this.selectionTarget.removeEventListener('mousedown', this.mouseDownHandler);
            }
            if (this.selectionTarget && this.mouseMoveHandler) {
                this.selectionTarget.removeEventListener('mousemove', this.mouseMoveHandler);
            }
            if (this.selectionTarget && this.mouseUpHandler) {
                this.selectionTarget.removeEventListener('mouseup', this.mouseUpHandler);
            }
            if (this.nativeSelectionHandler) {
                document.removeEventListener('mouseup', this.nativeSelectionHandler);
                this.nativeSelectionHandler = null;
            }
            this.mouseDownHandler = null;
            this.mouseMoveHandler = null;
            this.mouseUpHandler = null;
            this.selectionTarget = null;
            this.selectionListenersAttached = false;
        }
        
        enableUserSelection() {
            if (!this.annotationsEnabled) return;
            
            const target = this.annotationMode === OBSERVABLE_MODE ? this.plainContentElement : this.richContentElement;
            if (!target) return;
            // Disable selection entirely on the non-active surface to prevent ghost highlights
            const inactive = this.annotationMode === OBSERVABLE_MODE ? this.richContentElement : this.plainContentElement;
            if (inactive) {
                inactive.style.setProperty('user-select', 'none', 'important');
            }
            target.style.removeProperty('user-select');

            // Prevent duplicate listeners on the same target
            if (this.selectionListenersAttached && this.selectionTarget === target) return;
            // If switching targets, detach old listeners first
            if (this.selectionTarget && this.selectionTarget !== target) {
                this.detachSelectionListeners();
            }
            this.selectionListenersAttached = true;
            this.selectionTarget = target;
            
            let isSelecting = false;
            let startPos = null;
            let endPos = null;
            
            this.mouseDownHandler = (e) => {
                if (!this.annotationsEnabled) return;
                isSelecting = true;
                startPos = this.getTextPositionFromEvent(e);
            };
            
            this.mouseMoveHandler = (e) => {
                if (!this.annotationsEnabled) return;
                if (isSelecting) {
                    endPos = this.getTextPositionFromEvent(e);
                    this.showSelectionPreview(startPos, endPos);
                }
            };
            
            this.mouseUpHandler = (e) => {
                if (!this.annotationsEnabled) return;
                if (isSelecting) {
                    isSelecting = false;
                    
                    // For observables: use strict validation only (no fallbacks)
                    if (this.annotationMode === OBSERVABLE_MODE) {
                        const validatedSelection = this.validateAndExtractObservableSelection();
                        if (validatedSelection) {
                            this.showObservableModal(
                                validatedSelection.selectedText,
                                validatedSelection.start,
                                validatedSelection.end
                            );
                        }
                        // If validation fails, error already shown
                        return;
                    }
                    
                    // For huntability: continue with existing logic (allows fallbacks)
                    const selection = window.getSelection();
                    const selectedText = selection ? selection.toString().trim() : '';
                    if (selection && selectedText.length > 0) {
                        try {
                            const range = selection.getRangeAt(0);
                            const withinContent = this.contentElement.contains(range.commonAncestorContainer);
                            if (withinContent) {
                                const selectionStart = this.getTextPositionFromRange(
                                    range.startContainer,
                                    range.startOffset
                                );
                                const selectionEnd = this.getTextPositionFromRange(
                                    range.endContainer,
                                    range.endOffset
                                );
                                this.showClassificationOptions(selectionStart, selectionEnd);
                                return;
                            }
                        } catch (error) {
                            console.error('Error processing selection range on mouseup:', error);
                        }
                    }

                    // Fallback: use pointer-based offsets (huntability only, can be imprecise on touch/mobile).
                    endPos = this.getTextPositionFromEvent(e);
                    this.showClassificationOptions(startPos ?? 0, endPos ?? 0);
                }
            };

            target.addEventListener('mousedown', this.mouseDownHandler);
            target.addEventListener('mousemove', this.mouseMoveHandler);
            target.addEventListener('mouseup', this.mouseUpHandler);
            
            // Also listen for native text selection events (as backup)
            // For observables: use strict validation, no fallbacks
            this.nativeSelectionHandler = (e) => {
                if (!this.annotationsEnabled) return;
                // Observables rely solely on the content mouseup handler to avoid parallel selection handlers
                if (this.annotationMode === OBSERVABLE_MODE) return;
                // Only handle if the click was within our content area
                if (this.contentElement.contains(e.target)) {
                    setTimeout(() => {
                        // Skip if we're currently updating the selection programmatically
                        if (this.isUpdatingSelection) {
                            console.log('Skipping native selection handler - programmatic update in progress');
                            return;
                        }
                        
                        // For observables: use strict validation (no fallbacks)
                        if (this.annotationMode === OBSERVABLE_MODE) {
                            const validatedSelection = this.validateAndExtractObservableSelection();
                            if (validatedSelection) {
                                this.showObservableModal(
                                    validatedSelection.selectedText,
                                    validatedSelection.start,
                                    validatedSelection.end
                                );
                            }
                            // If validation fails, error already shown, just return
                            return;
                        }
                        
                        // For huntability: continue with existing logic (allows fallbacks)
                        const selection = window.getSelection();
                        const selectedText = selection ? selection.toString().trim() : '';
                        
                        if (selectedText.length > 0) {
                            console.log('Native selection detected:', {
                                text: selectedText.substring(0, 100),
                                fullLength: selectedText.length
                            });
                            
                            try {
                                const range = selection.getRangeAt(0);
                                const startPos = this.getTextPositionFromRange(range.startContainer, range.startOffset);
                                const endPos = this.getTextPositionFromRange(range.endContainer, range.endOffset);
                                
                                if (startPos !== endPos && endPos - startPos === selectedText.length) {
                                    console.log('Position calculation successful:', {
                                        start: startPos,
                                        end: endPos,
                                        calculatedLength: endPos - startPos,
                                        actualLength: selectedText.length
                                    });
                                    this.showClassificationOptions(startPos, endPos);
                                } else {
                                    console.log('Position calculation mismatch, using fallback');
                                    // Fallback: try to find the text in the content (huntability only)
                                    const contentText = this.contentElement.textContent;
                                    const textIndex = contentText.indexOf(selectedText);
                                    if (textIndex !== -1) {
                                        this.showClassificationOptions(textIndex, textIndex + selectedText.length);
                                    }
                                }
                            } catch (error) {
                                console.error('Error processing native selection:', error);
                                // Fallback: try to find the text in the content (huntability only)
                                const contentText = this.contentElement.textContent;
                                const textIndex = contentText.indexOf(selectedText);
                                if (textIndex !== -1) {
                                    this.showClassificationOptions(textIndex, textIndex + selectedText.length);
                                }
                            }
                        }
                    }, 50);
                }
            };
            
            document.addEventListener('mouseup', this.nativeSelectionHandler);
        }
        
        getTextPositionFromEvent(e) {
            const range = document.caretRangeFromPoint(e.clientX, e.clientY);
            if (!range) return 0;
            
            // Find the character position in the text content (ignoring HTML)
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(this.contentElement);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            
            return preCaretRange.toString().length;
        }
        
        getTextPositionFromRange(container, offset) {
            // Handle element nodes by finding the actual text node
            let textNode = container;
            let textOffset = offset;
            
            if (container.nodeType !== Node.TEXT_NODE) {
                // Create a collapsed range to find the text node
                const tempRange = document.createRange();
                tempRange.setStart(container, Math.min(offset, container.childNodes.length));
                tempRange.collapse(true);
                textNode = tempRange.startContainer;
                textOffset = tempRange.startOffset;
                
                // If still not a text node, walk to find it
                if (textNode.nodeType !== Node.TEXT_NODE) {
                    const walker = document.createTreeWalker(
                        textNode,
                        NodeFilter.SHOW_TEXT,
                        null,
                        false
                    );
                    const firstTextNode = walker.nextNode();
                    if (firstTextNode) {
                        textNode = firstTextNode;
                        textOffset = 0;
                    }
                }
            }
            
            // Walk text nodes from start of content to calculate position
            const walker = document.createTreeWalker(
                this.contentElement,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let position = 0;
            let node;
            while ((node = walker.nextNode())) {
                if (node === textNode) {
                    return position + Math.min(textOffset, node.textContent.length);
                }
                position += node.textContent.length;
            }
            
            // Fallback: use range.toString() if walker didn't find it
            const range = document.createRange();
            range.setStart(this.contentElement, 0);
            range.setEnd(container, offset);
            return range.toString().length;
        }
        
        showSelectionPreview(start, end) {
            // Clear previous preview
            this.clearSelectionPreview();
            
            if (start === end) return;
            
            const min = Math.min(start, end);
            const max = Math.max(start, end);
            
            const preview = document.createElement('div');
            preview.className = 'absolute bg-yellow-200 bg-opacity-50 border border-yellow-400';
            preview.id = 'selection-preview';
            
            try {
                // Create a range based on text content positions
                const range = document.createRange();
                const textContent = this.contentElement.textContent;
                
                // Find the text nodes that contain our selection
                const walker = document.createTreeWalker(
                    this.contentElement,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );
                
                let currentPos = 0;
                let startNode = null;
                let endNode = null;
                let startOffset = 0;
                let endOffset = 0;
                
                while (walker.nextNode()) {
                    const textNode = walker.currentNode;
                    const nodeLength = textNode.textContent.length;
                    
                    if (!startNode && currentPos + nodeLength >= min) {
                        startNode = textNode;
                        startOffset = min - currentPos;
                    }
                    
                    if (!endNode && currentPos + nodeLength >= max) {
                        endNode = textNode;
                        endOffset = max - currentPos;
                        break;
                    }
                    
                    currentPos += nodeLength;
                }
                
                if (startNode && endNode) {
                    range.setStart(startNode, startOffset);
                    range.setEnd(endNode, endOffset);
                    
                    const rect = range.getBoundingClientRect();
                    const containerRect = this.contentElement.getBoundingClientRect();
                    
                    preview.style.left = `${rect.left - containerRect.left}px`;
                    preview.style.top = `${rect.top - containerRect.top}px`;
                    preview.style.width = `${rect.width}px`;
                    preview.style.height = `${rect.height}px`;
                    
                    this.contentElement.appendChild(preview);
                }
            } catch (error) {
                console.error('Error showing selection preview:', error);
            }
        }
        
        clearSelectionPreview() {
            const preview = document.getElementById('selection-preview');
            if (preview) {
                preview.remove();
            }
        }
        
        /**
         * Validate and extract observable selection with strict rules.
         * Returns exact selection: no expansion, no trimming, no guessing.
         * Returns null if validation fails.
         */
        validateAndExtractObservableSelection() {
            const selection = window.getSelection();
            
            // Validation: Must exist and have exactly one contiguous range
            if (!selection || selection.rangeCount === 0) {
                showNotification('No selection found. Please highlight text.', 'error');
                return null;
            }
            
            if (selection.rangeCount !== 1) {
                showNotification('Multiple selections detected. Please select a single contiguous range.', 'error');
                return null;
            }
            
            const originalRange = selection.getRangeAt(0);
            const content = this.contentElement;
            
            // Validation: Must exist and be non-empty
            if (!originalRange || originalRange.collapsed) {
                showNotification('Selection is empty. Please highlight text.', 'error');
                return null;
            }
            
            // Clamp selection strictly inside the article content (no expansion beyond boundaries)
            const contentRange = document.createRange();
            contentRange.selectNodeContents(content);
            const clampedRange = originalRange.cloneRange();
            if (originalRange.compareBoundaryPoints(Range.START_TO_START, contentRange) < 0) {
                clampedRange.setStart(contentRange.startContainer, contentRange.startOffset);
            }
            if (originalRange.compareBoundaryPoints(Range.END_TO_END, contentRange) > 0) {
                clampedRange.setEnd(contentRange.endContainer, contentRange.endOffset);
            }
            if (clampedRange.collapsed) {
                showNotification('Selection must be within the article content.', 'error');
                return null;
            }

            // Exact selected text from clamped DOM range (no trimming)
            const selectedText = clampedRange.toString();
            if (!selectedText || selectedText.length === 0) {
                showNotification('Selection is empty. Please highlight text.', 'error');
                return null;
            }
            
            const canonical = this.canonicalText || '';
            
            // Resolve boundaries to concrete text nodes inside the clamped range
            const startBoundary = this.resolveBoundaryToText(clampedRange.startContainer, clampedRange.startOffset, true);
            const endBoundary = this.resolveBoundaryToText(clampedRange.endContainer, clampedRange.endOffset, false);
            
            if (!startBoundary || !endBoundary) {
                showNotification('Selection must be within the article content.', 'error');
                return null;
            }
            
            // Walk text nodes to compute absolute offsets against the canonical text
            const computeOffsetFromBoundary = (boundary) => {
                const walker = document.createTreeWalker(
                    this.contentElement,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );
                
                let pos = 0;
                let node;
                while ((node = walker.nextNode())) {
                    if (node === boundary.node) {
                        return pos + Math.min(boundary.offset, node.textContent.length);
                    }
                    pos += node.textContent.length;
                }
                return null;
            };

            const startOffset = computeOffsetFromBoundary(startBoundary);
            const endOffset = computeOffsetFromBoundary(endBoundary);

            if (startOffset === null || endOffset === null) {
                showNotification('Selection must be within the article content.', 'error');
                return null;
            }

            const orderedStart = Math.min(startOffset, endOffset);
            const orderedEnd = Math.max(startOffset, endOffset);

            if (orderedStart === orderedEnd) {
                showNotification('Selection is empty. Please highlight text.', 'error');
                return null;
            }

            if (orderedStart < 0 || orderedEnd > canonical.length) {
                showNotification('Invalid selection range. Please try again.', 'error');
                return null;
            }

            const canonicalSlice = canonical.substring(orderedStart, orderedEnd);
            if (canonicalSlice !== selectedText) {
                console.error('Canonical slice mismatch for selection', {
                    selectedPreview: selectedText.substring(0, 100),
                    canonicalPreview: canonicalSlice.substring(0, 100),
                    start: orderedStart,
                    end: orderedEnd
                });
                showNotification('Selection mismatch. Please re-select the exact text.', 'error');
                return null;
            }

            return {
                start: orderedStart,
                end: orderedEnd,
                selectedText: selectedText, // exact user-highlighted text
                range: originalRange.cloneRange() // Clone for later use
            };
        }

        /**
         * Calculate absolute start/end offsets for a range using rendered DOM text.
         * Walks text nodes from the start of the article content without mutating the DOM.
         */
        calculateOffsetsFromRange(range) {
            try {
                const walker = document.createTreeWalker(
                    this.contentElement,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );

                let currentPos = 0;
                let startOffset = null;
                let endOffset = null;
                let node;

                while ((node = walker.nextNode())) {
                    const len = node.textContent.length;

                    if (node === range.startContainer) {
                        startOffset = currentPos + Math.min(range.startOffset, len);
                    }
                    if (node === range.endContainer) {
                        endOffset = currentPos + Math.min(range.endOffset, len);
                    }

                    currentPos += len;
                }

                if (startOffset === null || endOffset === null) {
                    return null;
                }

                return { startOffset, endOffset };
            } catch (error) {
                console.error('Failed to calculate offsets from range:', error);
                return null;
            }
        }

        resolveBoundaryToText(node, offset, preferStart) {
            if (!node || !this.contentElement.contains(node)) return null;
            
            // Text node: clamp offset
            if (node.nodeType === Node.TEXT_NODE) {
                return { node, offset: Math.min(offset, node.textContent.length) };
            }
            
            // Element boundary: offset refers to child index
            const children = node.childNodes;
            if (!children || children.length === 0) {
                return null;
            }
            
            if (preferStart) {
                // Start boundary: find first text descendant at/after offset
                for (let i = offset; i < children.length; i++) {
                    const textNode = this.findFirstTextDescendant(children[i], true);
                    if (textNode) return { node: textNode, offset: 0 };
                }
                // Fallback: search before offset
                for (let i = offset - 1; i >= 0; i--) {
                    const textNode = this.findFirstTextDescendant(children[i], true);
                    if (textNode) return { node: textNode, offset: 0 };
                }
            } else {
                // End boundary: find last text descendant before offset
                for (let i = Math.min(offset - 1, children.length - 1); i >= 0; i--) {
                    const textNode = this.findFirstTextDescendant(children[i], false);
                    if (textNode) return { node: textNode, offset: textNode.textContent.length };
                }
                // Fallback: search after offset
                for (let i = offset; i < children.length; i++) {
                    const textNode = this.findFirstTextDescendant(children[i], false);
                    if (textNode) return { node: textNode, offset: textNode.textContent.length };
                }
            }
            
            return null;
        }

        orderBoundaries(nodeA, offsetA, nodeB, offsetB) {
            const position = nodeA.compareDocumentPosition(nodeB);
            if (
                position & Node.DOCUMENT_POSITION_FOLLOWING ||
                (nodeA === nodeB && offsetA <= offsetB)
            ) {
                return {
                    start: { node: nodeA, offset: Math.min(offsetA, nodeA.textContent.length) },
                    end: { node: nodeB, offset: Math.min(offsetB, nodeB.textContent.length) }
                };
            }
            return {
                start: { node: nodeB, offset: Math.min(offsetB, nodeB.textContent.length) },
                end: { node: nodeA, offset: Math.min(offsetA, nodeA.textContent.length) }
            };
        }
        
        getOffsetWithPrefix(container, offset) {
            try {
                const prefixRange = document.createRange();
                prefixRange.setStart(this.contentElement, 0);
                prefixRange.setEnd(container, offset);
                return prefixRange.toString().length;
            } catch (e) {
                console.error('Prefix range offset failed:', e);
                return null;
            }
        }

        findFirstTextDescendant(node, forward = true) {
            if (!node || !this.contentElement.contains(node)) return null;
            
            if (node.nodeType === Node.TEXT_NODE && node.textContent.length > 0) {
                return node;
            }
            
            const children = node.childNodes;
            if (!children || children.length === 0) return null;
            
            if (forward) {
                for (let i = 0; i < children.length; i++) {
                    const found = this.findFirstTextDescendant(children[i], true);
                    if (found) return found;
                }
            } else {
                for (let i = children.length - 1; i >= 0; i--) {
                    const found = this.findFirstTextDescendant(children[i], false);
                    if (found) return found;
                }
            }
            
            return null;
        }

        normalizeSelectionToContent(startPos, endPos) {
            // Try to get selection from DOM first
            const selection = window.getSelection();
            if (selection && selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                
                // Ensure selection is within article content
                if (this.contentElement.contains(range.startContainer) && 
                    this.contentElement.contains(range.endContainer)) {
                    
                    const start = this.getTextPositionFromRange(range.startContainer, range.startOffset);
                    const end = this.getTextPositionFromRange(range.endContainer, range.endOffset);
                    
                    if (start < end) {
                        const fullText = this.contentElement.textContent;
                        const selectedText = fullText.substring(start, end);
                        
                        if (selectedText.trim()) {
                            return {
                                min: start,
                                max: end,
                                selectedText: selectedText
                            };
                        }
                    }
                }
            }
            
            // Fallback to provided positions if DOM selection unavailable
            if (startPos !== undefined && endPos !== undefined && startPos < endPos) {
                const fullText = this.contentElement.textContent;
                if (endPos <= fullText.length) {
                    const selectedText = fullText.substring(startPos, endPos);
                    if (selectedText.trim()) {
                        return {
                            min: startPos,
                            max: endPos,
                            selectedText: selectedText
                        };
                    }
                }
            }
            
            return null;
        }
        
        showClassificationOptions(start, end) {
            this.clearSelectionPreview();
            
            if (start === end) return;
            
            // For observables: use strict validation and exact extraction
            if (this.annotationMode === OBSERVABLE_MODE) {
                const observableSelection = this.validateAndExtractObservableSelection();
                if (!observableSelection) {
                    // Validation failed, error already shown
                    return;
                }
                
                // Use exact selection - no modification
                this.showObservableModal(
                    observableSelection.selectedText,
                    observableSelection.start,
                    observableSelection.end
                );
                return;
            }
            
            // For huntability: continue using normalization (allows expansion)
            const normalized = this.normalizeSelectionToContent(start, end);
            if (!normalized) {
                console.warn('Could not normalize selection to article content');
                return;
            }
            let { min, max, selectedText } = normalized;

            // Prefer the live DOM selection if present to avoid offset drift
            const selection = window.getSelection();
            if (selection && selection.rangeCount > 0 && selection.toString().trim().length > 0) {
                try {
                    const range = selection.getRangeAt(0);
                    if (this.contentElement.contains(range.startContainer) && this.contentElement.contains(range.endContainer)) {
                        const selStart = this.getTextPositionFromRange(range.startContainer, range.startOffset);
                        const selEnd = this.getTextPositionFromRange(range.endContainer, range.endOffset);
                        if (selEnd > selStart) {
                            min = selStart;
                            max = selEnd;
                            selectedText = selection.toString();
                        }
                    }
                } catch (err) {
                    console.error('Failed to normalize selection:', err);
                }
            }

            console.log('Showing classification options:', {
                start: min,
                end: max,
                textLength: selectedText.length,
                textPreview: selectedText.substring(0, 100)
            });
            
            // Show classification modal with enhanced features
            this.showClassificationModal(selectedText, min, max);
        }
        showObservableModal(text, start, end) {
            if (this.isUpdatingModal) return;

            // Store the validated selection - this becomes the source of truth
            // Modal is a confirmation boundary; we save exactly these values
            this.pendingObservableSelection = {
                selectedText: text,
                start: start,
                end: end
            };

            const MAX_OBS_LENGTH = 4000;
            const workingText = text;
            const workingStart = start;
            const workingEnd = end;

            const charCount = workingText.length;
            const targetLength = MAX_OBS_LENGTH;
            let lengthStatus = 'good';
            let lengthMessage = '';
            if (charCount < 30) {
                lengthStatus = 'short';
                lengthMessage = 'Too short - highlight the full command line.';
            } else if (charCount > targetLength) {
                lengthStatus = 'long';
                lengthMessage = `Long selection (${charCount}). Commands over ${targetLength} chars may be harder to review.`;
            }

            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center';
            this.currentModal = modal; // Store reference for reliable closing

            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    // Clear pending selection on click-away (user cancelled)
                    this.pendingObservableSelection = null;
                    this.closeModal();
                }
            }.bind(this));

            const handleEsc = function(e) {
                if (e.key === 'Escape') {
                    // Clear pending selection on ESC (user cancelled)
                    this.pendingObservableSelection = null;
                    this.closeModal();
                    document.removeEventListener('keydown', handleEsc);
                }
            }.bind(this);
            document.addEventListener('keydown', handleEsc);

            modal.innerHTML = `
                <div class="bg-gray-800 border border-gray-700 rounded-xl shadow-2xl p-6 max-w-lg w-full mx-4">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold text-gray-50">Save Observable</h3>
                        <div class="char-counter ${lengthStatus}">
                            ${charCount}/${targetLength} chars
                        </div>
                    </div>
                    ${lengthMessage ? `<div class="length-guidance ${lengthStatus} mb-4">${lengthMessage}</div>` : ''}
                    <p class="text-sm text-gray-300 mb-4 break-words whitespace-pre-wrap">"${workingText.substring(0, 200)}${workingText.length > 200 ? '‚Ä¶' : ''}"</p>
                    <div class="flex space-x-3">
                        <button id="observable-save-btn" 
                                class="flex-1 bg-purple-500 hover:bg-purple-600 text-white px-4 py-3 rounded-lg text-lg font-semibold min-h-[48px] touch-manipulation focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            Save ${this.observableType}
                        </button>
                        <button id="observable-cancel-btn" 
                                class="px-4 py-3 border border-gray-600 hover:bg-gray-800 text-gray-300 rounded-lg text-lg font-semibold min-h-[48px] touch-manipulation focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            Cancel
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
            this.isUpdatingModal = true;

            const saveBtn = modal.querySelector('#observable-save-btn');
            const cancelBtn = modal.querySelector('#observable-cancel-btn');

            if (saveBtn) {
                saveBtn.addEventListener('click', async () => {
                    // Use stored validated selection - ignore current window.getSelection()
                    // IMPORTANT: Submit BEFORE closeModal() because closeModal clears pendingObservableSelection
                    await this.submitObservableAnnotation();
                    this.closeModal();
                });
            }
            if (cancelBtn) {
                cancelBtn.addEventListener('click', () => {
                    // Clear pending selection on cancel
                    this.pendingObservableSelection = null;
                    this.closeModal();
                });
            }

            if (!document.getElementById('observable-modal-styles')) {
                const styles = document.createElement('style');
                styles.id = 'observable-modal-styles';
                styles.textContent = `
                    .char-counter {
                        font-size: 11px;
                        font-weight: 600;
                        padding: 2px 6px;
                        border-radius: 4px;
                        margin-left: 8px;
                    }
                    .char-counter.good {
                        background: #dcfce7;
                        color: #15803d;
                        border: 1px solid #16a34a;
                    }
                    .char-counter.short {
                        background: #c9c7c9;
                        color: #92400e;
                        border: 1px solid #f59e0b;
                    }
                    .char-counter.long {
                        background: #fee2e2;
                        color: #dc2626;
                        border: 1px solid #ef4444;
                    }
                    .length-guidance {
                        font-size: 12px;
                        padding: 8px 12px;
                        border-radius: 6px;
                        border-left: 4px solid;
                    }
                    .length-guidance.short {
                        background: #c9c7c9;
                        color: #92400e;
                        border-left-color: #f59e0b;
                    }
                    .length-guidance.long {
                        background: #fee2e2;
                        color: #dc2626;
                        border-left-color: #ef4444;
                    }
                `;
                document.head.appendChild(styles);
            }

            setTimeout(() => {
                this.isUpdatingModal = false;
            }, 100);
        }
        showClassificationModal(text, start, end) {
            // Prevent infinite loops when updating existing modal
            if (this.isUpdatingModal) {
                return;
            }
            
            // Auto-expand to 1000 characters before showing modal
            const expandedSelection = this.autoExpandTo1000(start, end);
            const expandedText = expandedSelection.text;
            const expandedStart = expandedSelection.start;
            const expandedEnd = expandedSelection.end;
            
            // Create modal for classification
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center';
            this.currentModal = modal; // Store reference for reliable closing
            
            // Add click outside to close
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    this.closeModal();
                }
            }.bind(this));
            
            // Add ESC key to close
            const handleEsc = function(e) {
                if (e.key === 'Escape') {
                    this.closeModal();
                    document.removeEventListener('keydown', handleEsc);
                }
            }.bind(this);
            document.addEventListener('keydown', handleEsc);
            
            // Calculate character count and length guidance
            const charCount = expandedText.length;
            const targetLength = 1000;
            
            // Color coding for length guidance (production-aligned)
            let lengthStatus = 'good'; // green
            let lengthMessage = '';
            if (charCount < 800) {
                lengthStatus = 'short'; // yellow
                lengthMessage = '‚ö†Ô∏è Too short - add more context to match production chunks';
            } else if (charCount < 950) {
                lengthStatus = 'acceptable'; // blue
                lengthMessage = '‚ö†Ô∏è Acceptable but not optimal - aim for 950-1000 chars';
            } else if (charCount > 1000) {
                lengthStatus = 'long'; // red
                lengthMessage = '‚ö†Ô∏è Too long - will be chunked differently in production';
            }
            
            modal.innerHTML = `
                <div class="bg-gray-800 border border-gray-700 rounded-xl shadow-2xl p-6 max-w-md w-full mx-4">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold text-gray-50">Classify Selected Text</h3>
                        <div class="char-counter ${lengthStatus}">
                            ${charCount}/${targetLength} chars
                        </div>
                    </div>
                    ${lengthMessage ? `<div class="length-guidance ${lengthStatus} mb-4">${lengthMessage}</div>` : ''}
                    <p class="text-sm text-gray-300 mb-4">"${expandedText.substring(0, 100)}${expandedText.length > 100 ? '...' : ''}"</p>
                    
                    <div class="flex space-x-3">
                        <button id="huntable-btn" 
                                class="flex-1 bg-emerald-500 hover:bg-emerald-600 text-white px-4 py-3 rounded-lg text-lg font-semibold min-h-[48px] touch-manipulation focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            üéØ Huntable
                        </button>
                        <button id="not-huntable-btn" 
                                class="flex-1 bg-red-500 hover:bg-red-600 text-white px-4 py-3 rounded-lg text-lg font-semibold min-h-[48px] touch-manipulation focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            ‚ùå Not Huntable
                        </button>
                        <button id="cancel-btn" 
                                class="px-4 py-3 border border-gray-600 hover:bg-gray-800 text-gray-300 rounded-lg text-lg font-semibold min-h-[48px] touch-manipulation focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Add touch event handlers for mobile
            addMobileModalHandlers(modal, expandedStart, expandedEnd);
            
            // Add CSS styles if not already present
            if (!document.getElementById('annotation-enhancement-styles')) {
                const styles = document.createElement('style');
                styles.id = 'annotation-enhancement-styles';
                styles.textContent = `
                    .char-counter {
                        font-size: 11px;
                        font-weight: 600;
                        padding: 2px 6px;
                        border-radius: 4px;
                        margin-left: 8px;
                    }
                    
                    .char-counter.good {
                        background: #dcfce7;
                        color: #15803d;
                        border: 1px solid #16a34a;
                    }
                    
                    .char-counter.short {
                        background: #c9c7c9;
                        color: #d97706;
                        border: 1px solid #f59e0b;
                    }
                    
                    .char-counter.acceptable {
                        background: #dbeafe;
                        color: #1d4ed8;
                        border: 1px solid #3b82f6;
                    }
                    
                    .char-counter.long {
                        background: #fef2f2;
                        color: #dc2626;
                        border: 1px solid #ef4444;
                    }
                    
                    .length-guidance {
                        font-size: 11px;
                        padding: 6px 8px;
                        border-radius: 4px;
                        text-align: center;
                    }
                    
                    .length-guidance.good {
                        background: #dcfce7;
                        color: #15803d;
                        border: 1px solid #16a34a;
                    }
                    
                    .length-guidance.short {
                        background: #c9c7c9;
                        color: #d97706;
                        border: 1px solid #f59e0b;
                    }
                    
                    .length-guidance.acceptable {
                        background: #dbeafe;
                        color: #1d4ed8;
                        border: 1px solid #3b82f6;
                    }
                    
                    .length-guidance.long {
                        background: #fef2f2;
                        color: #dc2626;
                        border: 1px solid #ef4444;
                    }
                `;
                document.head.appendChild(styles);
            }
        }
        
        expandSelection(currentStart, currentEnd, expandBy) {
            // Get the full article text
            const fullText = this.contentElement.textContent;
            
            // Calculate new boundaries
            let newStart, newEnd;
            
            if (expandBy > 0) {
                // Expanding - add to both sides symmetrically
                const halfExpand = Math.floor(expandBy / 2);
                newStart = Math.max(0, currentStart - halfExpand);
                newEnd = Math.min(fullText.length, currentEnd + halfExpand);
            } else {
                // Contracting - remove from both sides symmetrically
                const halfContract = Math.floor(Math.abs(expandBy) / 2);
                newStart = currentStart + halfContract;
                newEnd = currentEnd - halfContract;
            }
            
            // Apply smart boundary detection
            const smartBoundaries = this.findSmartBoundaries(fullText, newStart, newEnd);
            newStart = smartBoundaries.start;
            newEnd = smartBoundaries.end;
            
            // Get new text
            const newText = fullText.substring(newStart, newEnd);
            
            // Update the live text selection in the browser
            this.updateLiveSelection(newStart, newEnd);
            
            // Update the current modal with new selection data
            this.updateModalWithNewSelection(newText, newStart, newEnd);
        }
        
        autoExpandTo1000(currentStart, currentEnd) {
            // Get the full article text
            const fullText = this.contentElement.textContent;
            const currentText = fullText.substring(currentStart, currentEnd);
            const currentLength = currentText.length;
            const targetLength = 1000;
            
            let newStart, newEnd;
            
            if (currentLength >= targetLength) {
                // Already at or over target, just trim to exactly 1000
                const trimAmount = currentLength - targetLength;
                const halfTrim = Math.floor(trimAmount / 2);
                newStart = currentStart + halfTrim;
                newEnd = currentEnd - (trimAmount - halfTrim);
            } else {
                // Need to expand - calculate how much to add
                const expandBy = targetLength - currentLength;
                const halfExpand = Math.floor(expandBy / 2);
                
                // Try to expand symmetrically
                newStart = Math.max(0, currentStart - halfExpand);
                newEnd = Math.min(fullText.length, currentEnd + halfExpand);
                
                // If we hit boundaries, expand more on the other side
                if (newStart === 0 && newEnd < fullText.length) {
                    const remainingExpand = targetLength - (newEnd - newStart);
                    newEnd = Math.min(fullText.length, newEnd + remainingExpand);
                } else if (newEnd === fullText.length && newStart > 0) {
                    const remainingExpand = targetLength - (newEnd - newStart);
                    newStart = Math.max(0, newStart - remainingExpand);
                }
                
                // CRITICAL: Ensure we don't exceed 1000 characters for ML training
                const finalLength = newEnd - newStart;
                if (finalLength > targetLength) {
                    const excess = finalLength - targetLength;
                    const halfExcess = Math.floor(excess / 2);
                    newStart += halfExcess;
                    newEnd -= (excess - halfExcess);
                    console.log(`Trimmed selection to stay under 1000 chars: ${finalLength} ‚Üí ${newEnd - newStart}`);
                }
            }
            
            // Apply smart boundary detection
            const smartBoundaries = this.findSmartBoundaries(fullText, newStart, newEnd);
            newStart = smartBoundaries.start;
            newEnd = smartBoundaries.end;
            
            // CRITICAL: Final check - ensure we don't exceed 1000 characters for ML training
            const finalLength = newEnd - newStart;
            if (finalLength > targetLength) {
                const excess = finalLength - targetLength;
                const halfExcess = Math.floor(excess / 2);
                newStart += halfExcess;
                newEnd -= (excess - halfExcess);
                console.log(`Final trim to stay under 1000 chars: ${finalLength} ‚Üí ${newEnd - newStart}`);
            }
            
            const newText = fullText.substring(newStart, newEnd);
            
            console.log(`Auto-expand: ${currentLength} ‚Üí ${newText.length} chars`);
            
            // Update the live text selection in the browser
            this.updateLiveSelection(newStart, newEnd);
            
            // Update the current modal with new selection data
            this.updateModalWithNewSelection(newText, newStart, newEnd);

            // Return expanded selection so callers can use it without re-deriving
            return {
                text: newText,
                start: newStart,
                end: newEnd
            };
        }
        updateLiveSelection(newStart, newEnd) {
            // Update the browser's text selection to show the expanded selection
            try {
                // Temporarily disable the native selection event handler to prevent conflicts
                this.isUpdatingSelection = true;
                
                const range = document.createRange();
                const startNode = this.getTextNodeAtOffset(newStart);
                const endNode = this.getTextNodeAtOffset(newEnd);
                
                if (startNode && endNode) {
                    range.setStart(startNode.node, startNode.offset);
                    range.setEnd(endNode.node, endNode.offset);
                    
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // Disable automatic scrolling for Auto 1000 to prevent background page jumping
                    // The selection will be updated but the page position will remain stable
                }
                
                // Re-enable the native selection event handler after a short delay
                setTimeout(() => {
                    this.isUpdatingSelection = false;
                }, 100);
                
            } catch (error) {
                console.error('Error updating live selection:', error);
                this.isUpdatingSelection = false;
            }
        }
        
        updateModalWithNewSelection(newText, newStart, newEnd) {
            // NUCLEAR OPTION: Completely recreate the modal to force UI update
            console.log('Recreating modal to force UI update');
            
            // Set flag to prevent infinite loops
            this.isUpdatingModal = true;
            
            // Close the current modal
            this.closeModal();
            
            // Wait a frame to ensure DOM cleanup
            setTimeout(() => {
                // Create modal directly without auto-expanding (we already have the right text)
                this.createModalDirectly(newText, newStart, newEnd);
                
                // Clear the flag after modal is recreated
                setTimeout(() => {
                    this.isUpdatingModal = false;
                }, 100);
            }, 10);
        }
        
        createModalDirectly(text, start, end) {
            // Create modal for classification without auto-expanding
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center';
            this.currentModal = modal; // Store reference for reliable closing
            
            // Add click outside to close
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    this.closeModal();
                }
            }.bind(this));
            
            // Add ESC key to close
            const handleEsc = function(e) {
                if (e.key === 'Escape') {
                    this.closeModal();
                    document.removeEventListener('keydown', handleEsc);
                }
            }.bind(this);
            document.addEventListener('keydown', handleEsc);
            
            // Calculate character count and length guidance
            const charCount = text.length;
            const targetLength = 1000;
            
            // Color coding for length guidance (production-aligned)
            let lengthStatus = 'good'; // green
            let lengthMessage = '';
            if (charCount < 800) {
                lengthStatus = 'short'; // yellow
                lengthMessage = '‚ö†Ô∏è Too short - add more context to match production chunks';
            } else if (charCount < 950) {
                lengthStatus = 'acceptable'; // blue
                lengthMessage = '‚ö†Ô∏è Acceptable but not optimal - aim for 950-1000 chars';
            } else if (charCount > 1000) {
                lengthStatus = 'long'; // red
                lengthMessage = '‚ö†Ô∏è Too long - will be chunked differently in production';
            }
            
            modal.innerHTML = `
                <div class="bg-gray-800 border border-gray-700 rounded-xl shadow-2xl p-6 max-w-md w-full mx-4">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold text-gray-50">Classify Selected Text</h3>
                        <div class="char-counter ${lengthStatus}">
                            ${charCount}/${targetLength} chars
                        </div>
                    </div>
                    ${lengthMessage ? `<div class="length-guidance ${lengthStatus} mb-4">${lengthMessage}</div>` : ''}
                    <p class="text-sm text-gray-300 mb-4">"${text.substring(0, 100)}${text.length > 100 ? '...' : ''}"</p>
                    
                    <div class="flex space-x-3">
                        <button id="huntable-btn" 
                                class="flex-1 bg-emerald-500 hover:bg-emerald-600 text-white px-4 py-3 rounded-lg text-lg font-semibold min-h-[48px] touch-manipulation focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            üéØ Huntable
                        </button>
                        <button id="not-huntable-btn" 
                                class="flex-1 bg-red-500 hover:bg-red-600 text-white px-4 py-3 rounded-lg text-lg font-semibold min-h-[48px] touch-manipulation focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            ‚ùå Not Huntable
                        </button>
                        <button id="cancel-btn" 
                                class="px-4 py-3 border border-gray-600 hover:bg-gray-800 text-gray-300 rounded-lg text-lg font-semibold min-h-[48px] touch-manipulation focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Add touch event handlers for mobile
            addMobileModalHandlers(modal, start, end);
            
            // Add CSS styles if not already present
            if (!document.getElementById('annotation-enhancement-styles')) {
                const styles = document.createElement('style');
                styles.id = 'annotation-enhancement-styles';
                styles.textContent = `
                    .char-counter {
                        font-size: 11px;
                        font-weight: 600;
                        padding: 2px 6px;
                        border-radius: 4px;
                        margin-left: 8px;
                    }
                    
                    .char-counter.good {
                        background: #dcfce7;
                        color: #15803d;
                        border: 1px solid #16a34a;
                    }
                    
                    .char-counter.short {
                        background: #c9c7c9;
                        color: #92400e;
                        border: 1px solid #f59e0b;
                    }
                    
                    .char-counter.acceptable {
                        background: #dbeafe;
                        color: #1e40af;
                        border: 1px solid #3b82f6;
                    }
                    
                    .char-counter.long {
                        background: #fee2e2;
                        color: #dc2626;
                        border: 1px solid #ef4444;
                    }
                    
                    .length-guidance {
                        font-size: 12px;
                        padding: 8px 12px;
                        border-radius: 6px;
                        border-left: 4px solid;
                    }
                    
                    .length-guidance.good {
                        background: #dcfce7;
                        color: #15803d;
                        border-left-color: #16a34a;
                    }
                    
                    .length-guidance.short {
                        background: #c9c7c9;
                        color: #92400e;
                        border-left-color: #f59e0b;
                    }
                    
                    .length-guidance.acceptable {
                        background: #dbeafe;
                        color: #1e40af;
                        border-left-color: #3b82f6;
                    }
                    
                    .length-guidance.long {
                        background: #fee2e2;
                        color: #dc2626;
                        border-left-color: #ef4444;
                    }
                `;
                document.head.appendChild(styles);
            }
        }
        
        findSmartBoundaries(text, start, end) {
            // Smart boundary detection - prefer sentence, paragraph, then word boundaries
            const maxLookback = 100; // Don't look back more than 100 chars
            const maxLookahead = 100; // Don't look ahead more than 100 chars
            
            // Find sentence boundaries (preferred)
            const sentenceStart = this.findSentenceStart(text, start, maxLookback);
            const sentenceEnd = this.findSentenceEnd(text, end, maxLookahead);
            
            if (sentenceStart !== start || sentenceEnd !== end) {
                return { start: sentenceStart, end: sentenceEnd };
            }
            
            // Find paragraph boundaries (second choice)
            const paragraphStart = this.findParagraphStart(text, start, maxLookback);
            const paragraphEnd = this.findParagraphEnd(text, end, maxLookahead);
            
            if (paragraphStart !== start || paragraphEnd !== end) {
                return { start: paragraphStart, end: paragraphEnd };
            }
            
            // Find word boundaries (last resort)
            const wordStart = this.findWordStart(text, start, maxLookback);
            const wordEnd = this.findWordEnd(text, end, maxLookahead);
            
            return { start: wordStart, end: wordEnd };
        }
        
        findSentenceStart(text, position, maxLookback) {
            const start = Math.max(0, position - maxLookback);
            const searchText = text.substring(start, position);
            
            // Look for sentence endings followed by whitespace and capital letter
            const sentenceEndRegex = /[.!?]\s+[A-Z]/g;
            let match;
            let lastMatch = start;
            
            while ((match = sentenceEndRegex.exec(searchText)) !== null) {
                lastMatch = start + match.index + match[0].length - 1; // Position after the capital letter
            }
            
            return lastMatch;
        }
        
        findSentenceEnd(text, position, maxLookahead) {
            const end = Math.min(text.length, position + maxLookahead);
            const searchText = text.substring(position, end);
            
            // Look for sentence endings
            const sentenceEndRegex = /[.!?](?=\s|$)/g;
            const match = sentenceEndRegex.exec(searchText);
            
            if (match) {
                return position + match.index + 1; // Position after the punctuation
            }
            
            return position;
        }
        
        findParagraphStart(text, position, maxLookback) {
            const start = Math.max(0, position - maxLookback);
            const searchText = text.substring(start, position);
            
            // Look for double newlines (paragraph breaks)
            const paragraphBreak = searchText.lastIndexOf('\n\n');
            if (paragraphBreak !== -1) {
                return start + paragraphBreak + 2; // After the double newline
            }
            
            return start;
        }
        
        findParagraphEnd(text, position, maxLookahead) {
            const end = Math.min(text.length, position + maxLookahead);
            const searchText = text.substring(position, end);
            
            // Look for double newlines (paragraph breaks)
            const paragraphBreak = searchText.indexOf('\n\n');
            if (paragraphBreak !== -1) {
                return position + paragraphBreak; // Before the double newline
            }
            
            return position;
        }
        
        findWordStart(text, position, maxLookback) {
            const start = Math.max(0, position - maxLookback);
            const searchText = text.substring(start, position);
            
            // Look for word boundary (space or punctuation followed by letter)
            const wordBoundaryRegex = /[^\w](?=\w)/g;
            let match;
            let lastMatch = start;
            
            while ((match = wordBoundaryRegex.exec(searchText)) !== null) {
                lastMatch = start + match.index + 1; // Position after the boundary
            }
            
            return lastMatch;
        }
        
        findWordEnd(text, position, maxLookahead) {
            const end = Math.min(text.length, position + maxLookahead);
            const searchText = text.substring(position, end);
            
            // Look for word boundary (letter followed by space or punctuation)
            const wordBoundaryRegex = /\w(?=[^\w]|$)/g;
            const match = wordBoundaryRegex.exec(searchText);
            
            if (match) {
                return position + match.index + 1; // Position after the word
            }
            
            return position;
        }
        
        getTextNodeAtOffset(offset) {
            // Helper method to find text node at character offset
            let currentOffset = 0;
            const walker = document.createTreeWalker(
                this.contentElement,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let node;
            while (node = walker.nextNode()) {
                const nodeLength = node.textContent.length;
                if (currentOffset + nodeLength >= offset) {
                    return {
                        node: node,
                        offset: offset - currentOffset
                    };
                }
                currentOffset += nodeLength;
            }
            
            // Fallback to last node
            const lastNode = this.contentElement.lastChild;
            if (lastNode && lastNode.nodeType === Node.TEXT_NODE) {
                return {
                    node: lastNode,
                    offset: lastNode.textContent.length
                };
            }
            
            return null;
        }
        
        async classifySelection(start, end, classification) {
            // Prevent duplicate submissions - check immediately
            if (this.isSubmitting) {
                console.log('Preventing duplicate submission - already submitting');
                return;
            }
            this.isSubmitting = true;
            
            try {
                const text = this.contentElement.textContent.substring(start, end);
                
                console.log('Classifying selection:', {
                    start: start,
                    end: end,
                    textLength: text.length,
                    textPreview: text.substring(0, 100),
                    classification: classification
                });
                
                // Close modal immediately to provide visual feedback
                this.closeModal();
                
                // Add the classification highlight
                this.addUserClassification(start, end, classification, text);
                
                // Save to server
                await this.saveClassification(start, end, text, classification);
                
                // Show success message
                const label = this.getAnnotationLabel(classification);
                this.showSuccessMessage(`Text classified as ${label}`);
                
            } finally {
                // Reset submission state after a short delay to prevent rapid clicking
                setTimeout(() => {
                    this.isSubmitting = false;
                }, 500);
            }
        }
        showRemoveAnnotationModal(spanElement, annotationType, annotationText) {
            // Store reference to the span element for removal
            this.pendingRemovalSpan = spanElement;
            this.pendingRemovalText = annotationText;
            
            // Create modal for removing annotation
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center';
            
            // Add click outside to close
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    this.closeModal();
                }
            }.bind(this));
            
            // Add ESC key to close
            const handleEsc = function(e) {
                if (e.key === 'Escape') {
                    this.closeModal();
                    document.removeEventListener('keydown', handleEsc);
                }
            }.bind(this);
            document.addEventListener('keydown', handleEsc);
            
            modal.innerHTML = `
                <div class="bg-gray-800 border border-gray-700 rounded-xl shadow-2xl p-6 max-w-md w-full mx-4">
                    <h3 class="text-lg font-semibold text-gray-50 mb-4">Remove Annotation</h3>
                    <p class="text-sm text-gray-300 mb-2">
                        <strong>Type:</strong> ${this.getAnnotationLabel(annotationType)}
                    </p>
                    <p class="text-sm text-gray-300 mb-4">
                        <strong>Text:</strong> "${annotationText.substring(0, 100)}${annotationText.length > 100 ? '...' : ''}"
                    </p>
                    <p class="text-sm text-gray-300 mb-4">
                        Do you want to remove this annotation?
                    </p>
                    <div class="flex space-x-3">
                        <button onclick="simpleTextManager.confirmRemoveAnnotation()" 
                                class="flex-1 bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            Remove
                        </button>
                        <button onclick="simpleTextManager.closeModal()" 
                                class="flex-1 px-4 py-2 border border-gray-600 hover:bg-gray-800 text-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        async confirmRemoveAnnotation() {
            if (!this.pendingRemovalSpan || !this.pendingRemovalText) {
                console.error('No pending annotation removal');
                return;
            }
            
            try {
                // Save state for undo
                this.saveState();
                
                // Remove the span from the DOM (replace with original text)
                const originalText = this.pendingRemovalText;
                const parent = this.pendingRemovalSpan.parentNode;
                const textNode = document.createTextNode(originalText);
                parent.replaceChild(textNode, this.pendingRemovalSpan);
                
                // Find and delete the annotation from the database
                const response = await fetch(`/api/articles/{{ article.id }}/annotations`, {
                    method: 'GET'
                });
                const data = await response.json();
                
                if (data.success && data.annotations.length > 0) {
                    // Find the annotation that matches our text
                    const matchingAnnotation = data.annotations.find(annotation => 
                        annotation.selected_text === originalText
                    );
                    
                    if (matchingAnnotation) {
                        // Delete it from database
                        const deleteResponse = await fetch(`/api/articles/{{ article.id }}/annotations/${matchingAnnotation.id}`, {
                            method: 'DELETE'
                        });
                        
                        if (deleteResponse.ok) {
                            console.log(`Removed annotation ID ${matchingAnnotation.id} from database`);
                        } else {
                            console.error('Failed to remove annotation from database');
                        }
                    } else {
                        console.log('Could not find matching annotation in database');
                    }
                }
                
                // Clear pending removal references
                this.pendingRemovalSpan = null;
                this.pendingRemovalText = null;
                
                console.log('Annotation removed successfully');
                
            } catch (error) {
                console.error('Error removing annotation:', error);
            }
            
            this.closeModal();
        }
        
        closeModal() {
            // First try to use stored modal reference (most reliable)
            if (this.currentModal && this.currentModal.parentNode) {
                this.currentModal.remove();
                this.currentModal = null;
            } else {
                // Fallback: Try multiple selectors to find the modal
                // First try the old observable modal selector
                let modal = document.querySelector('.fixed.inset-0.bg-gray-600.bg-opacity-50');
                
                // If not found, look for any modal containing "Classify Selected Text"
                if (!modal) {
                    const modals = document.querySelectorAll('.fixed.inset-0');
                    for (const m of modals) {
                        if (m.textContent && m.textContent.includes('Classify Selected Text')) {
                            modal = m;
                            break;
                        }
                    }
                }
                
                // Fallback: find any fixed inset-0 modal with z-50 (classification modals)
                if (!modal) {
                    const allModals = document.querySelectorAll('.fixed.inset-0');
                    for (const m of allModals) {
                        if (m.classList.contains('z-50')) {
                            modal = m;
                            break;
                        }
                    }
                }
                
                if (modal) {
                    modal.remove();
                }
            }
            
            // Clear pending observable selection when modal closes (unless it was saved)
            // This ensures cancel/ESC doesn't leave stale state
            if (this.pendingObservableSelection) {
                this.pendingObservableSelection = null;
            }
        }
        
        showSuccessMessage(message) {
            // Create a temporary success message
            const successDiv = document.createElement('div');
            successDiv.className = 'fixed top-4 right-4 bg-emerald-500 text-white px-4 py-2 rounded shadow-lg z-50';
            successDiv.textContent = message;
            document.body.appendChild(successDiv);
            
            // Remove after 2 seconds
            setTimeout(() => {
                if (successDiv.parentNode) {
                    successDiv.parentNode.removeChild(successDiv);
                }
            }, 2000);
        }
        
        async saveClassification(start, end, text, classification, contextOverride = null, usage = null) {
            try {
                console.log('Saving classification:', {
                    start: start,
                    end: end,
                    textLength: text.length,
                    textPreview: text.substring(0, 100),
                    classification: classification
                });
                const context = contextOverride || this.getContextAroundSelection(start, end);

                const payload = {
                    selected_text: text,
                    start_position: start,
                    end_position: end,
                    annotation_type: classification,
                    context_before: context.before,
                    context_after: context.after,
                    confidence_score: 1.0
                };
                if (usage && OBSERVABLE_TYPES.includes(classification)) {
                    payload.usage = usage;
                }

                const response = await fetch(`/api/articles/{{ article.id }}/annotations`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API Error Response:', errorText);
                    throw new Error(`Failed to save classification: ${response.status} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log('Classification saved successfully:', result);
                
                // Show success notification
                showNotification(`Annotation saved successfully!`, 'success');
                
            } catch (error) {
                console.error('Error saving classification:', error);
                showNotification(`Failed to save annotation: ${error.message}`, 'error');
            }
        }

        getTypeStyle(annotationType) {
            return ANNOTATION_STYLE_MAP[annotationType] || {
                label: annotationType,
                highlightClass: 'bg-gray-100 border-gray-300 text-gray-800'
            };
        }

        getAnnotationLabel(annotationType) {
            const style = this.getTypeStyle(annotationType);
            return style.label;
        }

        getContextAroundSelection(start, end) {
            // Use canonical text to ensure context matches the offset calculation buffer
            const fullText = this.canonicalText || this.contentElement.textContent;
            const CONTEXT_RADIUS = 400; // capture broader context for observables training
            const contextBefore = fullText.substring(Math.max(0, start - CONTEXT_RADIUS), start);
            const contextAfter = fullText.substring(end, Math.min(fullText.length, end + CONTEXT_RADIUS));
            return { before: contextBefore, after: contextAfter };
        }

        async submitObservableAnnotation() {
            // Use stored validated selection from modal open - ignore window.getSelection()
            // Modal is a confirmation boundary; we save exactly what was validated when modal opened
            if (!this.pendingObservableSelection) {
                showNotification('No selection to save. Please select text and try again.', 'error');
                return;
            }
            
            // Use stored exact values - no re-validation, no modification
            const normalizedStart = this.pendingObservableSelection.start;
            const normalizedEnd = this.pendingObservableSelection.end;
            const selectedText = this.pendingObservableSelection.selectedText;
            
            // Clear any current selection (before DOM mutation)
            const selection = window.getSelection();
            if (selection) {
                selection.removeAllRanges();
            }
            
            // Clear pending selection after extracting values
            this.pendingObservableSelection = null;
            
            // Deduplication check
            const now = Date.now();
            const dedupeKey = `${this.articleId}:${this.observableType}:${normalizedStart}:${normalizedEnd}`;
            if (dedupeKey === this.lastObservableAnnotationKey && now - this.lastObservableAnnotationAt < 750) {
                console.log('Skipping duplicate observable annotation submission');
                return;
            }
            this.lastObservableAnnotationKey = dedupeKey;
            this.lastObservableAnnotationAt = now;
            
            // Final validation: selected text must exist
            if (!selectedText || selectedText.length === 0) {
                showNotification('Selection is empty. Please highlight text.', 'error');
                return;
            }
            
            // Length warning (informational only, not a blocker)
            const MAX_OBS_LENGTH = 4000;
            if (selectedText.length > MAX_OBS_LENGTH) {
                showNotification(`Long selection (${selectedText.length} chars). Saved, but please keep commands concise when possible.`, 'info');
            }
            
            const label = this.getAnnotationLabel(this.observableType);
            console.log('Creating observable annotation (exact selection):', {
                start: normalizedStart,
                end: normalizedEnd,
                textLength: selectedText.length,
                textPreview: selectedText.substring(0, 100),
                type: this.observableType
            });
            
            // Add highlight AFTER offset calculation (DOM mutation happens here)
            this.addUserClassification(normalizedStart, normalizedEnd, this.observableType, selectedText);
            
            // Calculate context from canonical text
            const context = this.getContextAroundSelection(normalizedStart, normalizedEnd);
            await this.saveClassification(
                normalizedStart,
                normalizedEnd,
                selectedText,
                this.observableType,
                context,
                this.observableDatasetUsage
            );
            
            this.showSuccessMessage(`Saved ${label} observable`);
        }
    }
    
    // Initialize the simple text manager
    let simpleTextManager;
    document.addEventListener('DOMContentLoaded', function() {
        simpleTextManager = new SimpleTextManager();
        // Expose for automation/tests and inline scripts
        window.simpleTextManager = simpleTextManager;
        window.SimpleTextManager = SimpleTextManager;
        document.querySelectorAll("#observableUsageButtons [data-dataset-usage]").forEach(button => {
            button.addEventListener("click", () => setObservableDatasetUsage(button.dataset.datasetUsage));
        });
        simpleTextManager.setObservableDatasetUsage(simpleTextManager.observableDatasetUsage);
        
        // Add iPhone touch support
        addiPhoneTouchSupport();
    });
    
    // Global function to toggle annotation system
    function toggleAnnotationSystem() {
        if (!simpleTextManager) return;
        
        if (simpleTextManager.annotationsEnabled) {
            simpleTextManager.disableAnnotations();
        } else {
            simpleTextManager.enableAnnotations();
        }
    }
    
    function setAnnotationMode(mode) {
        try {
            if (!simpleTextManager) {
                console.warn('setAnnotationMode called before simpleTextManager initialized, mode:', mode);
                // Store mode in localStorage so it can be applied when manager initializes
                localStorage.setItem('annotationMode', mode);
                return;
            }
            simpleTextManager.setAnnotationMode(mode);
        } catch (error) {
            console.error('Error in setAnnotationMode:', error);
        }
    }
    
    // Explicitly attach to window for inline onclick handlers
    window.setAnnotationMode = setAnnotationMode;
    
    function setObservableType(type) {
        try {
            if (!simpleTextManager) return;
            simpleTextManager.setObservableType(type);
        } catch (error) {
            console.error('Error in setObservableType:', error);
        }
    }
    
    // Explicitly attach to window for inline onclick handlers
    window.setObservableType = setObservableType;

    function setObservableDatasetUsage(usage) {
        if (!simpleTextManager) return;
        simpleTextManager.setObservableDatasetUsage(usage);
    }

    function updateDatasetUsageButtons() {
        if (!simpleTextManager) return;
        const currentUsage = simpleTextManager.observableDatasetUsage || 'train';
        document.querySelectorAll("#observableUsageButtons [data-dataset-usage]").forEach(button => {
            const btnUsage = (button.dataset.datasetUsage || 'train').toLowerCase();
            if (btnUsage === currentUsage) {
                button.classList.add('bg-[#4b4e77]', 'text-white');
                button.classList.remove('bg-white', 'text-gray-700', 'dark:text-gray-200');
            } else {
                button.classList.remove('bg-[#4b4e77]', 'text-white');
                button.classList.add('bg-white', 'text-gray-700', 'dark:text-gray-200');
            }
        });
    }

    function showDatasetUsageWarningOnce() {
        if (sessionStorage.getItem(DATASET_USAGE_WARNING_KEY)) return;
        showNotification("Evaluation data is never used for training.", "info");
        sessionStorage.setItem(DATASET_USAGE_WARNING_KEY, '1');
    }
    
    // iPhone Touch Support for Text Selection
    function addiPhoneTouchSupport() {
        // Use the active surface so observables use the plain container
        const managerRef = typeof simpleTextManager !== 'undefined' ? simpleTextManager : null;
        const contentElement = managerRef?.contentElement || document.getElementById('article-content');
        if (!contentElement) return;
        
        let touchStartTime = 0;
        let touchStartPos = null;
        let isLongPress = false;
        let longPressTimer = null;
        
        // Add touch event listeners
        contentElement.addEventListener('touchstart', function(e) {
            touchStartTime = Date.now();
            touchStartPos = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
            };
            
            console.log('üì± Touch start at:', touchStartPos);
            
            // Start long press timer
            longPressTimer = setTimeout(() => {
                console.log('üì± Long press timer triggered');
                isLongPress = true;
                handleLongPress(e);
            }, 800); // 800ms for long press (more reliable on iPhone)
            
            // Don't prevent default to allow text selection
        }, { passive: true });
        
        contentElement.addEventListener('touchmove', function(e) {
            // Cancel long press if finger moves too much
            if (touchStartPos) {
                const deltaX = Math.abs(e.touches[0].clientX - touchStartPos.x);
                const deltaY = Math.abs(e.touches[0].clientY - touchStartPos.y);
                
                if (deltaX > 10 || deltaY > 10) {
                    clearTimeout(longPressTimer);
                    isLongPress = false;
                }
            }
        });
        
        contentElement.addEventListener('touchend', function(e) {
            clearTimeout(longPressTimer);
            
            if (!isLongPress) {
                // Handle regular tap for text selection
                handleTap(e);
            }
            
            isLongPress = false;
            touchStartPos = null;
        });
        
        function handleLongPress(e) {
            console.log('üì± iPhone long press detected');
            
            // Get text at touch point
            const touch = e.touches[0];
            const range = document.caretRangeFromPoint ? 
                document.caretRangeFromPoint(touch.clientX, touch.clientY) :
                document.createRange();
            
            if (range) {
                // Select word at touch point
                range.selectNodeContents(range.commonAncestorContainer);
                if (range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {
                    const textNode = range.commonAncestorContainer;
                    const text = textNode.textContent;
                    const touchOffset = range.startOffset;
                    
                    // Find word boundaries
                    let start = touchOffset;
                    let end = touchOffset;
                    
                    while (start > 0 && /\S/.test(text[start - 1])) start--;
                    while (end < text.length && /\S/.test(text[end])) end++;
                    
                    range.setStart(textNode, start);
                    range.setEnd(textNode, end);
                    
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // Trigger annotation modal
                    if (simpleTextManager && selection.toString().length > 0) {
                        // For observables: use strict validation (no indexOf fallback)
                        if (simpleTextManager.annotationMode === OBSERVABLE_MODE) {
                            const validatedSelection = simpleTextManager.validateAndExtractObservableSelection();
                            if (validatedSelection) {
                                simpleTextManager.showObservableModal(
                                    validatedSelection.selectedText,
                                    validatedSelection.start,
                                    validatedSelection.end
                                );
                            }
                        } else {
                            // For huntability: use indexOf fallback
                            const selectedText = selection.toString();
                            const fullText = contentElement.textContent;
                            const startPos = fullText.indexOf(selectedText);
                            const endPos = startPos + selectedText.length;
                            
                            if (startPos !== -1) {
                                console.log('üì± iPhone: Triggering annotation modal');
                                simpleTextManager.showClassificationOptions(startPos, endPos);
                            }
                        }
                    }
                }
            }
        }
        
        function handleTap(e) {
            // Handle regular tap - let browser handle text selection
            console.log('üì± iPhone tap detected');
        }
        
        // Primary method: Double-tap to activate annotation modal
        let tapCount = 0;
        let tapTimer = null;
        
        contentElement.addEventListener('touchend', function(e) {
            tapCount++;
            
            if (tapCount === 1) {
                tapTimer = setTimeout(() => {
                    tapCount = 0;
                }, 300);
            } else if (tapCount === 2) {
                clearTimeout(tapTimer);
                tapCount = 0;
                
                console.log('üì± Double tap detected - triggering annotation modal');
                
                // Get current selection
                const selection = window.getSelection();
                if (selection.toString().length > 0) {
                    // For observables: use strict validation (no indexOf fallback)
                    if (simpleTextManager && simpleTextManager.annotationMode === OBSERVABLE_MODE) {
                        const validatedSelection = simpleTextManager.validateAndExtractObservableSelection();
                        if (validatedSelection) {
                            console.log('üì± Double tap: Triggering observable modal');
                            simpleTextManager.showObservableModal(
                                validatedSelection.selectedText,
                                validatedSelection.start,
                                validatedSelection.end
                            );
                        }
                    } else if (simpleTextManager) {
                        // For huntability: use indexOf fallback
                        const selectedText = selection.toString();
                        const fullText = contentElement.textContent;
                        const startPos = fullText.indexOf(selectedText);
                        const endPos = startPos + selectedText.length;
                        
                        if (startPos !== -1) {
                            console.log('üì± Double tap: Triggering annotation modal');
                            simpleTextManager.showClassificationOptions(startPos, endPos);
                        }
                    }
                } else {
                    // If no text is selected, try to select word at tap location
                    console.log('üì± Double tap: No selection, trying to select word');
                    selectWordAtTapLocation(e);
                }
            }
        });
        
        // Helper function to select word at tap location
        function selectWordAtTapLocation(e) {
            // Get touch coordinates
            const touch = e.changedTouches[0];
            const x = touch.clientX;
            const y = touch.clientY;
            
            // Try to get text at touch point
            if (document.caretRangeFromPoint) {
                const range = document.caretRangeFromPoint(x, y);
                if (range) {
                    const textNode = range.commonAncestorContainer;
                    if (textNode.nodeType === Node.TEXT_NODE) {
                        const text = textNode.textContent;
                        const offset = range.startOffset;
                        
                        // Find word boundaries
                        let start = offset;
                        let end = offset;
                        
                        while (start > 0 && /\S/.test(text[start - 1])) start--;
                        while (end < text.length && /\S/.test(text[end])) end++;
                        
                        if (start < end) {
                            // Create selection
                            const newRange = document.createRange();
                            newRange.setStart(textNode, start);
                            newRange.setEnd(textNode, end);
                            
                            const selection = window.getSelection();
                            selection.removeAllRanges();
                            selection.addRange(newRange);
                            
                            // Trigger annotation modal
                            if (simpleTextManager) {
                                // For observables: use strict validation (no indexOf fallback)
                                if (simpleTextManager.annotationMode === OBSERVABLE_MODE) {
                                    const validatedSelection = simpleTextManager.validateAndExtractObservableSelection();
                                    if (validatedSelection) {
                                        console.log('üì± Double tap: Word selected, triggering observable modal');
                                        simpleTextManager.showObservableModal(
                                            validatedSelection.selectedText,
                                            validatedSelection.start,
                                            validatedSelection.end
                                        );
                                    }
                                } else {
                                    // For huntability: use indexOf fallback
                                    const selectedText = selection.toString();
                                    const fullText = contentElement.textContent;
                                    const startPos = fullText.indexOf(selectedText);
                                    const endPos = startPos + selectedText.length;
                                    
                                    if (startPos !== -1) {
                                        console.log('üì± Double tap: Word selected, triggering modal');
                                        simpleTextManager.showClassificationOptions(startPos, endPos);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        console.log('üì± iPhone touch support added');
        
        // Add iPhone instructions
        addiPhoneInstructions();
    }

    async function markObservablesReviewed(articleId) {
        try {
            showNotification('Marking article as reviewed...', 'info');
            const response = await fetch(`/api/articles/${articleId}/mark-reviewed`, {
                method: 'POST'
            });
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Failed to update status: ${errorText}`);
            }
            const result = await response.json();
            showNotification(`Article marked as ${result.processing_status}`, 'success');
        } catch (error) {
            console.error('Failed to mark article reviewed:', error);
            showNotification(`Failed to mark reviewed: ${error.message}`, 'error');
        }
    }
    // Add mobile-friendly touch handlers for modal buttons
    function addMobileModalHandlers(modal, start, end) {
        // Huntable button
        const huntableBtn = modal.querySelector('#huntable-btn');
        if (huntableBtn) {
            huntableBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                console.log('üì± Huntable button clicked');
                simpleTextManager.classifySelection(start, end, 'huntable');
                simpleTextManager.closeModal();
            });
            
            huntableBtn.addEventListener('touchend', function(e) {
                e.stopPropagation();
                console.log('üì± Huntable button touched');
                simpleTextManager.classifySelection(start, end, 'huntable');
                simpleTextManager.closeModal();
            });
        }
        
        // Not Huntable button
        const notHuntableBtn = modal.querySelector('#not-huntable-btn');
        if (notHuntableBtn) {
            notHuntableBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                console.log('üì± Not Huntable button clicked');
                simpleTextManager.classifySelection(start, end, 'not_huntable');
                simpleTextManager.closeModal();
            });
            
            notHuntableBtn.addEventListener('touchend', function(e) {
                e.stopPropagation();
                console.log('üì± Not Huntable button touched');
                simpleTextManager.classifySelection(start, end, 'not_huntable');
                simpleTextManager.closeModal();
            });
        }
        
        // Cancel button
        const cancelBtn = modal.querySelector('#cancel-btn');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                console.log('üì± Cancel button clicked');
                simpleTextManager.closeModal();
            });
            
            cancelBtn.addEventListener('touchend', function(e) {
                e.stopPropagation();
                console.log('üì± Cancel button touched');
                simpleTextManager.closeModal();
            });
        }
        
        console.log('üì± Mobile modal handlers added');
    }
    
    function addiPhoneInstructions() {
        // Check if we're on mobile
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        if (!isMobile) return;
        
        // Add instructions banner
        const instructions = document.createElement('div');
        instructions.id = 'iphone-instructions';
        instructions.className = 'bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4 text-sm text-blue-800';
        instructions.innerHTML = `
            <div class="flex items-center space-x-2">
                <span class="text-lg">üì±</span>
                <div>
                    <strong>iPhone Annotation:</strong> 
                    <span class="block mt-1">
                        ‚Ä¢ <strong>Double-tap any word</strong> to select and annotate<br>
                        ‚Ä¢ <strong>Or select text normally</strong> then <strong>double-tap</strong> to annotate<br>
                        ‚Ä¢ <strong>Use "üéØ Auto 1000"</strong> to expand to 1000 characters<br>
                        ‚Ä¢ <strong>Perfect for ML training</strong>
                    </span>
                </div>
            </div>
        `;
        
        const contentElement = document.getElementById('article-content');
        if (contentElement && !document.getElementById('iphone-instructions')) {
            contentElement.parentNode.insertBefore(instructions, contentElement);
        }
    }
    
    // Copy article content to clipboard (for detail page)
    function copyArticleContentToClipboard() {
        try {
            const contentElement = document.getElementById('article-content');
            if (!contentElement) {
                showNotification('Article content element not found', 'error');
                return;
            }
            
            // Get the text content, stripping HTML tags
            const textContent = contentElement.innerText || contentElement.textContent || '';
            
            if (!textContent.trim()) {
                showNotification('Article has no content to copy', 'error');
                return;
            }
            
            navigator.clipboard.writeText(textContent).then(() => {
                showNotification('Article content copied to clipboard!', 'success');
            }).catch(error => {
                console.error('Error copying to clipboard:', error);
                showNotification('Failed to copy article content', 'error');
            });
        } catch (error) {
            console.error('Error copying article content:', error);
            showNotification('Failed to copy article content', 'error');
        }
    }
    
    // Explicitly attach to window for inline onclick handlers
    window.copyArticleContentToClipboard = copyArticleContentToClipboard;
    
    // Export article to PDF and open for printing
    async function exportArticleToPDF() {
        try {
            const contentElement = document.getElementById('article-content');
            const articleTitle = document.querySelector('h1.text-3xl')?.textContent || 'Article';
            
            if (!contentElement) {
                showNotification('Article content element not found', 'error');
                return;
            }
            
            // Check if html2pdf is loaded
            if (typeof html2pdf === 'undefined') {
                showNotification('PDF library not loaded. Please refresh the page.', 'error');
                return;
            }
            
            showNotification('Generating PDF...', 'info');
            
            // Create a print-friendly container that will be visible during capture
            const printContainer = document.createElement('div');
            printContainer.id = 'pdf-export-container';
            printContainer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 800px;
                max-width: 100vw;
                min-height: 600px;
                padding: 40px;
                margin: 0;
                font-family: Arial, sans-serif;
                background: white;
                color: black;
                z-index: 99999;
                overflow: visible;
                box-shadow: 0 0 20px rgba(0,0,0,0.3);
                box-sizing: border-box;
            `;
            
            // Add title
            const titleElement = document.createElement('h1');
            titleElement.textContent = articleTitle;
            titleElement.style.cssText = 'font-size: 24px; font-weight: bold; margin-bottom: 20px; color: #000; line-height: 1.4;';
            printContainer.appendChild(titleElement);
            
            // Get HTML content to preserve highlights
            let contentHtml = contentElement.innerHTML;
            
            if (!contentHtml || contentHtml.trim().length === 0) {
                const textContent = contentElement.textContent || contentElement.innerText || '';
                if (!textContent || textContent.trim().length === 0) {
                    showNotification('Article has no content to export', 'error');
                    return;
                }
                contentHtml = '<div>' + textContent + '</div>';
            }
            
            // Create a wrapper for the content with print-friendly styles
            const contentWrapper = document.createElement('div');
            contentWrapper.style.cssText = `
                color: #000000;
                background: #ffffff;
                border: 1px solid #cccccc;
                padding: 20px;
                font-family: 'Courier New', 'Monaco', monospace;
                font-size: 11pt;
                line-height: 1.8;
                white-space: pre-wrap;
                word-wrap: break-word;
                overflow-wrap: break-word;
                min-height: 200px;
            `;
            
            // Set HTML to preserve highlights
            contentWrapper.innerHTML = contentHtml;
            
            // Verify we have text content
            const originalTextLength = (contentElement.textContent || '').length;
            const clonedTextLength = (contentWrapper.textContent || '').length;
            
            if (clonedTextLength < originalTextLength * 0.9) {
                console.warn('Text content may have been lost:', {
                    original: originalTextLength,
                    cloned: clonedTextLength,
                    difference: originalTextLength - clonedTextLength
                });
                // Fallback: ensure we have the text
                if (clonedTextLength === 0 || clonedTextLength < originalTextLength * 0.5) {
                    // Re-add text content as fallback
                    const textNodes = [];
                    const walker = document.createTreeWalker(
                        contentElement,
                        NodeFilter.SHOW_TEXT,
                        null,
                        false
                    );
                    let node;
                    while (node = walker.nextNode()) {
                        if (node.textContent.trim()) {
                            textNodes.push(node.textContent);
                        }
                    }
                    if (textNodes.length > 0 && contentWrapper.textContent.length < textNodes.join('').length * 0.5) {
                        console.log('Restoring text content from text nodes');
                        // Create a new div with the text, preserving structure
                        const textDiv = document.createElement('div');
                        textDiv.style.cssText = contentWrapper.style.cssText;
                        textDiv.innerHTML = contentHtml;
                        // Merge text nodes back
                        contentWrapper.innerHTML = textDiv.innerHTML;
                    }
                }
            }
            
            printContainer.appendChild(contentWrapper);
            
            // Add to document first so we can process styles
            document.body.appendChild(printContainer);
            
            // Force a reflow
            printContainer.offsetHeight;
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Process all elements to make highlights print-friendly
            // First, ensure all text nodes are visible by checking parent elements
            const allElements = Array.from(contentWrapper.querySelectorAll('*'));
            
            // Also process text nodes' parent elements to ensure they're visible
            const textNodes = [];
            const textWalker = document.createTreeWalker(
                contentWrapper,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            let textNode;
            while (textNode = textWalker.nextNode()) {
                if (textNode.textContent.trim()) {
                    textNodes.push(textNode);
                }
            }
            
            // First pass: Remove purple and orange highlights (convert to plain text)
            const elementsToRemove = [];
            allElements.forEach(el => {
                const hasPurpleBg = el.classList.contains('bg-purple-100') || 
                                    el.classList.contains('bg-purple-200');
                const hasOrangeBg = el.classList.contains('bg-orange-100') || 
                                    el.classList.contains('bg-orange-200');
                
                if (hasPurpleBg || hasOrangeBg) {
                    elementsToRemove.push(el);
                }
            });
            
            // Replace purple/orange highlights with plain text
            elementsToRemove.forEach(el => {
                const textNode = document.createTextNode(el.textContent);
                if (el.parentNode) {
                    el.parentNode.replaceChild(textNode, el);
                }
            });
            
            // Second pass: Process remaining elements for styling
            const remainingElements = Array.from(contentWrapper.querySelectorAll('*'));
            remainingElements.forEach(el => {
                // Remove all dark mode classes
                const classesToRemove = Array.from(el.classList).filter(c => c.startsWith('dark:'));
                classesToRemove.forEach(c => el.classList.remove(c));
                
                // Ensure element is visible (but preserve its display type)
                const currentDisplay = window.getComputedStyle(el).display;
                if (currentDisplay === 'none') {
                    el.style.setProperty('display', 'block', 'important');
                }
                el.style.setProperty('visibility', 'visible', 'important');
                el.style.setProperty('opacity', '1', 'important');
                
                // Check if this is a highlight element - only Perfect (green) and LOLBAS (blue)
                const hasGreenBg = el.classList.contains('bg-green-100') || 
                                   el.classList.contains('bg-green-200') ||
                                   el.classList.contains('bg-green-300');
                const hasBlueBg = el.classList.contains('bg-blue-100') || 
                                  el.classList.contains('bg-blue-200');
                
                // Ensure highlight colors are visible for print (only Perfect and LOLBAS)
                if (hasGreenBg) {
                    // Perfect keyword matches - green highlight
                    el.style.setProperty('background-color', '#d1fae5', 'important'); // light green
                    el.style.setProperty('color', '#065f46', 'important'); // dark green text
                    el.style.setProperty('border', '1px solid #10b981', 'important');
                    el.style.setProperty('padding', '2px 4px', 'important');
                    el.style.setProperty('border-radius', '3px', 'important');
                } else if (hasBlueBg) {
                    // LOLBAS matches - blue highlight
                    el.style.setProperty('background-color', '#dbeafe', 'important');
                    el.style.setProperty('color', '#1e40af', 'important');
                    el.style.setProperty('border', '1px solid #3b82f6', 'important');
                    el.style.setProperty('padding', '2px 4px', 'important');
                    el.style.setProperty('border-radius', '3px', 'important');
                } else {
                    // Regular text elements - ensure black text
                    const tagName = el.tagName.toLowerCase();
                    if (['span', 'div', 'p', 'strong', 'em', 'b', 'i', 'mark', 'a'].includes(tagName)) {
                        const computedStyle = window.getComputedStyle(el);
                        const color = computedStyle.color;
                        const bgColor = computedStyle.backgroundColor;
                        
                        // If text is not black and not a highlight, make it black
                        if (color && !color.includes('rgb(0, 0, 0)') && 
                            !color.includes('rgb(1,') && !color.includes('rgb(2,')) {
                            // Only change if it's not already a colored highlight
                            if (!hasGreenBg && !hasBlueBg) {
                                el.style.setProperty('color', '#000000', 'important');
                            }
                        }
                        
                        // Remove dark backgrounds that aren't highlights
                        if (bgColor && bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent' &&
                            !hasGreenBg && !hasBlueBg) {
                            if (bgColor.includes('rgb(0,') || bgColor.includes('rgb(1,')) {
                                el.style.setProperty('background-color', 'transparent', 'important');
                            }
                        }
                    }
                }
            });
            
            // Ensure text nodes are visible
            textNodes.forEach(textNode => {
                const parent = textNode.parentElement;
                if (parent) {
                    parent.style.setProperty('color', 'inherit', 'important');
                    // If parent has no color set, ensure it's black
                    const parentColor = window.getComputedStyle(parent).color;
                    if (!parentColor || parentColor === 'rgba(0, 0, 0, 0)' || parentColor === 'transparent') {
                        parent.style.setProperty('color', '#000000', 'important');
                    }
                }
            });
            
            // Final verification - check text content again
            const finalTextLength = (contentWrapper.textContent || '').length;
            console.log('PDF export text verification:', {
                original: originalTextLength,
                final: finalTextLength,
                preserved: ((finalTextLength / originalTextLength) * 100).toFixed(1) + '%'
            });
            
            // Wait for style updates to render
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configure PDF options - ensure we capture the content
            const opt = {
                margin: [15, 15, 15, 15],
                filename: `article-${articleTitle.substring(0, 50).replace(/[^a-z0-9]/gi, '_')}.pdf`,
                image: { type: 'jpeg', quality: 0.98 },
                html2canvas: { 
                    scale: 2,
                    useCORS: true,
                    logging: false,
                    backgroundColor: '#ffffff',
                    width: printContainer.offsetWidth,
                    height: printContainer.offsetHeight,
                    windowWidth: printContainer.scrollWidth || 800,
                    windowHeight: printContainer.scrollHeight || 1200,
                    allowTaint: false,
                    removeContainer: false,
                    x: 0,
                    y: 0,
                    scrollX: 0,
                    scrollY: 0
                },
                jsPDF: { 
                    unit: 'mm', 
                    format: 'a4', 
                    orientation: 'portrait' 
                }
            };
            
            // Generate PDF and get as blob
            // html2pdf.js uses a promise chain - get the jsPDF object from the worker
            const worker = html2pdf().set(opt).from(printContainer);
            
            // Get PDF as data URL first, then convert to blob
            const pdfDataUrl = await new Promise((resolve, reject) => {
                worker.output('dataurlstring').then(resolve).catch(reject);
            });
            
            // Convert data URL to blob
            const response = await fetch(pdfDataUrl);
            const pdfBlob = await response.blob();
            
            // Clean up - remove the temporary container after a brief delay
            setTimeout(() => {
                if (printContainer && printContainer.parentNode) {
                    document.body.removeChild(printContainer);
                }
            }, 500);
            
            // Create blob URL and open in new window for printing
            const blobUrl = URL.createObjectURL(pdfBlob);
            const printWindow = window.open(blobUrl, '_blank');
            
            if (printWindow) {
                showNotification('PDF opened in new window. Ready for printing!', 'success');
                
                // Wait for PDF to load, then trigger print dialog
                printWindow.onload = function() {
                    setTimeout(() => {
                        printWindow.print();
                    }, 1000);
                };
            } else {
                // Fallback: download the PDF
                const link = document.createElement('a');
                link.href = blobUrl;
                link.download = opt.filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showNotification('PDF downloaded. Please open and print manually.', 'info');
            }
            
        } catch (error) {
            console.error('Error generating PDF:', error);
            showNotification('Failed to generate PDF: ' + error.message, 'error');
        }
    }
    
    function showNotification(message, type) {
        // Create notification element
        const notification = document.createElement('div');
        notification.className = `fixed top-4 right-4 z-50 p-4 rounded-md shadow-lg max-w-sm ${
            type === 'success' ? 'bg-emerald-500 text-white' : 
            type === 'error' ? 'bg-red-500 text-white' : 
            type === 'info' ? 'bg-blue-500 text-white' : 'bg-gray-500 text-white'
        }`;
        notification.textContent = message;
        
        // Add to page
        document.body.appendChild(notification);
        
        // Remove after 3 seconds
        setTimeout(() => {
            notification.remove();
        }, 3000);
    }
    
    function markOperationComplete(operationId, status = 'completed') {
        console.log('markOperationComplete called with:', operationId, status);
        
        // Update operation status in localStorage
        const ongoingOps = JSON.parse(localStorage.getItem('ongoingAIOperations') || '[]');
        const operationIndex = ongoingOps.findIndex(op => op.id === operationId);
        
        console.log('Found operation at index:', operationIndex, 'Operations:', ongoingOps);
        
        if (operationIndex !== -1) {
            ongoingOps[operationIndex].status = status;
            ongoingOps[operationIndex].completedAt = Date.now();
            localStorage.setItem('ongoingAIOperations', JSON.stringify(ongoingOps));
            
            // Store completion notification for cross-page display
            if (status === 'completed') {
                const completionNotification = {
                    id: `completion_${Date.now()}`,
                    operationId: operationId,
                    type: ongoingOps[operationIndex].type,
                    typeText: ongoingOps[operationIndex].typeText,
                    typeIcon: ongoingOps[operationIndex].typeIcon,
                    articleId: ongoingOps[operationIndex].articleId,
                    articleTitle: ongoingOps[operationIndex].articleTitle,
                    completedAt: Date.now()
                };
                
                console.log('Creating completion notification:', completionNotification);
                
                const completions = JSON.parse(localStorage.getItem('pendingCompletions') || '[]');
                completions.push(completionNotification);
                localStorage.setItem('pendingCompletions', JSON.stringify(completions));
                
                console.log('Stored pending completions:', completions);
            }
        }
    }
    
    function showCompletionBanner(type, typeText, typeIcon, articleId = null, articleTitle = null) {
        console.log('showCompletionBanner called with:', type, typeText, typeIcon, articleId, articleTitle);
        
        // Create completion banner
        const banner = document.createElement('div');
        banner.id = 'completionBanner';
        banner.className = 'fixed top-4 right-4 z-50 p-4 rounded-md shadow-lg max-w-sm bg-emerald-500 text-white';
        
        const bannerArticleTitle = articleTitle ? 
            articleTitle.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : 
            ({{ article.title | tojson }});
        const bannerArticleId = articleId || {{ article.id|default(0)|int }};
        
        banner.innerHTML = `
            <div class="flex items-center space-x-2">
                <span class="text-lg">${typeIcon}</span>
                <div class="flex-1">
                    <div class="font-medium">${typeText} Complete!</div>
                    <div class="text-sm opacity-90">Article: ${bannerArticleTitle.length > 30 ? bannerArticleTitle.substring(0, 30) + '...' : bannerArticleTitle}</div>
                    <a href="#" onclick="event.preventDefault(); window.location.hash = '${type}'; setTimeout(() => window.location.reload(), 100);" class="text-sm underline hover:no-underline">View Results ‚Üí</a>
                </div>
                <button onclick="this.parentElement.parentElement.remove()" class="text-white hover:text-gray-200">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
        `;
        
        // Add to page
        document.body.appendChild(banner);
        console.log('Banner added to DOM:', banner);
        
        // Remove after 10 seconds
        setTimeout(() => {
            const bannerElement = document.getElementById('completionBanner');
            if (bannerElement) {
                console.log('Removing banner after 10 seconds');
                bannerElement.remove();
            }
        }, 10000);
    }
    // Navigation functions
    async function navigateToNextUnclassified(retryCount = 0) {
        try {
            const response = await fetch(`/api/articles/next-unclassified?current_article_id={{ article.id|default(0)|int }}`);
            const data = await response.json();
            
            if (data.article_id) {
                window.location.href = `/articles/${data.article_id}`;
            } else {
                // If no article found and we haven't retried yet, wait and retry once
                if (retryCount === 0) {
                    console.log('No unclassified article found, retrying in 1 second...');
                    setTimeout(() => {
                        navigateToNextUnclassified(1);
                    }, 1000);
                } else {
                    showNotification('No more unclassified articles found!', 'info');
                }
            }
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        }
    }
    
    async function navigateToPrevious() {
        try {
            const currentId = {{ article.id|default(0)|int }};
            const response = await fetch(`/api/articles/previous?current_article_id=${currentId}`);
            const data = await response.json();
            
            if (data.article_id) {
                window.location.href = `/articles/${data.article_id}`;
            } else {
                showNotification('No previous article found', 'info');
            }
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        }
    }
    
    async function navigateToNext() {
        try {
            const currentId = {{ article.id|default(0)|int }};
            const response = await fetch(`/api/articles/next?current_article_id=${currentId}`);
            const data = await response.json();
            
            if (data.article_id) {
                window.location.href = `/articles/${data.article_id}`;
            } else {
                showNotification('No next article found', 'info');
            }
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        }
    }
    
    // AL/ML Assistant Functions
    async function showAIAssistant() {
        // Get AI model from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const aiModel = settings.aiModel || 'chatgpt';
        
        // Get current LMStudio model name if using LMStudio
        let lmstudioModelName = null;
        if (aiModel === 'lmstudio') {
            try {
                const lmstudioResponse = await fetch('/api/lmstudio-models');
                if (lmstudioResponse.ok) {
                    const lmstudioData = await lmstudioResponse.json();
                    if (lmstudioData.success && lmstudioData.models && lmstudioData.models.length > 0) {
                        lmstudioModelName = lmstudioData.models[0];
                    }
                }
            } catch (error) {
                console.log('Failed to fetch LMStudio model name:', error);
            }
        }
        
        // Check content size limits
        const contentLength = {{ article.content|length if article.content else 0 }};
        const contentLimit = aiModel === 'chatgpt' ? {{ chatgpt_content_limit|default(1000000)|int }} :
                           aiModel === 'anthropic' ? {{ anthropic_content_limit|default(1000000)|int }} : {{ chatgpt_content_limit|default(1000000)|int }};

        if (contentLength > contentLimit) {
            const modelName = aiModel === 'chatgpt' ? 'ChatGPT' :
                            aiModel === 'anthropic' ? 'Claude' :
                            aiModel === 'tinyllama' ? 'TinyLlama' :
                            aiModel === 'lmstudio' ? (lmstudioModelName || 'LMStudio') : 'LLM';
            showNotification(`Article too large for ${modelName}. Content: ${contentLength.toLocaleString()} chars, limit: ${contentLimit.toLocaleString()} chars.`, 'warning');
            return;
        }
        
        // Get current article classification
        // Get threat hunting score for SIGMA warning
        const threatHuntingScore = {{ article.article_metadata.get('threat_hunting_score', 0) if article.article_metadata and article.article_metadata.get('threat_hunting_score') else 0 }};
        const showSigmaWarning = threatHuntingScore < 65;
        

        
        // Fetch fresh data from API to get current state
        let hasSigmaRules = {{ 'true' if article.article_metadata and article.article_metadata.get('sigma_rules') else 'false' }};

        let hasRanking = {{ 'true' if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'false' }};

        
        try {
            const response = await fetch(`/api/articles/{{ article.id|default(0)|int }}`);
            if (response.ok) {
                const data = await response.json();
                if (data.article_metadata) {
                    hasSigmaRules = data.article_metadata.sigma_rules ? true : false;

                    hasRanking = data.article_metadata.gpt4o_ranking ? true : false;
                }
            }
        } catch (error) {
            console.log('Failed to fetch fresh data, using template data:', error);
        }
        
        // Remove any existing modal first (direct removal to avoid ModalManager interference)
        const existingModal = document.getElementById('aiAssistantModal');
        if (existingModal) {
            // Remove from ModalManager stack if present
            if (window.ModalManager) {
                const stack = window.ModalManager.getStack();
                while (stack.includes('aiAssistantModal')) {
                    const index = stack.indexOf('aiAssistantModal');
                    stack.splice(index, 1);
                }
            }
            // Remove from DOM
            existingModal.remove();
        }
        
        // Small delay to ensure cleanup completes
        await new Promise(resolve => setTimeout(resolve, 10));
        
        const modal = document.createElement('div');
        modal.id = 'aiAssistantModal';
        modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50 flex items-center justify-center';
        
        // Determine if there is existing generated content to display/regenerate
        const hasExisting = hasSigmaRules || hasRanking;
        const rankingButtonText = hasRanking ? 
            (aiModel === 'chatgpt' ? 'Display GPT4o Rank' : 
             aiModel === 'anthropic' ? 'Display Claude Rank' : 'Display LLM Rank') :
            (aiModel === 'chatgpt' ? 'Rank with GPT4o' : 
             aiModel === 'anthropic' ? 'Rank with Claude' : 'Rank with LLM');
        
        // Build model display text
        let modelDisplayText = '';
        if (aiModel === 'chatgpt') {
            modelDisplayText = 'ChatGPT (OpenAI)';
        } else if (aiModel === 'anthropic') {
            modelDisplayText = 'Claude (Anthropic)';
        } else if (aiModel === 'tinyllama') {
            modelDisplayText = 'TinyLlama (Local Ollama)';
        } else if (aiModel === 'lmstudio') {
            modelDisplayText = lmstudioModelName ? `LMStudio ‚Üí ${lmstudioModelName}` : 'LMStudio (Local)';
        } else {
            modelDisplayText = 'LLM (Local)';
        }
        
        modal.innerHTML = `
            <div class="bg-gray-800 border border-gray-700 rounded-xl shadow-2xl p-6 max-w-md w-full mx-4">
                <div class="mt-3 text-center">
                    <h3 class="text-lg font-medium text-gray-50 mb-4">ü§ñ AL/ML Assistant</h3>
                    <p class="text-sm text-gray-400 mb-4">One shot LLM demos for this article's content. Uses LLM chosen in Settings Page</p>
                    
                    <div class="mb-4 p-2 bg-[#0a0e1a] border border-gray-700 rounded text-xs text-gray-300" id="aiModelDisplay">
                        Using: ${modelDisplayText}
                    </div>
                    
                    <div class="space-y-3">
                        <button onclick="generateAIAnalysis('sigma')"
                                class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-[#4b4e77] hover:bg-[#7C3AED] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors"
                                title="${hasSigmaRules ? 'Display existing SIGMA detection rules' : 'Generate SIGMA detection rules for this article'}">
                            <span class="mr-2">üîç</span>
                            ${hasSigmaRules ? 'Display SIGMA Rules' : 'One Shot SIGMA'}
                            ${showSigmaWarning ? '<span class="ml-2 text-yellow-300">‚ö†Ô∏è</span>' : ''}
                        </button>
                        ${showSigmaWarning ? '<div class="text-xs text-amber-400 text-center mt-1">‚ö†Ô∏è Low threat hunting score (' + threatHuntingScore + '/100) - SIGMA rules may lack technical depth</div>' : ''}
                        

                        <button onclick="generateAIAnalysis('ranking')" 
                                class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-[#4b4e77] hover:bg-[#7C3AED] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                            <span class="mr-2">üìä</span>
                            ${rankingButtonText}
                        </button>
                        
                        
                        <button onclick="showCustomPromptModal()" 
                                class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-[#4b4e77] hover:bg-[#7C3AED] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                            <span class="mr-2">üí¨</span>
                            Custom Prompt
                        </button>
                    </div>

                    <div class="mt-6 text-center">
                        <p class="text-sm text-gray-400 mb-4">MLOps Features/Demos</p>
                        
                        <div class="space-y-3">
                            <button onclick="detectOS()" 
                                    class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-[#4b4e77] hover:bg-[#7C3AED] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                                <span class="mr-2">üíª</span>
                                Detect Operating System
                            </button>

                            <button onclick="showChunkDebugModal()" 
                                    class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-[#4b4e77] hover:bg-[#7C3AED] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                                <span class="mr-2">üîç</span>
                                Junk Filter Tuning
                            </button>
                            
                            <button onclick="generateAIAnalysis('cmdlines')" 
                                    class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-[#4b4e77] hover:bg-[#7C3AED] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                                <span class="mr-2">üßæ</span>
                                Extract CMDlines with CTI-BERT
                            </button>

                            <button onclick="closeAIAssistantModal()" 
                                    class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-gray-400 hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400 transition-colors">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Append modal to body
        document.body.appendChild(modal);
        
        // Ensure modal is visible (not hidden)
        modal.classList.remove('hidden');
        
        // Register and open with ModalManager
        if (window.ModalManager) {
            // Small delay to let mutation observer settle
            setTimeout(() => {
                window.ModalManager.register('aiAssistantModal', {
                    isDynamic: true,
                    hasInput: false
                });
                window.ModalManager.open('aiAssistantModal');
                // Ensure it's visible
                modal.classList.remove('hidden');
            }, 50);
        }
        
        // If LMStudio and model name wasn't fetched yet, update it asynchronously
        if (aiModel === 'lmstudio' && !lmstudioModelName) {
            fetch('/api/lmstudio-models')
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.models && data.models.length > 0) {
                        const modelDisplay = document.getElementById('aiModelDisplay');
                        if (modelDisplay) {
                            modelDisplay.textContent = `Using: LMStudio ‚Üí ${data.models[0]}`;
                        }
                    }
                })
                .catch(error => {
                    console.log('Failed to fetch LMStudio model name:', error);
                });
        }
    }
    
    function closeAIAssistantModal() {
        if (window.ModalManager) {
            window.ModalManager.close('aiAssistantModal');
        } else {
            const modal = document.getElementById('aiAssistantModal');
            if (modal) {
                modal.remove();
            }
        }
    }
    

    
    async function generateAIAnalysis(type, forceRegenerate = false, useLLMValidation = false) {
        closeAIAssistantModal();
        
        // Check for existing content first (unless force regenerate)
        if (!forceRegenerate) {
            if (type === 'sigma' && (window.latestSigmaData || {{ 'true' if article.article_metadata and article.article_metadata.get('sigma_rules') else 'false' }})) {
                // Use the latest generated data if available, otherwise fall back to page data
                const sigmaData = window.latestSigmaData || {{ article.article_metadata.get('sigma_rules') | tojson if article.article_metadata and article.article_metadata.get('sigma_rules') else 'null' }};
                console.log('Using sigma data:', window.latestSigmaData ? 'from window.latestSigmaData' : 'from page template');
                // Parse conversation log if it's a string
                if (sigmaData && sigmaData.metadata && sigmaData.metadata.conversation && typeof sigmaData.metadata.conversation === 'string') {
                    try {
                        sigmaData.metadata.conversation = JSON.parse(sigmaData.metadata.conversation);
                    } catch (e) {
                        console.error('Failed to parse conversation log:', e);
                        sigmaData.metadata.conversation = [];
                    }
                }
                showSigmaRulesModal(sigmaData.rules, sigmaData);
                return;
            }
            
            if (type === 'cmdlines' && (window.latestCommandLines || {{ 'true' if article.article_metadata and article.article_metadata.get('extracted_command_lines') else 'false' }})) {
                const templateCmdlineData = {{ article.article_metadata.get('extracted_command_lines') | tojson if article.article_metadata and article.article_metadata.get('extracted_command_lines') else 'null' }};
                const cmdlineData = window.latestCommandLines || templateCmdlineData;
                console.log('Using command line data:', window.latestCommandLines ? 'from window.latestCommandLines' : 'from page template');
                if (cmdlineData) {
                    showCommandLinesModal(cmdlineData.command_lines, cmdlineData);
                    return;
                }
            }

            
            
            if (type === 'ranking' && {{ 'true' if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'false' }}) {
                const rankingData = {{ article.article_metadata.get('gpt4o_ranking') | tojson if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'null' }};
                showGPT4oRankingModal(rankingData.analysis, rankingData);
                return;
            }
        }
        

        
        // Get AI model from settings - ALWAYS respect user's explicit choice
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        let aiModel = settings.aiModel || 'chatgpt';
        
        // NEVER override user's explicit model selection - if they chose LMStudio, use it
        // Having API keys configured doesn't mean they want to use them
        
        // Only set API key for cloud models that require it
        let apiKey = null;
        if (aiModel === 'anthropic') {
            apiKey = settings.aiAnthropicApiKey;
        } else if (aiModel === 'chatgpt') {
            apiKey = settings.aiOpenaiApiKey;
        }
        
        // DEBUG: Log what we got from localStorage
        console.log(`üîç DEBUG: aiModel="${aiModel}", aiOpenaiApiKey exists=${!!settings.aiOpenaiApiKey}, aiAnthropicApiKey exists=${!!settings.aiAnthropicApiKey}`);
        console.log(`üîç DEBUG: apiKey after selection=${apiKey ? 'EXISTS' : 'NULL'}, type=${typeof apiKey}, length=${apiKey ? apiKey.length : 0}`);
        
        if (apiKey) {
            console.log(`üîç DEBUG localStorage: apiKey type: ${typeof apiKey}, length: ${apiKey.length}, ends_with: ...${apiKey.substring(apiKey.length - 4)}`);
            console.log(`üîç DEBUG localStorage: Full key check - ends with "1WQA": ${apiKey.endsWith('1WQA')}, ends with "gkMA": ${apiKey.endsWith('gkMA')}`);
            
            // CRITICAL: Detect if key is corrupted (ends with gkMA instead of expected 1WQA)
            if (apiKey.endsWith('gkMA')) {
                console.error(`‚ùå CORRUPTED API KEY DETECTED: Key ends with 'gkMA' instead of expected '1WQA'`);
                console.error(`‚ùå This indicates localStorage corruption. The key must be re-entered in Settings.`);
                showNotification(
                    '‚ö†Ô∏è API key appears corrupted in localStorage (ends with gkMA). Please go to Settings and re-enter your OpenAI API key.',
                    'error'
                );
                return;
            }
        } else {
            // DEBUG: More detailed logging when apiKey is null
            console.warn(`‚ö†Ô∏è DEBUG: apiKey is NULL. aiModel="${aiModel}", settings keys:`, {
                hasOpenaiKey: !!settings.aiOpenaiApiKey,
                hasAnthropicKey: !!settings.aiAnthropicApiKey,
                openaiKeyLength: settings.aiOpenaiApiKey ? settings.aiOpenaiApiKey.length : 0,
                anthropicKeyLength: settings.aiAnthropicApiKey ? settings.aiAnthropicApiKey.length : 0
            });
        }
        
        // Strip whitespace from API key (common issue when copying/pasting)
        if (apiKey && typeof apiKey === 'string') {
            const beforeTrim = apiKey;
            apiKey = apiKey.trim();
            
            // DEBUG: Check if trim changed anything
            if (beforeTrim !== apiKey) {
                console.warn(`‚ö†Ô∏è API key had whitespace - trimmed from ${beforeTrim.length} to ${apiKey.length}`);
            }
            
            // Validate key format before using
            if (!apiKey.startsWith('sk-')) {
                console.error(`‚ùå ERROR: API key doesn't start with 'sk-': ${apiKey.substring(0, 10)}...`);
                showNotification('Invalid API key format in localStorage. Please re-enter your API key in Settings.', 'error');
                return;
            }
            
            if (apiKey.startsWith('sk-proj-') && apiKey.length < 100) {
                console.error(`‚ùå ERROR: API key appears truncated: length ${apiKey.length} (expected 100+ for sk-proj- keys)`);
                showNotification('API key appears truncated in localStorage. Please re-enter your API key in Settings.', 'error');
                return;
            }
            
            // Update localStorage with trimmed value to persist the fix
            if (aiModel === 'anthropic') {
                settings.aiAnthropicApiKey = apiKey;
            } else if (aiModel === 'chatgpt') {
                settings.aiOpenaiApiKey = apiKey;
            }
            localStorage.setItem('ctiScraperSettings', JSON.stringify(settings));
        }
        // For local models like lmstudio, apiKey remains null
        
        if ((aiModel === 'chatgpt' || aiModel === 'anthropic') && !apiKey) {
            const keyType = aiModel === 'anthropic' ? 'Anthropic' : 'OpenAI';
            console.error(`‚ùå ERROR: ${keyType} API key not found! aiModel="${aiModel}", apiKey is ${apiKey ? 'NOT NULL' : 'NULL'}`);
            console.error(`‚ùå DEBUG: Full settings from localStorage:`, {
                aiModel: settings.aiModel,
                hasOpenaiKey: !!settings.aiOpenaiApiKey,
                hasAnthropicKey: !!settings.aiAnthropicApiKey,
                openaiKeyLength: settings.aiOpenaiApiKey ? settings.aiOpenaiApiKey.length : 0,
                anthropicKeyLength: settings.aiAnthropicApiKey ? settings.aiAnthropicApiKey.length : 0,
                allSettingsKeys: Object.keys(settings)
            });
            showNotification(`Please configure your ${keyType} API key in Settings first. Make sure to click "Save Settings" after entering the key.`, 'error');
            return;
        }
        
        // Store ongoing AI operation in localStorage for cross-page tracking
        const articleId = {{ article.id|default(0)|int }};
        const operationId = `ai_${type}_${articleId}_${Date.now()}`;
        const operationData = {
            id: operationId,
            type: type,
            typeText:
                type === 'sigma'
                    ? 'SIGMA Rules'
                    : type === 'ranking'
                        ? aiModel === 'chatgpt'
                            ? 'GPT4o Ranking'
                            : 'Local AI Ranking'
                        : type === 'cmdlines'
                            ? 'Command Lines'
                            : 'IOCs',
            typeIcon:
                type === 'sigma'
                    ? 'üîç'
                    : type === 'ranking'
                        ? 'üìä'
                        : type === 'cmdlines'
                            ? 'üíª'
                            : 'üîç',
            articleId: articleId,
            articleTitle: {{ article.title | tojson }},
            startedAt: Date.now(),
            status: 'running'
        };
        
        // Store in localStorage
        const ongoingOps = JSON.parse(localStorage.getItem('ongoingAIOperations') || '[]');
        ongoingOps.push(operationData);
        localStorage.setItem('ongoingAIOperations', JSON.stringify(ongoingOps));
        
        // Show loading modal
        const loadingModal = document.createElement('div');
        loadingModal.id = 'loadingModal';
        loadingModal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50 flex items-center justify-center p-4';
        
        const typeText = operationData.typeText;
        const typeIcon = operationData.typeIcon;
        
        // Debug logging
        console.log('generateAIAnalysis called with type:', type);
        console.log('typeText:', typeText);
        console.log('typeIcon:', typeIcon);
        
        // Track if request has started
        let requestStarted = false;
        
        // Create AbortController for cancellation
        const abortController = new AbortController();
        let isCancelled = false;
        
        // Cancel handler function
        const handleCancel = function() {
            if (requestStarted && !isCancelled) {
                isCancelled = true;
                abortController.abort();
                markOperationComplete(operationId, 'cancelled');
                showNotification(`${typeText} ${type === 'sigma' ? 'generation' : type === 'ranking' ? 'generation' : 'extraction'} cancelled`, 'info');
            }
            const modal = document.getElementById('loadingModal');
            if (modal && modal.parentNode) {
                modal.remove();
            }
            document.removeEventListener('keydown', handleEsc);
        };
        
        // Close modal when clicking outside (dismiss without cancelling)
        loadingModal.addEventListener('click', function(e) {
            if (e.target === loadingModal) {
                const modal = document.getElementById('loadingModal');
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleEsc);
            }
        });
        
        // Add ESC key handler to close loading modal (dismiss without cancelling)
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                // ESC just closes the modal, operation continues in background
                const modal = document.getElementById('loadingModal');
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        const loadingVerb = (type === 'sigma' || type === 'ranking') ? 'Generating' : 'Extracting';
        const loadingDescription = type === 'sigma'
            ? 'Creating detection rules'
            : type === 'ranking'
                ? (aiModel === 'chatgpt' ? 'Analyzing content with GPT-4o' : 'Analyzing content with local AI')
                : type === 'cmdlines'
                    ? 'Extracting command lines with CMDCaliper'
                    : 'Extracting indicators of compromise';

        loadingModal.innerHTML = `
            <div class="bg-gray-800 border border-gray-700 rounded-xl shadow-2xl p-6 max-w-md mx-4">
                <div class="mt-3 text-center">
                    <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-purple-500/20">
                        <svg class="animate-spin h-6 w-6 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <h3 class="text-lg font-medium text-gray-50 mt-4">${typeIcon} ${loadingVerb} ${typeText}...</h3>
                    <p class="text-sm text-gray-400 mt-2">${loadingDescription} - this may take a few moments.</p>
                    <div class="mt-6 flex flex-col items-center space-y-3">
                        <button id="cancelBtn" class="px-6 py-2.5 bg-red-500 hover:bg-red-600 text-white text-sm font-medium rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-gray-900 shadow-sm transition-colors">
                            Cancel Operation
                        </button>
                        <div class="flex items-center space-x-2 text-sm text-gray-400">
                            <span>Press</span>
                            <kbd class="px-2 py-1 bg-[#0a0e1a] border border-gray-700 rounded text-xs font-semibold text-gray-300 shadow-sm">ESC</kbd>
                            <span>or click outside to dismiss (operation continues)</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(loadingModal);
        
        // Wire up cancel button
        const cancelBtn = loadingModal.querySelector('#cancelBtn');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', handleCancel);
        }
        
        try {
            // Create a timeout promise - longer for LLM operations
            const timeoutPromise = new Promise((_, reject) => {
                const timeoutMs = aiModel === 'chatgpt' ? 180000 : 600000; // 180s for ChatGPT, 600s for LLM
                setTimeout(() => reject(new Error(`Request timed out after ${timeoutMs/1000} seconds`)), timeoutMs);
            });
            
            // Create the fetch promise
            const endpoint = type === 'sigma'
                ? 'generate-sigma'
                : type === 'ranking'
                    ? 'rank-with-gpt4o'
                    : type === 'cmdlines'
                        ? 'extract-command-lines'
                        : 'extract-iocs';
            
            // Prepare request body
            const requestBody = {
                include_content: true,
                force_regenerate: forceRegenerate,
                ai_model: aiModel,
                temperature: parseFloat(settings.aiTemperature || '0.3')
            };
            
            // Only include API key if it's provided (for cloud models)
            if (apiKey) {
                // DEBUG: Log before assignment
                console.log(`üîç DEBUG Frontend: apiKey type: ${typeof apiKey}, length: ${apiKey.length}, ends_with: ...${apiKey.substring(apiKey.length - 4)}`);
                requestBody.api_key = apiKey;
                // DEBUG: Log after assignment
                console.log(`üîç DEBUG Frontend: requestBody.api_key type: ${typeof requestBody.api_key}, length: ${requestBody.api_key.length}, ends_with: ...${requestBody.api_key.substring(requestBody.api_key.length - 4)}`);
                // Debug logging (masked for security)
                const apiKeyPreview = apiKey.length > 12 ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 4)}` : 'N/A';
                console.log(`üîë Sending API key with length: ${apiKey.length}, preview: ${apiKeyPreview}`);
                // DEBUG: Log full request body size
                console.log(`üîç DEBUG Frontend: requestBody JSON size: ${JSON.stringify(requestBody).length} chars`);
            } else {
                console.warn(`‚ö†Ô∏è No API key available for model: ${aiModel}`);
            }
            

            
            // Add author name for SIGMA rules
            if (type === 'sigma') {
                const sigmaAuthor = settings.sigmaAuthor || 'Huntable CTI Studio User';
                requestBody.author_name = sigmaAuthor;
            }
            
            // Add optimization options for ranking, sigma, observables, and IOC extraction with LLM validation
            // Show optimization dialog for cloud models (for all features) and for IOC extraction with LLM validation (all models)
            const shouldShowOptimization = (type === 'ranking' || type === 'sigma' || type === 'cmdlines');
            
            console.log('shouldShowOptimization:', shouldShowOptimization, 'type:', type, 'useLLMValidation:', useLLMValidation, 'aiModel:', aiModel);
            
            if (shouldShowOptimization) {
                console.log('Showing optimization dialog...');
                const optimizationOptions = await showOptimizationDialog(false);
                if (!optimizationOptions) {
                    // User dismissed the modal (ESC or Cancel) - clean up and return
                    const loadingModal = document.getElementById('loadingModal');
                    if (loadingModal && loadingModal.parentNode) {
                        loadingModal.remove();
                    }
                    document.removeEventListener('keydown', handleEsc);
                    return;
                }
                requestBody.optimization_options = optimizationOptions;
            }
            
            console.log('Making fetch request to:', `/api/articles/{{ article.id }}/${endpoint}`);
            // DEBUG: Check API key in request body before sending
            if (requestBody.api_key) {
                const keyInBody = requestBody.api_key;
                console.log(`üîç DEBUG Before Fetch: requestBody.api_key length: ${keyInBody.length}, ends_with: ...${keyInBody.substring(keyInBody.length - 4)}`);
                console.log(`üîç DEBUG Before Fetch: Key ends with "1WQA": ${keyInBody.endsWith('1WQA')}, ends with "gkMA": ${keyInBody.endsWith('gkMA')}`);
                
                // Stringify and parse back to check for corruption
                const stringified = JSON.stringify(requestBody);
                const parsedBack = JSON.parse(stringified);
                if (parsedBack.api_key) {
                    console.log(`üîç DEBUG After JSON round-trip: api_key length: ${parsedBack.api_key.length}, ends_with: ...${parsedBack.api_key.substring(parsedBack.api_key.length - 4)}`);
                    if (parsedBack.api_key !== keyInBody) {
                        console.error(`‚ùå ERROR: API key corrupted during JSON stringify/parse!`);
                        console.error(`Original: ...${keyInBody.substring(keyInBody.length - 10)}`);
                        console.error(`After:    ...${parsedBack.api_key.substring(parsedBack.api_key.length - 10)}`);
                    }
                }
            }
            console.log('Request body (without content):', {...requestBody, include_content: requestBody.include_content ? '[CONTENT INCLUDED]' : false});
            
            // Send API key in header instead of body to avoid corruption with large payloads
            const fetchHeaders = {
                'Content-Type': 'application/json',
            };
            if (apiKey) {
                // FINAL VALIDATION: Check key one more time before sending
                const keyEnd = apiKey.substring(apiKey.length - 4);
                if (keyEnd === 'gkMA') {
                    console.error(`‚ùå CORRUPTED KEY DETECTED AT SEND TIME: ends with 'gkMA'`);
                    showNotification(
                        '‚ö†Ô∏è API key corruption detected. Please go to Settings and re-enter your OpenAI API key.',
                        'error'
                    );
                    return;
                }
                
                // Use appropriate header based on model
                if (aiModel === 'anthropic') {
                    fetchHeaders['X-Anthropic-API-Key'] = apiKey;
                } else {
                    fetchHeaders['X-OpenAI-API-Key'] = apiKey;
                }
                
                // DEBUG: Log what we're actually sending
                console.log(`üîç DEBUG Send: Setting ${aiModel === 'anthropic' ? 'X-Anthropic-API-Key' : 'X-OpenAI-API-Key'} header with key ending: ...${keyEnd}`);
                
                // Remove from body to avoid potential corruption
                delete requestBody.api_key;
            }
            
            const fetchPromise = fetch(`/api/articles/{{ article.id }}/${endpoint}`, {
                method: 'POST',
                headers: fetchHeaders,
                body: JSON.stringify(requestBody),
                signal: abortController.signal
            });
            
            // Mark request as started
            requestStarted = true;
            
            // Race between fetch and timeout
            const response = await Promise.race([fetchPromise, timeoutPromise]);
            
            if (response.ok) {
                const data = await response.json();

                console.log('AI generation completed successfully:', data);

                // Show truncation warnings if any
                if (data.warnings && Array.isArray(data.warnings) && data.warnings.length > 0) {
                    data.warnings.forEach(warning => {
                        showNotification(`‚ö†Ô∏è LMStudio Truncation: ${warning}`, 'warning');
                    });
                }

                // Mark operation as complete and show banner
                markOperationComplete(operationId);
                showCompletionBanner(type, typeText, typeIcon);

                console.log('Completion banner should be showing now');

                // Update cached data and optionally show results
                if (type === 'sigma' && data.rules) {
                    // Update the page's sigmaData variable with the new rules
                    window.latestSigmaData = data;
                    console.log('‚úÖ Updated window.latestSigmaData with new SIGMA rules');

                    // Parse conversation log if needed
                    if (data.metadata && data.metadata.conversation && typeof data.metadata.conversation === 'string') {
                        try {
                            data.metadata.conversation = JSON.parse(data.metadata.conversation);
                        } catch (e) {
                            console.error('Failed to parse conversation log:', e);
                            data.metadata.conversation = [];
                        }
                    }

                    // Automatically show the new rules
                    setTimeout(() => showSigmaRulesModal(data.rules, data), 500);
                }
                else if (type === 'cmdlines' && data.command_lines) {
                    window.latestCommandLines = data;
                    console.log('‚úÖ Updated window.latestCommandLines with new command-line results');
                    setTimeout(() => showCommandLinesModal(data.command_lines, data), 500);
                }
            } else {
                const error = await response.json();
                console.log('API Error:', error);
                markOperationComplete(operationId, 'failed');
                showNotification(`${typeText} ${type === 'sigma' ? 'generation' : type === 'ranking' ? 'generation' : 'extraction'} failed: ${error.detail}`, 'error');
            }
        } catch (error) {
            // Don't show error if request was cancelled
            if (isCancelled || error.name === 'AbortError') {
                return; // Already handled in handleCancel
            }
            console.log('Caught error:', error);
            markOperationComplete(operationId, 'failed');
            if (error.message.includes('timed out')) {
                const timeoutMsg = aiModel === 'chatgpt' ? '60 seconds' : '200 seconds';
                showNotification(`${typeText} ${type === 'sigma' ? 'generation' : type === 'ranking' ? 'generation' : 'extraction'} timed out after ${timeoutMsg}. Try using a different model or check your settings.`, 'error');
            } else {
                showNotification(`Error: ${error.message}`, 'error');
            }
        } finally {
            // Remove loading modal and clean up ESC handler
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.parentNode) {
                loadingModal.remove();
            }
            // Clean up the ESC key handler
            document.removeEventListener('keydown', handleEsc);
        }
    }
    
    // Enhanced GPT4o Ranking Function with Content Filtering
    async function rankWithGPT4o() {
        const articleId = {{ article.id|default(0)|int }};
        
        // Get API key from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        let aiModel = settings.aiModel || 'chatgpt';
        
        // NEVER override user's explicit model selection - always respect Settings page choice
        
        // Only set API key for cloud models that require it
        let apiKey = null;
        if (aiModel === 'anthropic') {
            apiKey = settings.aiAnthropicApiKey;
        } else if (aiModel === 'chatgpt') {
            apiKey = settings.aiOpenaiApiKey;
        }
        // For local models like lmstudio, apiKey remains null
        
        if ((aiModel === 'chatgpt' || aiModel === 'anthropic') && !apiKey) {
            const keyType = aiModel === 'anthropic' ? 'Anthropic' : 'OpenAI';
            showNotification(`Please configure your ${keyType} API key in Settings first`, 'error');
            return;
        }
        
        // Show optimization options dialog
        const optimizationOptions = await showOptimizationDialog();
        if (!optimizationOptions) {
            return; // User cancelled
        }
        
        // Estimate cost before proceeding (only for ChatGPT)
        if (aiModel === 'chatgpt') {
            const articleContent = {{ article.content[:1000] | tojson }}; // Get first 1000 chars for estimation
            const estimatedTokens = Math.ceil(articleContent.length / 4); // Rough estimate: 1 token ‚âà 4 chars
            const promptTokens = 1508; // Updated prompt length (6,033 chars ‚âà 1,508 tokens)
            const totalTokens = estimatedTokens + promptTokens;
            
            // GPT4o pricing: $5.00 per 1M input tokens, $15.00 per 1M output tokens
            const inputCost = (totalTokens / 1000000) * 5.00;
            const outputCost = (2000 / 1000000) * 15.00; // Assume 2000 output tokens
            const totalCost = inputCost + outputCost;
            
            // Estimate cost savings if filtering is enabled
            let costSavings = 0;
            let costMessage = `Estimated cost: $${totalCost.toFixed(4)} (${totalTokens.toLocaleString()} input tokens + ~2,000 output tokens)`;
            
            if (optimizationOptions.useFiltering) {
                // Dynamic cost reduction based on confidence threshold
                // Lower confidence = more aggressive filtering = higher savings
                let savingsPercent = 0;
                if (optimizationOptions.minConfidence <= 0.5) {
                    savingsPercent = 0.6; // 60% savings for aggressive filtering
                } else if (optimizationOptions.minConfidence <= 0.7) {
                    savingsPercent = 0.4; // 40% savings for balanced filtering
                } else {
                    savingsPercent = 0.25; // 25% savings for conservative filtering
                }
                
                costSavings = totalCost * savingsPercent;
                const optimizedCost = totalCost - costSavings;
                costMessage = `Estimated cost: $${optimizedCost.toFixed(4)} (${(savingsPercent*100).toFixed(0)}% savings from content filtering)`;
            }
            
            const confirmed = confirm(`GPT4o Analysis Cost Estimate:\n\n${costMessage}\n\nOptimization: ${optimizationOptions.useFiltering ? 'Enabled' : 'Disabled'}\nConfidence Threshold: ${optimizationOptions.minConfidence}\n\nDo you want to proceed with the analysis?`);
            if (!confirmed) {
                return;
            }
        }
        
        // Show loading state
        const button = document.querySelector('button[onclick="rankWithGPT4o()"]');
        const originalText = button.innerHTML;
        button.innerHTML = '<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Analyzing...';
        button.disabled = true;
        button.classList.add('opacity-75', 'cursor-not-allowed');
        
        try {
            // Build request body conditionally
            const rankRequestBody = {
                use_filtering: optimizationOptions.useFiltering,
                min_confidence: optimizationOptions.minConfidence,
                ai_model: aiModel
            };
            
            // Send API key in header instead of body to avoid corruption with large payloads
            const rankFetchHeaders = {
                'Content-Type': 'application/json',
            };
            if (apiKey) {
                if (aiModel === 'anthropic') {
                    rankFetchHeaders['X-Anthropic-API-Key'] = apiKey;
                } else {
                    rankFetchHeaders['X-OpenAI-API-Key'] = apiKey;
                }
                // Don't include in body to avoid potential corruption
            }
            
            const response = await fetch(`/api/articles/${articleId}/rank-with-gpt4o`, {
                method: 'POST',
                headers: rankFetchHeaders,
                body: JSON.stringify(rankRequestBody)
            });
            
            if (response.ok) {
                const data = await response.json();
                
                // Show truncation warnings if any
                if (data.warnings && Array.isArray(data.warnings) && data.warnings.length > 0) {
                    data.warnings.forEach(warning => {
                        showNotification(`‚ö†Ô∏è LMStudio Truncation: ${warning}`, 'warning');
                    });
                }
                
                showGPT4oRankingModal(data.analysis, data);
                
                // Show optimization results if available
                if (data.optimization && data.optimization.enabled) {
                    const opt = data.optimization;
                    showNotification(
                        `GPT4o analysis completed! Cost savings: $${opt.cost_savings.toFixed(4)} (${opt.tokens_saved.toLocaleString()} tokens saved, ${opt.chunks_removed} chunks removed)`, 
                        'success'
                    );
                    
                    // Show debug info if available
                    if (data.debug_info && data.debug_info.removed_chunks.length > 0) {
                        showRemovedChunksDialog(data.debug_info);
                    }
                } else {
                    showNotification('GPT4o analysis completed successfully!', 'success');
                }
            } else {
                const error = await response.json();
                showNotification(`GPT4o analysis failed: ${error.detail}`, 'error');
            }
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        } finally {
            // Restore button state
            button.innerHTML = originalText;
            button.disabled = false;
            button.classList.remove('opacity-75', 'cursor-not-allowed');
        }
    }
    // Show optimization options dialog
    async function showOptimizationDialog(showQAAgent = false) {
        return new Promise((resolve) => {
            // Get AI model from settings to determine modal title
            const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
            const aiModel = settings.aiModel || 'chatgpt';
            const modelDisplayName = aiModel === 'chatgpt' ? 'GPT-4o' : 
                                    aiModel === 'anthropic' ? 'Claude' : 
                                    aiModel === 'tinyllama' ? 'TinyLlama' : 'LLM';
            
            // Create modal dialog
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-gray-800 border border-gray-700 rounded-xl shadow-2xl p-6 max-w-md w-full mx-4">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold text-gray-50">${modelDisplayName} Content Filter</h3>
                    </div>
                    
                    <div class="space-y-4">
                        <div class="flex items-center">
                            <input type="checkbox" id="useFiltering" checked class="mr-3 w-4 h-4 rounded border-gray-600 bg-[#0a0e1a] text-purple-500 focus:ring-purple-500 focus:ring-offset-gray-900">
                            <label for="useFiltering" class="text-sm text-gray-300">
                                Enable content filtering to reduce costs
                            </label>
                        </div>
                        
                        <div id="confidenceSection" class="ml-6">
                            <label for="minConfidence" class="block text-sm text-gray-300 mb-2">
                                Confidence threshold:
                            </label>
                            <select id="minConfidence" class="w-full bg-[#0a0e1a] border border-gray-700 rounded-lg px-3 py-2 text-gray-50 focus:outline-none focus:border-purple-500 focus:ring-1 focus:ring-purple-500">
                                <option value="0.5">0.5 - Aggressive filtering (~60% cost savings)</option>
                                <option value="0.7" selected>0.7 - Balanced filtering (~40% cost savings)</option>
                                <option value="0.8">0.8 - Conservative filtering (~25% cost savings)</option>
                            </select>
                            <p class="text-xs text-gray-400 mt-1">
                                Higher values keep more content but reduce cost savings
                            </p>
                        </div>
                        
                        ${showQAAgent ? `
                        <div class="border-t border-gray-700 pt-4 mt-4">
                            <div class="flex items-center">
                                <input type="checkbox" id="useQAAgent" checked class="mr-3 w-4 h-4 rounded border-gray-600 bg-[#0a0e1a] text-purple-500 focus:ring-purple-500 focus:ring-offset-gray-900">
                                <label for="useQAAgent" class="text-sm text-gray-300">
                                    Enable QA Agent validation
                                </label>
                            </div>
                            <p class="text-xs text-gray-400 mt-1 ml-6">
                                QA Agent will validate the extraction and retry according to the configured QA retry limit (default 5, max 20). This improves accuracy but increases processing time.
                            </p>
                        </div>
                        ` : ''}
                        
                        <div class="bg-blue-500/10 border border-blue-500/30 p-3 rounded-lg">
                            <h4 class="text-sm font-medium text-blue-400 mb-2">How it works:</h4>
                            <ul class="text-xs text-blue-300 space-y-1">
                                <li>‚Ä¢ Analyzes content chunks for huntability</li>
                                <li>‚Ä¢ Removes acknowledgments, marketing content</li>
                                <li>‚Ä¢ Keeps technical details, commands, IOCs</li>
                                <li>‚Ä¢ Typically saves 20-40% on costs</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="flex justify-end space-x-3 mt-6">
                        <button id="cancelBtn" class="px-4 py-2 border border-gray-600 hover:bg-gray-800 text-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            Cancel
                        </button>
                        <button id="confirmBtn" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            Analyze
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Handle checkbox change
            const useFilteringCheckbox = modal.querySelector('#useFiltering');
            const confidenceSection = modal.querySelector('#confidenceSection');
            
            useFilteringCheckbox.addEventListener('change', (e) => {
                confidenceSection.style.display = e.target.checked ? 'block' : 'none';
            });
            
            // Handle button clicks
            modal.querySelector('#cancelBtn').addEventListener('click', () => {
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                resolve(null);
            });
            
            modal.querySelector('#confirmBtn').addEventListener('click', () => {
                const useFiltering = useFilteringCheckbox.checked;
                const minConfidence = parseFloat(modal.querySelector('#minConfidence').value);
                const useQAAgent = showQAAgent ? (modal.querySelector('#useQAAgent')?.checked ?? false) : undefined;
                
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                const result = {
                    useFiltering,
                    minConfidence
                };
                if (useQAAgent !== undefined) {
                    result.useQAAgent = useQAAgent;
                }
                resolve(result);
            });
            
            // Handle escape key - just dismisses/closes the modal
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    if (modal && modal.parentNode) {
                        modal.remove();
                    }
                    document.removeEventListener('keydown', handleEscape);
                    resolve(null); // Returns null to indicate modal was dismissed
                }
            };
            document.addEventListener('keydown', handleEscape);
        });
    }
    // Show removed chunks dialog for debugging
    function showRemovedChunksDialog(debugInfo) {
        const modal = document.createElement('div');
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        
        const chunksHtml = debugInfo.removed_chunks.map((chunk, index) => `
            <div class="mb-4 p-3 bg-red-50 border border-red-200 rounded">
                <div class="flex justify-between items-center mb-2">
                    <h4 class="text-sm font-medium text-red-900">Chunk ${chunk.chunk_id}</h4>
                    <span class="text-xs text-red-600">${chunk.text.length} chars</span>
                </div>
                <div class="text-xs text-red-800 bg-white p-2 rounded border max-h-32 overflow-y-auto">
                    ${chunk.text.replace(/\n/g, '<br>')}
                </div>
                <div class="text-xs text-red-600 mt-1">
                    Reason: ${chunk.reason || 'Not huntable'} | Confidence: ${chunk.confidence && !isNaN(chunk.confidence) ? chunk.confidence.toFixed(2) : 'N/A'}
                </div>
            </div>
        `).join('');
        
        modal.innerHTML = `
            <div class="bg-gray-800 border border-gray-700 rounded-xl shadow-2xl p-6 max-w-4xl w-full mx-4 max-h-[80vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold text-gray-50">üóëÔ∏è Removed Content Chunks</h3>
                    <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-200 p-1 rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-4 p-3 bg-blue-500/10 border border-blue-500/30 rounded-lg">
                    <div class="text-sm text-blue-300">
                        <strong>Summary:</strong> ${debugInfo.chunks_removed} chunks removed 
                        (${debugInfo.reduction_percent}% content reduction)
                        <br>
                        <strong>Original:</strong> ${debugInfo.original_length.toLocaleString()} chars ‚Üí 
                        <strong>Filtered:</strong> ${debugInfo.filtered_length.toLocaleString()} chars
                    </div>
                </div>
                
                <div class="space-y-2">
                    ${chunksHtml}
                </div>
                
                <div class="mt-6 flex justify-end">
                    <button onclick="this.closest('.fixed').remove()" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Handle escape key
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);
    }
    
    async function showCustomPromptModal() {
        closeAIAssistantModal();
        await cleanupExistingModal('customPromptModal');
        
        // Get AI model from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const aiModel = settings.aiModel || 'chatgpt';
        const modelDisplayName = aiModel === 'chatgpt' ? 'ChatGPT (OpenAI)' : 
                                aiModel === 'anthropic' ? 'Claude (Anthropic)' : 
                                aiModel === 'tinyllama' ? 'TinyLlama (Local Ollama)' : 
                                aiModel === 'lmstudio' ? 'LMStudio (Local)' : 'Llama (Local Ollama)';
        
        const modal = document.createElement('div');
        modal.id = 'customPromptModal';
        modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeCustomPromptModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeCustomPromptModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        modal.innerHTML = `
            <div class="bg-gray-800 border border-gray-700 rounded-xl shadow-2xl p-6 max-w-2xl w-full mx-4">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gray-50">üí¨ Custom AI Prompt</h3>
                    <div class="flex items-center space-x-2">
                        <button onclick="showCustomHelp()" class="text-blue-400 hover:text-blue-300 text-sm px-2 py-1 rounded-lg border border-blue-500/30 hover:bg-blue-500/10 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            Help
                        </button>
                        <button onclick="closeCustomPromptModal()" class="text-gray-400 hover:text-gray-200 p-1 rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="mb-4 p-3 bg-[#0a0e1a] border border-gray-700 rounded-lg">
                    <div class="text-sm text-gray-300">
                        <p class="font-medium mb-1">ü§ñ AI Model:</p>
                        <p class="text-gray-400">${modelDisplayName}</p>
                    </div>
                </div>
                
                <div class="mb-4">
                    <label for="customPrompt" class="block text-sm font-medium text-gray-300 mb-2">
                        Your Question or Request
                    </label>
                    <textarea id="customPrompt" 
                              rows="4" 
                              class="w-full bg-[#0a0e1a] border border-gray-700 rounded-lg px-3 py-2 text-gray-50 placeholder-gray-500 focus:outline-none focus:border-purple-500 focus:ring-1 focus:ring-purple-500"
                              placeholder="Ask anything about this article. For example:&#10;- What are the main attack vectors mentioned?&#10;- How would I detect this threat in my network?&#10;- What are the key IOCs to monitor?&#10;- Explain the technical details in simple terms"></textarea>
                </div>
                
                <div class="mb-4 p-3 bg-blue-500/10 border border-blue-500/30 rounded-lg">
                    <div class="text-sm text-blue-300">
                        <p class="font-medium mb-1">üí° Tips:</p>
                        <ul class="list-disc list-inside space-y-1">
                            <li>Be specific about what you want to know</li>
                            <li>Ask for technical details, IOCs, or analysis</li>
                            <li>Request detection rules or threat hunting queries</li>
                            <li>Ask for explanations in different detail levels</li>
                        </ul>
                    </div>
                </div>
                
                <div class="flex justify-between">
                    <button onclick="showCustomPromptHistory()" 
                            class="inline-flex items-center px-4 py-2 border border-gray-600 hover:bg-gray-800 text-gray-300 text-sm font-medium rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition-colors">
                        <span class="mr-2">üìö</span>
                        View Previous Prompts
                    </button>
                    <div class="flex space-x-3">
                        <button onclick="closeCustomPromptModal()" 
                                class="inline-flex items-center px-4 py-2 border border-gray-600 hover:bg-gray-800 text-gray-300 text-sm font-medium rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition-colors">
                            Cancel
                        </button>
                        <button onclick="generateCustomPrompt()" 
                                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-lg text-white bg-purple-500 hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition-colors">
                            <span class="mr-2">ü§ñ</span>
                            Generate Response
                        </button>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        // Ensure modal is visible
        modal.classList.remove('hidden');
        
        // Register and open with ModalManager
        if (window.ModalManager) {
            setTimeout(() => {
                const submitBtn = modal.querySelector('button[onclick*="generateCustomPrompt"]');
                window.ModalManager.register('customPromptModal', {
                    isDynamic: true,
                    hasInput: true,
                    submitButton: submitBtn
                });
                window.ModalManager.open('customPromptModal');
                modal.classList.remove('hidden');
            }, 50);
        }
        
        // Add Cmd/Ctrl+Enter key handler to textarea
        const textarea = document.getElementById('customPrompt');
        if (textarea) {
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                    e.preventDefault();
                    generateCustomPrompt();
                }
            });
            // Focus the textarea
            textarea.focus();
        }
    }
    
    function closeCustomPromptModal() {
        const modal = document.getElementById('customPromptModal');
        if (modal) {
            modal.remove();
        }
    }
    
    async function generateCustomPrompt() {
        const customPrompt = document.getElementById('customPrompt').value.trim();
        
        if (!customPrompt) {
            showNotification('Please enter a question or request', 'error');
            return;
        }
        
        closeCustomPromptModal();
        
        // Get AI model from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const aiModel = settings.aiModel || 'chatgpt';
        
        // Only set API key for cloud models that require it
        let apiKey = null;
        if (aiModel === 'anthropic') {
            apiKey = settings.aiAnthropicApiKey;
        } else if (aiModel === 'chatgpt') {
            apiKey = settings.aiOpenaiApiKey;
        }
        // For local models like lmstudio, apiKey remains null
        
        if ((aiModel === 'chatgpt' || aiModel === 'anthropic') && !apiKey) {
            const keyType = aiModel === 'anthropic' ? 'Anthropic' : 'OpenAI';
            showNotification(`Please configure your ${keyType} API key in Settings first`, 'error');
            return;
        }
        
        // Show loading modal
        const loadingModal = document.createElement('div');
        loadingModal.id = 'loadingModal';
        loadingModal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50 flex items-center justify-center p-4';
        
        // Track if request has started
        let requestStarted = false;
        
        // Create AbortController for cancellation
        const abortController = new AbortController();
        let isCancelled = false;
        
        // Cancel handler function
        const handleCancel = function() {
            if (requestStarted && !isCancelled) {
                isCancelled = true;
                abortController.abort();
                showNotification('Custom prompt generation cancelled', 'info');
            }
            const modal = document.getElementById('loadingModal');
            if (modal && modal.parentNode) {
                modal.remove();
            }
            document.removeEventListener('keydown', handleEsc);
        };
        
        // Close modal when clicking outside (dismiss without cancelling)
        loadingModal.addEventListener('click', function(e) {
            if (e.target === loadingModal) {
                const modal = document.getElementById('loadingModal');
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleEsc);
            }
        });
        
        // Add ESC key handler to close loading modal (dismiss without cancelling)
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                // ESC just closes the modal, operation continues in background
                const modal = document.getElementById('loadingModal');
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        loadingModal.innerHTML = `
            <div class="mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-purple-100">
                        <svg class="animate-spin h-6 w-6 text-purple-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <h3 class="text-lg font-medium text-gray-900 mt-4">ü§ñ Processing Custom Request...</h3>
                    <p class="text-sm text-gray-500 mt-2">This may take a few moments.</p>
                    <div class="mt-6 flex flex-col items-center space-y-3">
                        <button id="cancelBtnCustom" class="px-6 py-2.5 bg-red-600 text-white text-sm font-medium rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 shadow-sm transition-colors">
                            Cancel Operation
                        </button>
                        <div class="flex items-center space-x-2 text-sm text-gray-600">
                            <span>Press</span>
                            <kbd class="px-2 py-1 bg-gray-100 border border-gray-300 rounded text-xs font-semibold text-gray-700 shadow-sm">ESC</kbd>
                            <span>or click outside to dismiss (operation continues)</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(loadingModal);
        
        // Wire up cancel button
        const cancelBtn = loadingModal.querySelector('#cancelBtnCustom');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', handleCancel);
        }
        
        try {
            // Create a timeout promise - longer for LLM operations
            const timeoutPromise = new Promise((_, reject) => {
                const timeoutMs = aiModel === 'chatgpt' ? 180000 : 600000; // 180s for ChatGPT, 600s for LLM
                setTimeout(() => reject(new Error(`Request timed out after ${timeoutMs/1000} seconds`)), timeoutMs);
            });
            
            // Build request body conditionally
            const customPromptBody = {
                prompt: customPrompt,
                ai_model: aiModel
            };
            
            // Only include API key if it's provided (for cloud models)
            if (apiKey) {
                customPromptBody.api_key = apiKey;
            }
            
            // Create the fetch promise
            const fetchPromise = fetch(`/api/articles/{{ article.id }}/custom-prompt`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(customPromptBody),
                signal: abortController.signal
            });
            
            // Mark request as started
            requestStarted = true;
            
            // Race between fetch and timeout
            const response = await Promise.race([fetchPromise, timeoutPromise]);
            
            if (response.ok) {
                const data = await response.json();
                showCustomResponseModal(data.response, customPrompt, data);
            } else {
                const error = await response.json();
                showNotification(`Custom prompt failed: ${error.detail}`, 'error');
            }
        } catch (error) {
            // Don't show error if request was cancelled
            if (isCancelled || error.name === 'AbortError') {
                return; // Already handled in handleCancel
            }
            if (error.message.includes('timed out')) {
                const timeoutMsg = aiModel === 'chatgpt' ? '60 seconds' : '200 seconds';
                showNotification(`Custom prompt timed out after ${timeoutMsg}. Try using a different model or check your settings.`, 'error');
            } else {
                showNotification(`Error: ${error.message}`, 'error');
            }
        } finally {
            // Remove loading modal and clean up ESC handler
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.parentNode) {
                loadingModal.remove();
            }
            // Clean up the ESC key handler
            document.removeEventListener('keydown', handleEsc);
        }
    }
    
    async function showCustomResponseModal(response, originalPrompt, data = null) {
        await cleanupExistingModal('customResponseModal');
        
        const modal = document.createElement('div');
        modal.id = 'customResponseModal';
        modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeCustomResponseModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeCustomResponseModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        const modelUsed = data?.ai_model || data?.model_name || 'Unknown';
        const respondedAt = data?.responded_at ? new Date(data.responded_at).toLocaleString() : 'Unknown';
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gray-900">üí¨ Custom AI Response</h3>
                    <button onclick="closeCustomResponseModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-4 p-3 bg-gray-50 rounded-md">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                        <div>
                            <span class="font-medium text-gray-700">Your Question:</span>
                            <p class="text-gray-900 mt-1">${originalPrompt}</p>
                        </div>
                        <div>
                            <span class="font-medium text-gray-700">Model Used:</span>
                            <span class="text-gray-900">${modelUsed}</span>
                        </div>
                        <div>
                            <span class="font-medium text-gray-700">Responded At:</span>
                            <span class="text-gray-900">${respondedAt}</span>
                        </div>
                    </div>
                </div>
                
                <div class="bg-gray-50 rounded-lg p-4 max-h-96 overflow-y-auto">
                    <div class="prose max-w-none">
                        <pre class="whitespace-pre-wrap text-sm text-gray-800 font-mono">${response}</pre>
                    </div>
                </div>
                
                <div class="mt-4 flex justify-end space-x-3">
                    <button onclick="showCustomPromptModal()" 
                            class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-[#4b4e77] hover:bg-[#7C3AED] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                        <span class="mr-2">üí¨</span>
                        Ask a new question
                    </button>
                    <button onclick="closeCustomResponseModal()" 
                            class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        // Ensure modal is visible
        modal.classList.remove('hidden');
        
        // Register and open with ModalManager
        if (window.ModalManager) {
            setTimeout(() => {
                window.ModalManager.register('customResponseModal', {
                    isDynamic: true,
                    hasInput: false
                });
                window.ModalManager.open('customResponseModal');
                modal.classList.remove('hidden');
            }, 50);
        }
    }
    
    function closeCustomResponseModal() {
        const modal = document.getElementById('customResponseModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function showCustomPromptHistory() {
        closeCustomPromptModal();
        
        const modal = document.createElement('div');
        modal.id = 'customPromptHistoryModal';
        modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeCustomPromptHistoryModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeCustomPromptHistoryModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        // Get stored custom prompts from article metadata
        const customPrompts = {{ article.article_metadata.get('custom_prompts', []) | tojson }};
        console.log('Custom prompts data:', customPrompts);
        console.log('Custom prompts length:', customPrompts ? customPrompts.length : 'null');
        
        let historyContent = '';
        if (customPrompts && customPrompts.length > 0) {
            console.log('Processing custom prompts...');
            historyContent = customPrompts.map((prompt, index) => {
                const respondedAt = new Date(prompt.responded_at).toLocaleString();
                const responsePreview = prompt.response.substring(0, 200) + (prompt.response.length > 200 ? '...' : '');
                
                return `
                    <div class="border border-gray-200 rounded-lg p-4 mb-4 bg-white">
                        <div class="flex justify-between items-start mb-3">
                            <div class="flex-1">
                                <h4 class="font-semibold text-gray-900 mb-2">${prompt.prompt}</h4>
                                <div class="text-sm text-gray-600 mb-2">
                                    <span class="font-medium">Model:</span> ${prompt.model_name || prompt.model_used || 'Unknown'} ‚Ä¢ 
                                    <span class="font-medium">Date:</span> ${respondedAt}
                                </div>
                            </div>
                            <button onclick="showFullPromptResponse(${index})" 
                                    class="ml-4 px-3 py-1 text-sm bg-purple-100 text-purple-700 rounded hover:bg-purple-200 transition-colors">
                                View Full
                            </button>
                        </div>
                        <div class="bg-gray-50 rounded p-3">
                            <div class="text-sm text-gray-700 font-mono whitespace-pre-wrap">${responsePreview}</div>
                        </div>
                    </div>
                `;
            }).join('');
            console.log('Generated history content:', historyContent);
        } else {
            console.log('No custom prompts found, showing empty state');
            historyContent = `
                <div class="text-center py-8 text-gray-500">
                    <div class="text-4xl mb-4">üìù</div>
                    <p class="text-lg font-medium mb-2">No Previous Prompts</p>
                    <p class="text-sm">You haven't asked any custom questions about this article yet.</p>
                </div>
            `;
        }
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-6">
                    <h3 class="text-xl font-bold text-gray-900">üìö Custom Prompt History</h3>
                    <div class="flex space-x-3">
                        <button onclick="showCustomPromptModal()" 
                                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-[#4b4e77] hover:bg-[#7C3AED] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                            <span class="mr-2">üí¨</span>
                            Ask New Question
                        </button>
                        <button onclick="closeCustomPromptHistoryModal()" class="text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="max-h-96 overflow-y-auto">
                    ${historyContent}
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        // Ensure modal is visible
        modal.classList.remove('hidden');
        
        // Register and open with ModalManager
        if (window.ModalManager) {
            setTimeout(() => {
                window.ModalManager.register('customPromptHistoryModal', {
                    isDynamic: true,
                    hasInput: false
                });
                window.ModalManager.open('customPromptHistoryModal');
                modal.classList.remove('hidden');
            }, 50);
        }
    }
    
    function closeCustomPromptHistoryModal() {
        const modal = document.getElementById('customPromptHistoryModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function showFullPromptResponse(index) {
        const customPrompts = {{ article.article_metadata.get('custom_prompts', []) | tojson }};
        if (!customPrompts || !customPrompts[index]) {
            showNotification('Prompt not found', 'error');
            return;
        }
        
        const prompt = customPrompts[index];
        closeCustomPromptHistoryModal();
        showCustomResponseModal(prompt.response, prompt.prompt, {
            model_name: prompt.model_name || prompt.model_used,
            responded_at: prompt.responded_at
        });
    }
    
    // Store generated rules globally for easy access
    let currentGeneratedSigmaRules = [];
    
    async function showSigmaRulesModal(sigmaRules, data) {
        // Remove any existing modal
        closeSigmaRulesModal();
        await cleanupExistingModal('sigmaRulesModal');
        
        // Store generated rules globally
        if (sigmaRules && Array.isArray(sigmaRules)) {
            currentGeneratedSigmaRules = sigmaRules;
        } else if (data && data.rules && Array.isArray(data.rules)) {
            currentGeneratedSigmaRules = data.rules;
        }
        
        const modal = document.createElement('div');
        modal.id = 'sigmaRulesModal';
        modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeSigmaRulesModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeSigmaRulesModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        const provider = data?.ai_model || data?.metadata?.ai_model || 'unknown';
        const modelName = data?.model_name || data?.metadata?.model_name || null;
        const modelUsed = modelName ? `${provider} ‚Äî ${modelName}` : provider;
        const generatedAt = data?.generated_at || data?.metadata?.generated_at ? new Date(data.generated_at || data.metadata.generated_at).toLocaleString() : 'Unknown';
        const temperature = data?.temperature || data?.metadata?.temperature || '0.2';
        const validationResults = data?.validation_results || data?.metadata?.validation_results || [];
        const failureError = data?.error || null;
        const hasFailure = (sigmaRules === null || sigmaRules === 'null') && failureError;
        
        // Convert sigmaRules to string if it's an object
        let sigmaRulesText = sigmaRules;
        if (typeof sigmaRules === 'object' && sigmaRules !== null) {
            // If it's an array of rules with content field, extract and format the content
            if (Array.isArray(sigmaRules) && sigmaRules.length > 0 && sigmaRules[0].content) {
                sigmaRulesText = sigmaRules.map((rule, index) => {
                    return `--- Rule ${index + 1} ---\n${rule.content.replace(/\\n/g, '\n')}`;
                }).join('\n\n');
            } else {
                sigmaRulesText = JSON.stringify(sigmaRules, null, 2);
            }
        }
        
        // Build error banner if there was a failure
        let errorBannerHtml = '';
        if (hasFailure) {
            errorBannerHtml = `
                <div class="mb-4 p-4 bg-red-50 border-2 border-red-300 rounded-lg">
                    <div class="flex items-start">
                        <span class="text-2xl mr-3">‚ö†Ô∏è</span>
                        <div class="flex-1">
                            <h4 class="font-bold text-red-900 mb-2">SIGMA Generation Failed</h4>
                            <p class="text-sm text-red-800 mb-2">${failureError}</p>
                            <p class="text-xs text-red-700">The conversation log below shows what was attempted before the failure. Click "Regenerate" to try again.</p>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Build validation status display
        let validationStatusHtml = '';
        if (validationResults.length > 0) {
            validationStatusHtml = '<div class="mb-4 p-3 bg-gray-50 rounded-lg">';
            validationStatusHtml += '<h4 class="font-medium text-gray-900 mb-2">üîç Validation Results</h4>';
            
            validationResults.forEach((result, index) => {
                const statusIcon = result.is_valid ? '‚úÖ' : '‚ùå';
                const statusColor = result.is_valid ? 'text-emerald-400' : 'text-red-600';
                const statusText = result.is_valid ? 'Valid' : 'Invalid';
                const ruleIndex = result.rule_index !== undefined ? result.rule_index : (index + 1);
                
                validationStatusHtml += `<div class="mb-2 p-2 border rounded ${result.is_valid ? 'border-green-200 bg-green-50' : 'border-red-200 bg-red-50'}">`;
                validationStatusHtml += `<div class="flex items-center mb-1">`;
                validationStatusHtml += `<span class="mr-2">${statusIcon}</span>`;
                validationStatusHtml += `<span class="font-medium ${statusColor}">Rule ${ruleIndex}: ${statusText}</span>`;
                validationStatusHtml += `</div>`;
                
                if (result.errors && result.errors.length > 0) {
                    validationStatusHtml += `<div class="text-sm text-red-600 mb-1">`;
                    validationStatusHtml += `<strong>Errors:</strong><ul class="list-disc list-inside ml-2">`;
                    result.errors.forEach(error => {
                        const escapedError = String(error).replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                        validationStatusHtml += `<li>${escapedError}</li>`;
                    });
                    validationStatusHtml += `</ul></div>`;
                }
                
                if (result.warnings && result.warnings.length > 0) {
                    validationStatusHtml += `<div class="text-sm text-amber-400 mb-1">`;
                    validationStatusHtml += `<strong>Warnings:</strong><ul class="list-disc list-inside ml-2">`;
                    result.warnings.forEach(warning => {
                        const escapedWarning = String(warning).replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                        validationStatusHtml += `<li>${escapedWarning}</li>`;
                    });
                    validationStatusHtml += `</ul></div>`;
                }
                
                if (result.rule_info) {
                    validationStatusHtml += `<div class="text-sm text-gray-600">`;
                    validationStatusHtml += `<strong>Rule Info:</strong> ${result.rule_info.title || 'Untitled'} `;
                    if (result.rule_info.level) {
                        validationStatusHtml += `(${result.rule_info.level})`;
                    }
                    validationStatusHtml += `</div>`;
                }
                
                validationStatusHtml += `</div>`;
            });
            
            validationStatusHtml += '</div>';
        }
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-6xl shadow-lg rounded-md" style="background-color: rgba(134, 153, 177, 1);">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium text-gray-900">üîç One Shot - SIGMA Detection Rules</h3>
                    <div class="flex items-center space-x-2">
                        <button onclick="showSigmaHelp()" class="text-blue-500 hover:text-blue-700 text-sm px-2 py-1 rounded border border-blue-300 hover:bg-blue-50">
                            <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            Help
                        </button>
                        <button onclick="closeSigmaRulesModal()" class="text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="mb-4 text-sm text-gray-600">
                    <span class="font-medium">Generated by:</span> ${modelUsed} | 
                    <span class="font-medium">Generated at:</span> ${generatedAt} |
                    <span class="font-medium">Temperature:</span> ${temperature}
                    ${data?.cached ? ' | <span class="font-medium text-blue-600">(Cached)</span>' : ''}
                </div>
                
                ${data?.optimization ? `
                <div class="mb-4 p-3 bg-green-50 border border-green-200 rounded-md">
                    <div class="flex items-center mb-2">
                        <span class="text-emerald-400 font-medium">üöÄ Content Optimization Applied</span>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-2 text-xs">
                        ${modelUsed.includes('gpt') || modelUsed.includes('chatgpt') ? `
                        <div>
                            <span class="font-medium text-gray-700">Cost Savings:</span>
                            <span class="text-emerald-400 font-medium">$${data.optimization.cost_savings.toFixed(4)}</span>
                        </div>
                        ` : ''}
                        <div>
                            <span class="font-medium text-gray-700">Tokens Saved:</span>
                            <span class="text-emerald-400 font-medium">${data.optimization.tokens_saved.toLocaleString()}</span>
                        </div>
                        <div>
                            <span class="font-medium text-gray-700">Chunks Removed:</span>
                            <span class="text-emerald-400 font-medium">${data.optimization.chunks_removed}</span>
                        </div>
                    </div>
                </div>
                ` : ''}
                
                ${errorBannerHtml}
                ${hasFailure ? '' : `
                <div class="mt-4">
                    <h4 class="text-md font-medium text-gray-900 mb-2">üìù SIGMA Rules</h4>
                    <div class="p-4 rounded-lg max-h-96 overflow-y-auto" style="background-color: var(--color-text-secondary);">
                        <pre class="text-sm font-mono whitespace-pre-wrap text-gray-800">${sigmaRulesText}</pre>
                    </div>
                </div>
                `}

                ${validationStatusHtml}

                <div class="mt-4">
                    <div class="flex items-center justify-between mb-2">
                        <h4 class="text-md font-medium text-gray-900">üîÑ LLM ‚Üî pySigma Conversation Log</h4>
                        <button id="toggleSigmaConversation" class="text-sm text-blue-600 hover:text-blue-800 px-3 py-1 border border-blue-300 rounded hover:bg-blue-50">
                            Show Log
                        </button>
                    </div>
                    <div class="text-xs text-gray-600 mb-2">Shows the iterative validation process between the LLM and pySigma validator</div>
                    <div id="sigmaConversationContent" style="display: none;">
                        <div id="sigmaConversation" class="space-y-4 max-h-96 overflow-y-auto p-4 bg-gray-50 rounded border">
                            <!-- Filled by script below -->
                        </div>
                    </div>
                </div>
                
                <div class="mt-4 flex justify-between items-center">
                    <div class="flex space-x-2">
                        <button onclick="regenerateSigmaRules()" 
                                class="px-4 py-2 bg-[#4b4e77] text-white rounded-md hover:bg-[#7C3AED] transition-colors">
                            üîÑ Regenerate
                        </button>
                        <button id="checkSimilarRulesBtn" onclick="checkSimilarSigmaRules(false)" 
                                class="px-4 py-2 bg-[#4b4e77] text-white rounded-md hover:bg-[#7C3AED] transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                                title="Search for similar rules in SigmaHQ repository"
                                disabled>
                            üîç Similarity Search
                        </button>
                        <button id="regenerateSimilarRulesBtn" onclick="checkSimilarSigmaRules(true)"
                                class="px-4 py-2 bg-[#4b4e77] text-white rounded-md hover:bg-[#7C3AED] transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed hidden"
                                title="Re-run similar rules search (forces re-check)">
                            üîÑ Regenerate Similar
                        </button>
                        <button id="embedArticleBtn" onclick="generateArticleEmbedding()" 
                                class="px-4 py-2 bg-[#4b4e77] text-white rounded-md hover:bg-[#7C3AED] transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                                title="Generate article embedding for semantic search"
                                disabled>
                            üß¨ Embed Article
                        </button>
                        <button id="sendToQueueBtn" onclick="sendRuleToQueue()" 
                                class="px-4 py-2 bg-[#4b4e77] text-white rounded-md hover:bg-[#7C3AED] transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                                title="Send generated rule to SIGMA Queue for review"
                                disabled>
                            üìã Send to Queue
                        </button>
                    </div>
                    <button onclick="closeSigmaRulesModal()" 
                            class="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Ensure modal is visible
        modal.classList.remove('hidden');
        
        // Register and open with ModalManager
        if (window.ModalManager) {
            setTimeout(() => {
                window.ModalManager.register('sigmaRulesModal', {
                    isDynamic: true,
                    hasInput: false
                });
                window.ModalManager.open('sigmaRulesModal');
                modal.classList.remove('hidden');
            }, 50);
        }

        // Check if article has embeddings and enable/disable buttons
        const checkBtn = document.getElementById('checkSimilarRulesBtn');
        const embedBtn = document.getElementById('embedArticleBtn');
        const queueBtn = document.getElementById('sendToQueueBtn');
        const articleId = {{ article.id|default(0)|int }};
        
        // Enable queue button if rules are available
        if (queueBtn && currentGeneratedSigmaRules && currentGeneratedSigmaRules.length > 0) {
            queueBtn.disabled = false;
        }
        
        // Fetch embedding status from API
        fetch(`/api/articles/${articleId}`)
            .then(response => response.json())
            .then(data => {
                const hasEmbedding = data.embedding && data.embedding.length > 0;
                
                if (checkBtn) {
                    if (hasEmbedding) {
                        checkBtn.disabled = false;
                        checkBtn.title = 'Search for similar rules in SigmaHQ repository';
                    } else {
                        checkBtn.disabled = true;
                        checkBtn.title = 'Article embeddings required. Click "Embed Article" below to generate.';
                    }
                }
                
                if (embedBtn) {
                    if (hasEmbedding) {
                        embedBtn.disabled = true;
                        embedBtn.textContent = '‚úì Embedded';
                        embedBtn.title = 'Article already has embedding';
                    } else {
                        embedBtn.disabled = false;
                        embedBtn.title = 'Generate article embedding for semantic search';
                    }
                }
            })
            .catch(error => {
                console.error('Failed to check embedding status:', error);
                if (checkBtn) {
                    checkBtn.disabled = true;
                    checkBtn.title = 'Unable to verify embedding status';
                }
                if (embedBtn) {
                    embedBtn.disabled = false;
                }
            });

        // Add toggle functionality for conversation log
        const toggleButton = document.getElementById('toggleSigmaConversation');
        const conversationContent = document.getElementById('sigmaConversationContent');
        if (toggleButton && conversationContent) {
            toggleButton.addEventListener('click', function() {
                if (conversationContent.style.display === 'none') {
                    conversationContent.style.display = 'block';
                    toggleButton.textContent = 'Hide Log';
                } else {
                    conversationContent.style.display = 'none';
                    toggleButton.textContent = 'Show Log';
                }
            });
        }
        
        // Render conversation entries if present
        try {
            console.log('DEBUG: data object:', data);
            console.log('DEBUG: data.metadata:', data && data.metadata);
            console.log('DEBUG: data.metadata.conversation:', data && data.metadata && data.metadata.conversation);
            const convo = (data && data.metadata && data.metadata.conversation) ? data.metadata.conversation : []; // Corrected data path
            console.log('DEBUG: convo array:', convo);
            const container = document.getElementById('sigmaConversation');
            if (container) {
                if (!convo.length) {
                    container.innerHTML = '<div class="text-sm text-gray-600 text-center py-4">‚ö†Ô∏è No conversation log available. This might be cached data from an older version.</div>';
                } else {
                    container.innerHTML = convo.map((entry, idx) => {
                        const attempt = entry.attempt || (idx + 1);
                        const attemptBadgeColor = idx === convo.length - 1 ? 'bg-emerald-500' : 'bg-blue-500';
                        const attemptIcon = idx === convo.length - 1 ? '‚úÖ' : 'üîÑ';
                        
                        // Format the messages (system + user prompts)
                        const messages = entry.messages || [];
                        const messagesHtml = messages.map((msg, msgIdx) => {
                            const role = msg.role || 'user';
                            const content = String(msg.content || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            const roleIcon = role === 'system' ? '‚öôÔ∏è' : 'üë§';
                            const roleColor = role === 'system' ? 'text-purple-700' : 'text-blue-700';
                            // COMMENTED OUT: Truncation control
                            // const preview = content.substring(0, 200) + (content.length > 200 ? '...' : '');
                            const collapsibleId = 'msg-' + idx + '-' + msgIdx;
                            
                            return '<div class="mb-2">' +
                                '<div class="flex items-center mb-1">' +
                                    '<span class="mr-2">' + roleIcon + '</span>' +
                                    '<span class="font-semibold ' + roleColor + ' text-sm uppercase">' + role + '</span>' +
                                    // COMMENTED OUT: Truncation control button
                                    // '<button onclick="toggleCollapse(\'' + collapsibleId + '\')" class="ml-2 text-xs text-blue-600 hover:text-blue-800 underline">' +
                                    //     '[toggle full content]' +
                                    // '</button>' +
                                '</div>' +
                                '<div class="bg-gray-100 p-2 rounded border border-gray-300">' +
                                    '<div id="' + collapsibleId + '-preview" class="text-xs text-gray-700">' + content + '</div>' +
                                    // COMMENTED OUT: Truncation control - showing full content directly
                                    // '<div id="' + collapsibleId + '-preview" class="text-xs text-gray-700">' + preview + '</div>' +
                                    // '<pre id="' + collapsibleId + '-full" class="text-xs whitespace-pre-wrap text-gray-800 hidden">' + content + '</pre>' +
                                '</div>' +
                            '</div>';
                        }).join('');
                        
                        // Format LLM response
                        const llmResponse = entry.llm_response || '';
                        const llmContent = String(llmResponse).replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        // COMMENTED OUT: Truncation control
                        // const llmPreview = llmContent.substring(0, 200) + (llmContent.length > 200 ? '...' : '');
                        const llmCollapsibleId = 'llm-' + idx;
                        
                        // Format validation results
                        const validation = entry.validation || [];
                        const hasErrors = validation.some(v => !v.is_valid);
                        const validationIcon = hasErrors ? '‚ùå' : '‚úÖ';
                        const validationColor = hasErrors ? 'text-red-700' : 'text-green-700';
                        
                        const validationHtml = validation.map((v, vIdx) => {
                            const errs = (v.errors || []).map(e => '<li class="text-red-700 text-xs">' + String(e).replace(/</g,'&lt;').replace(/>/g,'&gt;') + '</li>').join('');
                            const warns = (v.warnings || []).map(w => '<li class="text-yellow-700 text-xs">' + String(w).replace(/</g,'&lt;').replace(/>/g,'&gt;') + '</li>').join('');
                            const statusBadge = v.is_valid 
                                ? '<span class="px-2 py-1 text-xs bg-green-100 text-green-800 rounded">‚úÖ VALID</span>'
                                : '<span class="px-2 py-1 text-xs bg-red-100 text-red-800 rounded">‚ùå INVALID</span>';
                            const borderClass = v.is_valid ? 'border-green-300' : 'border-red-300';
                            const errsHtml = errs ? '<div class="mt-2"><strong class="text-sm text-red-800">Errors:</strong><ul class="list-disc ml-5 mt-1">' + errs + '</ul></div>' : '';
                            const warnsHtml = warns ? '<div class="mt-2"><strong class="text-sm text-yellow-800">Warnings:</strong><ul class="list-disc ml-5 mt-1">' + warns + '</ul></div>' : '';
                            
                            return '<div class="mb-3 p-3 bg-white border ' + borderClass + ' rounded">' +
                                '<div class="flex items-center justify-between mb-2">' +
                                    '<span class="font-semibold text-sm">Rule #' + (vIdx + 1) + '</span>' +
                                    statusBadge +
                                '</div>' +
                                errsHtml +
                                warnsHtml +
                            '</div>';
                        }).join('');
                        
                        return '<div class="mb-4 p-3 border border-solid rounded ' + (hasErrors ? 'bg-red-50 border-red-200' : 'bg-green-50 border-green-200') + '">' +
                            '<div class="flex items-center mb-2">' +
                                '<span class="mr-2">' + attemptIcon + '</span>' +
                                '<span class="font-medium">Attempt ' + attempt + ':</span>' +
                            '</div>' +
                            '<div class="space-y-3">' +
                                '<div class="border-l-4 border-blue-500 pl-3">' +
                                    '<div class="font-semibold text-sm text-gray-700 mb-2">üìù Prompts Sent to LLM</div>' +
                                    messagesHtml +
                                '</div>' +
                                '<div class="border-l-4 border-purple-500 pl-3">' +
                                    '<div class="flex items-center mb-2">' +
                                        '<span class="mr-2">ü§ñ</span>' +
                                        '<span class="font-semibold text-sm text-gray-700">LLM Response</span>' +
                                        // COMMENTED OUT: Truncation control button
                                        // '<button onclick="toggleCollapse(\'' + llmCollapsibleId + '\')" class="ml-2 text-xs text-blue-600 hover:text-blue-800 underline">' +
                                        //     '[toggle full response]' +
                                        // '</button>' +
                                    '</div>' +
                                    '<div class="bg-purple-50 p-3 rounded border border-purple-200">' +
                                        '<div id="' + llmCollapsibleId + '-preview" class="text-xs text-gray-700">' + llmContent + '</div>' +
                                        // COMMENTED OUT: Truncation control - showing full content directly
                                        // '<div id="' + llmCollapsibleId + '-preview" class="text-xs text-gray-700">' + llmPreview + '</div>' +
                                        // '<pre id="' + llmCollapsibleId + '-full" class="text-xs whitespace-pre-wrap text-gray-800 hidden">' + llmContent + '</pre>' +
                                    '</div>' +
                                '</div>' +
                                '<div class="border-l-4 ' + (hasErrors ? 'border-red-500' : 'border-green-500') + ' pl-3">' +
                                    '<div class="flex items-center mb-2">' +
                                        '<span class="mr-2">' + validationIcon + '</span>' +
                                        '<span class="font-semibold text-sm ' + validationColor + '">pySigma Validation</span>' +
                                    '</div>' +
                                    '<div class="space-y-2">' +
                                        validationHtml +
                                    '</div>' +
                                '</div>' +
                            '</div>' +
                        '</div>';
                    }).join('');
                }
            }
        } catch (e) {
            console.error('Failed to render sigma conversation', e);
            const container = document.getElementById('sigmaConversation');
            if (container) {
                container.innerHTML = '<div class="text-sm text-red-600">Error rendering conversation log. Check console for details.</div>';
            }
        }
    }
    
    // COMMENTED OUT: Helper function to toggle collapsible sections
    // function toggleCollapse(id) {
    //     const preview = document.getElementById(id + '-preview');
    //     const full = document.getElementById(id + '-full');
    //     if (preview && full) {
    //         preview.classList.toggle('hidden');
    //         full.classList.toggle('hidden');
    //     }
    // }
    
    function closeSigmaRulesModal() {
        const modal = document.getElementById('sigmaRulesModal');
        if (modal) {
            modal.remove();
        }
    }
    

    
    async function showIOCsModal(iocsJson, data) {
        // Remove any existing modal
        closeIOCsModal();
        await cleanupExistingModal('iocsModal');
        
        const modal = document.createElement('div');
        modal.id = 'iocsModal';
        modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeIOCsModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeIOCsModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        const modelUsed = data?.ai_model || data?.model_name || 'gpt-4';
        const extractedAt = data?.extracted_at ? new Date(data.extracted_at).toLocaleString() : 'Unknown';
        
        // Try to parse the JSON for better display
        let iocsData = {};
        let jsonError = null;
        try {
            // If iocsJson is already an array, use it directly
            if (Array.isArray(iocsJson)) {
                iocsData = iocsJson;
            } else {
                // Try to extract JSON from the response if it contains text before JSON
                let jsonText = iocsJson.trim();
                
                // If the response starts with text, try to find JSON within it
                if (!jsonText.startsWith('{') && !jsonText.startsWith('[')) {
                    const jsonMatch = jsonText.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
                    if (jsonMatch) {
                        jsonText = jsonMatch[0];
                    }
                }
                
                iocsData = JSON.parse(jsonText);
            }
        } catch (e) {
            jsonError = e.message;
        }
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-6xl shadow-lg rounded-md" style="background-color: rgba(134, 153, 177, 1);">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium text-gray-900">üîç Extracted IOCs</h3>
                    <div class="flex items-center space-x-2">
                        <button onclick="showIOCHelp()" class="text-blue-500 hover:text-blue-700 text-sm px-2 py-1 rounded border border-blue-300 hover:bg-blue-50">
                            <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            Help
                        </button>
                        <button onclick="closeIOCsModal()" class="text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="mb-4 text-sm text-gray-600">
                    ${data?.use_llm_validation ? `<span class="font-medium">Generated by:</span> ${modelUsed} (LLM Validated) | ` : ''}
                    <span class="font-medium">Extracted at:</span> ${extractedAt}
                    ${data?.cached ? ' | <span class="font-medium text-blue-600">(Cached)</span>' : ''}
                </div>
                
                ${jsonError ? `
                <div class="bg-red-50 p-4 rounded-lg mb-4">
                    <div class="text-red-800">
                        <strong>JSON Parse Error:</strong> ${jsonError}
                    </div>
                    <div class="mt-2">
                        <strong>Raw Response:</strong>
                        <pre class="text-sm mt-1 bg-gray-100 p-2 rounded overflow-x-auto">${iocsJson}</pre>
                    </div>
                </div>
                ` : `
                <div class="bg-gray-50 p-4 rounded-lg max-h-96 overflow-y-auto">
                    ${Array.isArray(iocsData) ? `
                    <div class="space-y-3">
                        <div class="text-sm text-gray-600 mb-2">
                            <strong>Total IOCs found:</strong> ${iocsData.length}
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            ${iocsData.map(ioc => `
                            <div class="bg-white p-3 rounded border">
                                <div class="flex justify-between items-start mb-2">
                                    <span class="inline-block px-2 py-1 text-xs font-medium bg-blue-100 text-blue-800 rounded capitalize">${ioc.type}</span>
                                    <span class="text-xs text-gray-500">${(ioc.confidence * 100).toFixed(0)}%</span>
                                </div>
                                <div class="font-mono text-sm text-gray-900 break-all">${ioc.value}</div>
                                ${ioc.context ? `<div class="text-xs text-gray-600 mt-1 italic">${ioc.context.substring(0, 100)}${ioc.context.length > 100 ? '...' : ''}</div>` : ''}
                            </div>
                            `).join('')}
                        </div>
                    </div>
                    ` : `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        ${Object.entries(iocsData).map(([category, items]) => `
                        <div class="bg-white p-3 rounded border">
                            <h4 class="font-medium text-gray-900 mb-2 capitalize">${category.replace(/_/g, ' ')}</h4>
                            ${items && items.length > 0 ? `
                            <ul class="text-sm text-gray-700 space-y-1">
                                ${items.map(item => `<li class="font-mono text-xs bg-gray-50 px-2 py-1 rounded">${item}</li>`).join('')}
                            </ul>
                            ` : '<p class="text-gray-500 text-sm">No items found</p>'}
                        </div>
                        `).join('')}
                    </div>
                    `}
                </div>
                `}
                
                ${(data?.llm_prompt || data?.metadata?.prompt) ? `
                <div class="mt-6 border-t pt-4">
                    <div class="flex items-center justify-between mb-2">
                        <h4 class="font-medium text-gray-900">LLM Prompt & Response</h4>
                        <button id="toggleIocLlmLog" class="text-sm text-blue-600 hover:text-blue-800 px-3 py-1 border border-blue-300 rounded hover:bg-blue-50">
                            Show Log
                        </button>
                    </div>
                    <div id="iocLlmLogContent" style="display: none;">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="bg-blue-50 p-3 rounded border border-blue-200">
                                <h5 class="font-medium text-blue-900 mb-2">Prompt</h5>
                                <pre class="text-xs text-blue-800 bg-white p-2 rounded overflow-x-auto max-h-64">${(data.llm_prompt || data.metadata.prompt).substring(0, 1000)}...</pre>
                            </div>
                            <div class="bg-green-50 p-3 rounded border border-green-200">
                                <h5 class="font-medium text-green-900 mb-2">Response</h5>
                                <pre class="text-xs text-green-800 bg-white p-2 rounded overflow-x-auto max-h-64">${(data.llm_response || data.metadata.response)?.substring(0, 1000)}...</pre>
                            </div>
                        </div>
                    </div>
                </div>
                ` : ''}
                
                <div class="mt-4 flex justify-between items-center">
                    <div class="flex items-center space-x-4">
                        <label class="flex items-center">
                            <input type="checkbox" id="llmValidationToggle" class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50" ${data?.use_llm_validation ? 'checked' : ''}>
                            <span class="ml-2 text-sm text-gray-700">Use LLM Validation</span>
                            <div class="relative group ml-1">
                                <svg class="w-4 h-4 text-gray-400 hover:text-gray-600 cursor-help" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                                <div class="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 text-white text-xs rounded-lg opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-50" style="width: 280px; white-space: normal;">
                                    <div>
                                        <strong>LLM Validation:</strong> Uses AI to validate and categorize IOCs, removing false positives and improving accuracy. API key required only for cloud models (OpenAI, Anthropic); local models (LMStudio, Ollama) work without API keys.
                                    </div>
                                    <div class="absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-gray-900"></div>
                                </div>
                            </div>
                        </label>
                        <button onclick="regenerateIOCs()" 
                                class="px-4 py-2 bg-orange-600 text-white rounded-md hover:bg-orange-700 transition-colors">
                            üîÑ Regenerate
                        </button>
                    </div>
                    <button onclick="closeIOCsModal()" 
                            class="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Ensure modal is visible
        modal.classList.remove('hidden');
        
        // Register and open with ModalManager
        if (window.ModalManager) {
            setTimeout(() => {
                window.ModalManager.register('iocsModal', {
                    isDynamic: true,
                    hasInput: false
                });
                window.ModalManager.open('iocsModal');
                modal.classList.remove('hidden');
            }, 50);
        }
        
        // Add toggle functionality for IOC LLM log
        const iocLlmToggleButton = document.getElementById('toggleIocLlmLog');
        const iocLlmLogContent = document.getElementById('iocLlmLogContent');
        if (iocLlmToggleButton && iocLlmLogContent) {
            iocLlmToggleButton.addEventListener('click', function() {
                if (iocLlmLogContent.style.display === 'none') {
                    iocLlmLogContent.style.display = 'block';
                    iocLlmToggleButton.textContent = 'Hide Log';
                } else {
                    iocLlmLogContent.style.display = 'none';
                    iocLlmToggleButton.textContent = 'Show Log';
                }
            });
        }
    }
    
    function closeIOCsModal() {
        const modal = document.getElementById('iocsModal');
        if (modal) {
            modal.remove();
        }
    }

    let commandLinesEscHandler = null;

    function escapeHtml(value) {
        if (value === undefined || value === null) {
            return '';
        }
        return value
            .toString()
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }

    async function showCommandLinesModal(commandLines = [], metadata = {}) {
        closeCommandLinesModal();
        await cleanupExistingModal('commandLinesModal');
        
        const modal = document.createElement('div');
        modal.id = 'commandLinesModal';
        modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50';
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeCommandLinesModal();
            }
        });

        commandLinesEscHandler = function(e) {
            if (e.key === 'Escape') {
                closeCommandLinesModal();
            }
        };
        document.addEventListener('keydown', commandLinesEscHandler);

        const extractedAt = metadata?.extracted_at
            ? new Date(metadata.extracted_at).toLocaleString()
            : 'Unknown';
        const filterInfo = metadata?.content_filtering || { enabled: false };
        const filterSummary = filterInfo.enabled
            ? `${filterInfo.chunks_removed || 0} chunks removed, ${filterInfo.tokens_saved || 0} tokens saved${filterInfo.cost_savings ? `, ‚âà$${filterInfo.cost_savings.toFixed(4)} saved` : ''}`
            : 'Content filtering disabled';
        const entriesHtml = Array.isArray(commandLines) && commandLines.length > 0
            ? commandLines.map((entry, index) => `
                <div class="bg-white border border-gray-200 rounded-lg p-3 space-y-2">
                    <div class="flex items-center justify-between text-xs text-gray-500 uppercase">
                        <span>Command ${index + 1}</span>
                        <span>${((entry?.score || 0) * 100).toFixed(1)}%</span>
                    </div>
                    <pre class="text-sm font-mono text-gray-900 break-words bg-gray-50 px-2 py-1 rounded">${escapeHtml(entry?.text)}</pre>
                    ${entry?.context ? `<div class="text-xs text-gray-600 italic">${escapeHtml(entry.context)}</div>` : ''}
                </div>
            `).join('')
            : '<div class="text-sm text-gray-500 text-center py-8">No command lines detected.</div>';

        const similarityPercent = ((metadata?.similarity_threshold || 0) * 100).toFixed(1);
        const minConfidence = (metadata?.min_confidence ?? 0.7).toFixed(2);

        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-5xl shadow-lg rounded-md bg-white max-h-[90vh] overflow-y-auto">
                <div class="flex items-start justify-between mb-4">
                    <div>
                        <h3 class="text-lg font-medium text-gray-900">üßæ Command Line Extraction</h3>
                        <p class="text-xs text-gray-500 mt-1">
                            Extracted at ${extractedAt}
                            ${metadata?.cached ? '<span class="text-blue-600"> (Cached)</span>' : ''}
                        </p>
                    </div>
                    <button onclick="closeCommandLinesModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-xs text-gray-600 mb-4">
                    <div>
                        <div class="text-[11px] uppercase text-gray-400">Similarity</div>
                        <div class="font-semibold text-gray-900">${similarityPercent}%</div>
                    </div>
                    <div>
                        <div class="text-[11px] uppercase text-gray-400">Filter confidence</div>
                        <div class="font-semibold text-gray-900">${minConfidence}</div>
                    </div>
                    <div>
                        <div class="text-[11px] uppercase text-gray-400">Filtering</div>
                        <div class="font-semibold text-gray-900">${filterInfo.enabled ? 'Enabled' : 'Disabled'}</div>
                    </div>
                </div>

                <div class="space-y-3">
                    ${entriesHtml}
                </div>

                <div class="mt-6 border-t border-gray-200 pt-4 text-xs text-gray-600">
                    ${filterSummary}
                </div>

                <div class="mt-6 flex justify-end gap-3">
                    <button onclick="regenerateCommandLines()" class="px-4 py-2 bg-orange-600 text-white rounded-md hover:bg-orange-700 transition-colors">
                        üîÑ Regenerate
                    </button>
                    <button onclick="closeCommandLinesModal()" class="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;

        document.body.appendChild(modal);
        
        // Ensure modal is visible
        modal.classList.remove('hidden');
        
        // Register and open with ModalManager
        if (window.ModalManager) {
            setTimeout(() => {
                window.ModalManager.register('commandLinesModal', {
                    isDynamic: true,
                    hasInput: false
                });
                window.ModalManager.open('commandLinesModal');
                modal.classList.remove('hidden');
            }, 50);
        }
        
        window.latestCommandLines = { command_lines: commandLines, metadata };
    }

    function closeCommandLinesModal() {
        const modal = document.getElementById('commandLinesModal');
        if (modal) {
            modal.remove();
        }
        if (commandLinesEscHandler) {
            document.removeEventListener('keydown', commandLinesEscHandler);
            commandLinesEscHandler = null;
        }
    }
    
    async function detectOS() {
        closeAIAssistantModal();
        
        const articleId = {{ article.id|default(0)|int }};
        
        // Show optimization dialog first
        const optimizationOptions = await showOptimizationDialog(false);
        if (!optimizationOptions) {
            // User cancelled
            return;
        }
        
        // Fetch workflow config to get actual model names
        let embeddingModel = 'ibm-research/CTI-BERT';
        let fallbackModel = 'mistralai/mistral-7b-instruct-v0.3';
        try {
            const configResponse = await fetch('/api/workflow/config');
            if (configResponse.ok) {
                const config = await configResponse.json();
                if (config.agent_models) {
                    embeddingModel = config.agent_models['OSDetectionAgent_embedding'] || embeddingModel;
                    fallbackModel = config.agent_models['OSDetectionAgent_fallback'] || fallbackModel;
                }
            }
        } catch (e) {
            console.warn('Could not fetch workflow config for model names:', e);
        }
        
        // Format model names for display
        const embeddingModelDisplay = embeddingModel.includes('CTI-BERT') ? 'CTI-BERT' : 
                                     embeddingModel.includes('SEC-BERT') ? 'SEC-BERT' : 
                                     embeddingModel.split('/').pop();
        const fallbackModelDisplay = fallbackModel.split('/').pop() || 'Mistral-7B-Instruct-v0.3';
        
        // Show loading indicator
        const loadingModal = document.createElement('div');
        loadingModal.id = 'osDetectionLoadingModal';
        loadingModal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50 flex items-center justify-center p-4';
        
        // Track if request has started
        let osRequestStarted = false;
        
        // Create AbortController for cancellation
        const osAbortController = new AbortController();
        let osIsCancelled = false;
        
        // Cancel handler function
        const handleOsCancel = function() {
            if (osRequestStarted && !osIsCancelled) {
                osIsCancelled = true;
                osAbortController.abort();
                showNotification('OS detection cancelled', 'info');
            }
            const modal = document.getElementById('osDetectionLoadingModal');
            if (modal && modal.parentNode) {
                modal.remove();
            }
            document.removeEventListener('keydown', handleOsEsc);
        };
        
        // Close modal when clicking outside (dismiss without cancelling)
        loadingModal.addEventListener('click', function(e) {
            if (e.target === loadingModal) {
                const modal = document.getElementById('osDetectionLoadingModal');
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleOsEsc);
            }
        });
        
        // Add ESC key handler to close loading modal (dismiss without cancelling)
        const handleOsEsc = function(e) {
            if (e.key === 'Escape') {
                // ESC just closes the modal, operation continues in background
                const modal = document.getElementById('osDetectionLoadingModal');
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleOsEsc);
            }
        };
        document.addEventListener('keydown', handleOsEsc);
        
        loadingModal.innerHTML = `
            <div class="mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <h3 class="text-lg font-medium text-gray-900 mb-4">üíª Detecting Operating System</h3>
                    <div class="flex justify-center items-center">
                        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-cyan-600"></div>
                        <span class="ml-3 text-gray-600">Analyzing article content...</span>
                    </div>
                    <p class="text-xs text-gray-500 mt-4">Trying keyword matching, then ${embeddingModelDisplay} embeddings + classifier</p>
                    <p class="text-xs text-gray-400 mt-1">Fallback: ${fallbackModelDisplay}</p>
                    <div class="mt-6 flex flex-col items-center space-y-3">
                        <button id="cancelBtnOs" class="px-6 py-2.5 bg-red-600 text-white text-sm font-medium rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 shadow-sm transition-colors">
                            Cancel Operation
                        </button>
                        <div class="flex items-center space-x-2 text-sm text-gray-600">
                            <span>Press</span>
                            <kbd class="px-2 py-1 bg-gray-100 border border-gray-300 rounded text-xs font-semibold text-gray-700 shadow-sm">ESC</kbd>
                            <span>or click outside to dismiss (operation continues)</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(loadingModal);
        
        // Wire up cancel button
        const cancelBtnOs = loadingModal.querySelector('#cancelBtnOs');
        if (cancelBtnOs) {
            cancelBtnOs.addEventListener('click', handleOsCancel);
        }
        
        try {
            osRequestStarted = true;
            const response = await fetch(`/api/articles/${articleId}/detect-os`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    use_classifier: true,
                    use_fallback: true,
                    use_junk_filter: optimizationOptions.useFiltering,
                    junk_filter_threshold: optimizationOptions.minConfidence
                }),
                signal: osAbortController.signal
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.detail || 'OS detection failed');
            }
            
            const result = await response.json();
            
            // Remove loading modal and clean up ESC handler
            if (loadingModal && loadingModal.parentNode) {
                loadingModal.remove();
            }
            document.removeEventListener('keydown', handleOsEsc);
            
            // Show results modal
            const resultModal = document.createElement('div');
            resultModal.id = 'osDetectionResultModal';
            resultModal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50 flex items-center justify-center';
            
            const osLabel = result.operating_system || 'Unknown';
            const method = result.method || 'unknown';
            const confidence = result.confidence || 'unknown';
            const maxSimilarity = result.max_similarity ? (result.max_similarity * 100).toFixed(1) : null;
            const keywordMatches = result.keyword_matches || null;
            
            // Build similarities display
            let similaritiesHtml = '';
            if (result.similarities) {
                const sortedSims = Object.entries(result.similarities)
                    .sort((a, b) => b[1] - a[1])
                    .map(([os, sim]) => `<div class="flex justify-between"><span>${os}:</span><span>${(sim * 100).toFixed(1)}%</span></div>`)
                    .join('');
                similaritiesHtml = `<div class="mt-3 p-2 bg-gray-50 rounded text-xs">${sortedSims}</div>`;
            }
            
            // Build content filtering display
            let filteringHtml = '';
            if (result.content_filtering && result.content_filtering.enabled) {
                const filtering = result.content_filtering;
                filteringHtml = `
                    <div class="mt-3 pt-3 border-t">
                        <div class="text-sm font-medium text-gray-700 mb-2">Content Filtering:</div>
                        <div class="text-xs text-gray-600 space-y-1">
                            <div>Threshold: ${filtering.threshold}</div>
                            <div>Original: ${filtering.original_length?.toLocaleString() || 'N/A'} chars</div>
                            <div>Filtered: ${filtering.filtered_length?.toLocaleString() || 'N/A'} chars</div>
                            ${filtering.reduction_percent ? `<div>Reduction: ${filtering.reduction_percent.toFixed(1)}%</div>` : ''}
                        </div>
                    </div>
                `;
            }
            
            resultModal.innerHTML = `
                <div class="mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-medium text-gray-900">üíª OS Detection Result</h3>
                        <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    
                    <div class="space-y-3">
                        <div>
                            <div class="text-sm font-medium text-gray-700">Operating System:</div>
                            <div class="text-lg font-bold text-cyan-600 mt-1">${osLabel}</div>
                        </div>
                        
                        <div>
                            <div class="text-sm font-medium text-gray-700">Detection Method:</div>
                            <div class="text-sm text-gray-600 mt-1 font-mono">${method}</div>
                        </div>
                        
                        <div>
                            <div class="text-sm font-medium text-gray-700">Models Used:</div>
                            <div class="text-xs text-gray-600 mt-1">
                                ${method === 'keyword_match' ? 
                                    '<div>Method: <span class="font-mono">Keyword Matching</span></div>' :
                                    `<div>Embedding: <span class="font-mono">${embeddingModelDisplay}</span></div>`
                                }
                                ${method.includes('fallback') || method.includes('LLM') ? `<div>LLM Fallback: <span class="font-mono">${fallbackModelDisplay}</span></div>` : ''}
                            </div>
                        </div>
                        
                        <div>
                            <div class="text-sm font-medium text-gray-700">Confidence:</div>
                            <div class="text-sm text-gray-600 mt-1">${confidence}</div>
                        </div>
                        
                        ${keywordMatches !== null ? `
                        <div>
                            <div class="text-sm font-medium text-gray-700">Keyword Matches:</div>
                            <div class="text-sm text-gray-600 mt-1">${keywordMatches} Windows keywords found</div>
                        </div>
                        ` : ''}
                        
                        ${maxSimilarity ? `
                        <div>
                            <div class="text-sm font-medium text-gray-700">Max Similarity:</div>
                            <div class="text-sm text-gray-600 mt-1">${maxSimilarity}%</div>
                        </div>
                        ` : ''}
                        
                        ${similaritiesHtml}
                        
                        ${filteringHtml}
                        
                        <div class="mt-4 pt-4 border-t">
                            <button onclick="this.closest('.fixed').remove()" 
                                    class="w-full inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-[#4b4e77] hover:bg-[#7C3AED] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(resultModal);
            
            // Add click outside to close
            resultModal.addEventListener('click', function(e) {
                if (e.target === resultModal) {
                    resultModal.remove();
                }
            });
            
            // Add ESC key to close
            const handleEsc = function(e) {
                if (e.key === 'Escape') {
                    resultModal.remove();
                    document.removeEventListener('keydown', handleEsc);
                }
            };
            document.addEventListener('keydown', handleEsc);
            
        } catch (error) {
            loadingModal.remove();
            
            // Show error modal
            const errorModal = document.createElement('div');
            errorModal.id = 'osDetectionErrorModal';
            errorModal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50 flex items-center justify-center';
            errorModal.innerHTML = `
                <div class="mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-medium text-red-600">‚ùå OS Detection Error</h3>
                        <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    <p class="text-sm text-gray-700">${error.message}</p>
                    <button onclick="this.closest('.fixed').remove()" 
                            class="mt-4 w-full inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700">
                        Close
                    </button>
                </div>
            `;
            document.body.appendChild(errorModal);
            
            // Add click outside to close
            errorModal.addEventListener('click', function(e) {
                if (e.target === errorModal) {
                    errorModal.remove();
                }
            });
        }
    }
    
    async function extractIOCsCTIBERT() {
        closeAIAssistantModal();
        
        const articleId = {{ article.id|default(0)|int }};
        
        // Show loading modal
        const loadingModal = document.createElement('div');
        loadingModal.id = 'loadingModal';
        loadingModal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50 flex items-center justify-center p-4';
        loadingModal.innerHTML = `
            <div class="mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
                    <h3 class="text-lg font-medium text-gray-900 mb-2">Extracting IOCs with CTI-BERT</h3>
                    <p class="text-sm text-gray-500">Using IBM Research's CTI-BERT model for Named Entity Recognition...</p>
                </div>
            </div>
        `;
        document.body.appendChild(loadingModal);
        
        try {
            const response = await fetch(`/api/articles/${articleId}/extract-iocs-ctibert`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({})
            });
            
            const result = await response.json();
            
            // Remove loading modal
            const loading = document.getElementById('loadingModal');
            if (loading) {
                loading.remove();
            }
            
            if (!response.ok) {
                throw new Error(result.detail || 'Failed to extract IOCs');
            }
            
            if (result.success && result.validated_count > 0) {
                // Show results modal
                showCTIBERTIOCsModal(result.iocs, result);
            } else {
                showNotification('No IOCs found using CTI-BERT extraction.', 'info');
            }
            
        } catch (error) {
            // Remove loading modal
            const loading = document.getElementById('loadingModal');
            if (loading) {
                loading.remove();
            }
            
            console.error('CTI-BERT extraction error:', error);
            showNotification(`Failed to extract IOCs: ${error.message}`, 'error');
        }
    }
    
    async function showCTIBERTIOCsModal(iocsData, resultData) {
        // Remove any existing modal
        closeCTIBERTIOCsModal();
        await cleanupExistingModal('ctibertIOCsModal');
        
        const modal = document.createElement('div');
        modal.id = 'ctibertIOCsModal';
        modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeCTIBERTIOCsModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeCTIBERTIOCsModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        const extractedAt = resultData?.metadata?.extracted_at || new Date().toISOString();
        const extractedAtFormatted = new Date(extractedAt).toLocaleString();
        const confidence = (resultData?.confidence || 0) * 100;
        const processingTime = (resultData?.processing_time || 0).toFixed(2);
        const method = resultData?.method || 'ctibert-ner';
        
        // Calculate totals
        let totalCount = 0;
        const categoryCounts = {};
        for (const [category, items] of Object.entries(iocsData)) {
            const count = Array.isArray(items) ? items.length : 0;
            categoryCounts[category] = count;
            totalCount += count;
        }
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-6xl shadow-lg rounded-md" style="background-color: rgba(134, 153, 177, 1);">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium text-gray-900">ü§ñ CTI-BERT IOC Extraction</h3>
                    <div class="flex items-center space-x-2">
                        <button onclick="showCTIBERTHelp()" class="text-blue-500 hover:text-blue-700 text-sm px-2 py-1 rounded border border-blue-300 hover:bg-blue-50">
                            <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            Help
                        </button>
                        <button onclick="closeCTIBERTIOCsModal()" class="text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="mb-4 grid grid-cols-4 gap-4">
                    <div class="bg-blue-50 p-3 rounded border border-blue-200">
                        <div class="text-sm text-blue-600 font-medium">Total IOCs</div>
                        <div class="text-2xl font-bold text-blue-900">${totalCount}</div>
                    </div>
                    <div class="bg-green-50 p-3 rounded border border-green-200">
                        <div class="text-sm text-emerald-400 font-medium">Confidence</div>
                        <div class="text-2xl font-bold text-green-900">${confidence.toFixed(1)}%</div>
                    </div>
                    <div class="bg-purple-50 p-3 rounded border border-purple-200">
                        <div class="text-sm text-purple-600 font-medium">Processing Time</div>
                        <div class="text-2xl font-bold text-purple-900">${processingTime}s</div>
                    </div>
                    <div class="bg-orange-50 p-3 rounded border border-orange-200">
                        <div class="text-sm text-orange-600 font-medium">Method</div>
                        <div class="text-sm font-bold text-orange-900">${method}</div>
                    </div>
                </div>
                
                <div class="mb-4 text-sm text-gray-600">
                    <span class="font-medium">Extracted at:</span> ${extractedAtFormatted}
                </div>
                
                <div class="bg-gray-50 p-4 rounded-lg max-h-96 overflow-y-auto">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        ${Object.entries(iocsData).filter(([cat, items]) => items && items.length > 0).map(([category, items]) => `
                        <div class="bg-white p-3 rounded border">
                            <h4 class="font-medium text-gray-900 mb-2 capitalize flex items-center justify-between">
                                <span>${category.replace(/_/g, ' ')}</span>
                                <span class="text-xs font-normal text-gray-500 bg-gray-100 px-2 py-1 rounded">${items.length}</span>
                            </h4>
                            <ul class="text-sm text-gray-700 space-y-1 max-h-48 overflow-y-auto">
                                ${items.slice(0, 20).map(item => `<li class="font-mono text-xs bg-gray-50 px-2 py-1 rounded break-all">${item}</li>`).join('')}
                                ${items.length > 20 ? `<li class="text-xs text-gray-500 italic">... and ${items.length - 20} more</li>` : ''}
                            </ul>
                        </div>
                        `).join('')}
                    </div>
                    ${totalCount === 0 ? '<p class="text-gray-500 text-center py-8">No IOCs found</p>' : ''}
                </div>
                
                ${resultData?.metadata ? `
                <div class="mt-4 p-3 bg-gray-50 rounded border">
                    <h4 class="font-medium text-gray-900 mb-2 text-sm">Extraction Details</h4>
                    <div class="text-xs text-gray-600 space-y-1">
                        <div><strong>Model:</strong> ${resultData.metadata.model_name || 'ibm-research/CTI-BERT'}</div>
                        <div><strong>Device:</strong> ${resultData.metadata.device || 'cpu'}</div>
                        ${resultData.metadata.chunks_processed ? `<div><strong>Chunks Processed:</strong> ${resultData.metadata.chunks_processed}</div>` : ''}
                    </div>
                </div>
                ` : ''}
                
                <div class="mt-4 flex justify-end">
                    <button onclick="closeCTIBERTIOCsModal()" class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Ensure modal is visible
        modal.classList.remove('hidden');
        
        // Register and open with ModalManager
        if (window.ModalManager) {
            setTimeout(() => {
                window.ModalManager.register('ctibertIOCsModal', {
                    isDynamic: true,
                    hasInput: false
                });
                window.ModalManager.open('ctibertIOCsModal');
                modal.classList.remove('hidden');
            }, 50);
        }
    }
    
    function closeCTIBERTIOCsModal() {
        const modal = document.getElementById('ctibertIOCsModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function showCTIBERTHelp() {
        alert('CTI-BERT IOC Extraction\n\n' +
              'Uses IBM Research\'s CTI-BERT model (pre-trained on 1.2B cybersecurity tokens) for Named Entity Recognition-based IOC extraction.\n\n' +
              'Features:\n' +
              '‚Ä¢ Domain-specific cybersecurity knowledge\n' +
              '‚Ä¢ Pattern-based extraction with semantic filtering\n' +
              '‚Ä¢ No API keys required (runs locally)\n' +
              '‚Ä¢ Extracts IPs, domains, URLs, hashes, file paths, registry keys, emails, mutexes, and more\n\n' +
              'This method complements the standard IOC extraction by leveraging domain-specific language understanding.');
    }
    
    async function showGPT4oRankingModal(analysis, data) {
        // Remove any existing modal
        closeGPT4oRankingModal();
        await cleanupExistingModal('gpt4oRankingModal');
        
        const modal = document.createElement('div');
        modal.id = 'gpt4oRankingModal';
        modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeGPT4oRankingModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeGPT4oRankingModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        // Format the analysis for display
        const formattedAnalysis = analysis.replace(/\n/g, '<br>');
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-6xl shadow-lg rounded-md" style="background-color: rgba(134, 153, 177, 1);">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium text-gray-900">üìä ${data && (data.ai_model || data.model_name || data.model) ? (() => {
                        const model = data.ai_model || data.model_name || data.model;
                        if (model.includes('claude')) return 'CLAUDE';
                        if (model.includes('gpt')) return 'GPT-4O';
                        return model.toUpperCase();
                    })() : 'LLM'} SIGMA Huntability Analysis</h3>
                    <div class="flex items-center space-x-2">
                        <button onclick="showRankingHelp()" class="text-blue-500 hover:text-blue-700 text-sm px-2 py-1 rounded border border-blue-300 hover:bg-blue-50">
                            <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            Help
                        </button>
                        <button onclick="closeGPT4oRankingModal()" class="text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="mb-4">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <div class="text-sm text-blue-800 whitespace-pre-wrap">${formattedAnalysis}</div>
                    </div>
                </div>
                
                ${data ? `
                <div class="mt-4 text-xs text-gray-500">
                    <div class="flex justify-between">
                        <span>Generated: ${data.analyzed_at ? new Date(data.analyzed_at).toLocaleString() : 'Unknown'}</span>
                        <span>Model: ${data.ai_model || data.model_name || data.model || 'gpt-4o'}</span>
                    </div>
                </div>
                ` : ''}
                
                <div class="mt-6 flex justify-between">
                    <button onclick="regenerateGPT4oRanking()" 
                            class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
                        üîÑ Regenerate Analysis
                    </button>
                    <button onclick="closeGPT4oRankingModal()" 
                            class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Ensure modal is visible
        modal.classList.remove('hidden');
        
        // Register and open with ModalManager
        if (window.ModalManager) {
            setTimeout(() => {
                window.ModalManager.register('gpt4oRankingModal', {
                    isDynamic: true,
                    hasInput: false
                });
                window.ModalManager.open('gpt4oRankingModal');
                modal.classList.remove('hidden');
            }, 50);
        }
    }
    
    function closeGPT4oRankingModal() {
        const modal = document.getElementById('gpt4oRankingModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function regenerateSigmaRules() {
        // Close current modal
        closeSigmaRulesModal();
        
        // Call generateAIAnalysis with force regeneration
        generateAIAnalysis('sigma', true);
    }
    
    async function checkSimilarSigmaRules(force = false) {
        // Get the currently displayed Sigma rules
        const sigmaRulesModal = document.getElementById('sigmaRulesModal');
        
        // Get the generated rules from multiple sources
        let generatedRules = currentGeneratedSigmaRules; // Try global variable first
        
        // Try to get from modal data attribute
        if (generatedRules.length === 0 && sigmaRulesModal) {
            try {
                const modalRules = sigmaRulesModal.dataset.generatedRules;
                if (modalRules) {
                    generatedRules = JSON.parse(modalRules);
                }
            } catch (e) {
                console.warn('Could not parse modal data', e);
            }
        }
        
        // If not found, fetch from article metadata
        if (generatedRules.length === 0) {
            const articleId = {{ article.id|default(0)|int }};
            try {
                const articleResponse = await fetch(`/api/articles/${articleId}`);
                if (articleResponse.ok) {
                    const articleData = await articleResponse.json();
                    if (articleData.article_metadata?.sigma_rules?.rules) {
                        generatedRules = articleData.article_metadata.sigma_rules.rules;
                        currentGeneratedSigmaRules = generatedRules; // Store globally
                    }
                }
            } catch (e) {
                console.warn('Could not fetch article metadata', e);
            }
        }
        
        if (generatedRules.length === 0) {
            showNotification('No generated SIGMA rules found. Please generate rules first.', 'error');
            return;
        }
        
        const articleId = {{ article.id|default(0)|int }};
        
        // Show loading indicator
        showNotification('Searching for similar rules in SigmaHQ repository...', 'info');
        
        let hadSuccess = false;
        try {
            // Fetch similar rules from the API
            // Show loading state
            const checkBtn = document.getElementById('checkSimilarRulesBtn');
            if (checkBtn) {
                checkBtn.disabled = true;
                checkBtn.textContent = '‚è≥ Checking... (this may take 20-30 seconds)';
            }
            
            // Get LLM provider from Settings
            const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
            const llmProvider = settings.aiModel || 'chatgpt';
            
            const response = await fetch(`/api/articles/${articleId}/sigma-matches?llm_provider=${encodeURIComponent(llmProvider)}${force ? '&force=true' : ''}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                },
                signal: AbortSignal.timeout(60000)  // 60 second timeout on client side
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.success) {
                showSimilarRulesModal(data.matches, data.coverage_summary, generatedRules);
                hadSuccess = true;
            } else {
                showNotification('Failed to find similar rules', 'error');
            }
        } catch (error) {
            console.error('Error checking similar rules:', error);
            if (error.name === 'AbortError' || error.name === 'TimeoutError') {
                showNotification('Request timed out - LLM reranking may still be processing. Try refreshing in a moment.', 'warning');
            } else {
                showNotification('Error checking similar rules: ' + error.message, 'error');
            }
        } finally {
            // Re-enable button
            const checkBtn = document.getElementById('checkSimilarRulesBtn');
            const regenBtn = document.getElementById('regenerateSimilarRulesBtn');
            if (checkBtn) {
                checkBtn.disabled = false;
                // After first successful run, convert to Display and reveal Regenerate button
                if (hadSuccess) {
                    checkBtn.textContent = 'üìö Display Similar Rules';
                } else {
                    checkBtn.textContent = 'üîç Similarity Search';
                }
            }
            if (regenBtn) {
                // Show regenerate button only after successful first generation
                if (hadSuccess) {
                    regenBtn.classList.remove('hidden');
                    regenBtn.disabled = false;
                }
            }
        }
    }
    
    async function generateArticleEmbedding() {
        const articleId = {{ article.id|default(0)|int }};
        
        // Disable button during generation
        const embedBtn = document.getElementById('embedArticleBtn');
        if (embedBtn) {
            embedBtn.disabled = true;
            embedBtn.textContent = '‚è≥ Generating...';
        }
        
        showNotification('Generating article embedding...', 'info');
        
        try {
            const response = await fetch(`/api/articles/${articleId}/embed`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.status === 'task_submitted' || data.status === 'already_embedded') {
                showNotification('‚úì Article embedding generated successfully!', 'success');
                
                // Re-enable Similarity Search button
                const checkBtn = document.getElementById('checkSimilarRulesBtn');
                if (checkBtn) {
                    checkBtn.disabled = false;
                }
                
                // Keep embed button disabled (already embedded)
                if (embedBtn) {
                    embedBtn.disabled = true;
                    embedBtn.textContent = '‚úì Embedded';
                }
            } else {
                throw new Error(data.error || data.message || 'Failed to generate embedding');
            }
        } catch (error) {
            console.error('Error generating embedding:', error);
            showNotification('Error: ' + error.message, 'error');
            
            if (embedBtn) {
                embedBtn.disabled = false;
                embedBtn.textContent = 'üß¨ Embed Article';
            }
        }
    }
    
    async function sendRuleToQueue() {
        const queueBtn = document.getElementById('sendToQueueBtn');
        const articleId = {{ article.id|default(0)|int }};
        
        // Get the generated rules
        let generatedRules = currentGeneratedSigmaRules;
        
        // Try to get from modal data attribute if not available
        if (generatedRules.length === 0) {
            const sigmaRulesModal = document.getElementById('sigmaRulesModal');
            if (sigmaRulesModal) {
                try {
                    const modalRules = sigmaRulesModal.dataset.generatedRules;
                    if (modalRules) {
                        generatedRules = JSON.parse(modalRules);
                    }
                } catch (e) {
                    console.warn('Could not parse modal data', e);
                }
            }
        }
        
        // If not found, fetch from article metadata
        if (generatedRules.length === 0) {
            try {
                const articleResponse = await fetch(`/api/articles/${articleId}`);
                if (articleResponse.ok) {
                    const articleData = await articleResponse.json();
                    if (articleData.article_metadata?.sigma_rules?.rules) {
                        generatedRules = articleData.article_metadata.sigma_rules.rules;
                        currentGeneratedSigmaRules = generatedRules;
                    }
                }
            } catch (e) {
                console.warn('Could not fetch article metadata', e);
            }
        }
        
        if (generatedRules.length === 0) {
            showNotification('No generated SIGMA rules found. Please generate rules first.', 'error');
            return;
        }
        
        // Get the first rule (or handle multiple rules)
        const rule = generatedRules[0];
        
        // Extract rule data - handle different formats
        let ruleYaml = null;
        let ruleJson = null;
        let ruleMetadata = null;
        
        if (typeof rule === 'string') {
            // Rule is already YAML string
            ruleYaml = rule;
        } else if (rule.content) {
            // Rule has a content field with YAML
            ruleYaml = rule.content;
            ruleMetadata = {
                title: rule.title,
                description: rule.description,
                tags: rule.tags || [],
                level: rule.level,
                status: rule.status || 'experimental'
            };
        } else if (typeof rule === 'object') {
            // Rule is an object - send as JSON, backend will convert to YAML
            ruleJson = rule;
            ruleMetadata = {
                title: rule.title,
                description: rule.description,
                tags: rule.tags || [],
                level: rule.level,
                status: rule.status || 'experimental'
            };
        } else {
            showNotification('Invalid rule format. Cannot send to queue.', 'error');
            return;
        }
        
        // Show loading state
        if (queueBtn) {
            queueBtn.disabled = true;
            queueBtn.textContent = '‚è≥ Sending...';
        }
        
        try {
            const requestBody = {
                article_id: articleId,
                rule_metadata: ruleMetadata
            };
            
            if (ruleYaml) {
                requestBody.rule_yaml = ruleYaml;
            } else if (ruleJson) {
                requestBody.rule_json = ruleJson;
            }
            
            const response = await fetch('/api/sigma-queue/add', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody)
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
                throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.success) {
                showNotification(`‚úì Rule added to SIGMA Queue (ID: ${data.queue_id})`, 'success');
                if (queueBtn) {
                    queueBtn.textContent = '‚úì Queued';
                    queueBtn.disabled = true;
                }
                
                // Redirect to the queue page with previewId parameter to auto-open preview modal
                // Query parameters must come before the hash in URLs
                window.location.href = `/workflow?previewId=${data.queue_id}#queue`;
            } else {
                throw new Error(data.message || 'Failed to add rule to queue');
            }
        } catch (error) {
            console.error('Error sending rule to queue:', error);
            showNotification('Error: ' + error.message, 'error');
            
            if (queueBtn) {
                queueBtn.disabled = false;
                queueBtn.textContent = 'üìã Send to Queue';
            }
        }
    }
    
    async function showSimilarRulesModal(matches, coverageSummary, generatedRules = []) {
        // Remove any existing modal
        closeSimilarRulesModal();
        await cleanupExistingModal('similarRulesModal');
        
        const modal = document.createElement('div');
        modal.id = 'similarRulesModal';
        modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeSimilarRulesModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeSimilarRulesModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        
        // Build matches HTML
        let matchesHtml = '';
        if (!matches || matches.length === 0) {
            matchesHtml = `
                <div class="text-center py-8">
                    <div class="w-16 h-16 mx-auto mb-4 text-green-500 flex items-center justify-center">
                        <svg class="w-full h-full" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
                        </svg>
                    </div>
                    <p class="text-lg font-semibold text-gray-900 mb-2">‚ú® Novel Detection Pattern</p>
                    <p class="text-gray-600 mb-1">No similar rules found in SigmaHQ repository</p>
                    <p class="text-sm text-gray-500 mt-2">This rule represents a unique detection pattern that is not currently covered by existing SigmaHQ rules.</p>
                </div>
            `;
        } else {
            // Get parsed data from first generated rule
            let newRuleLogsource = null;
            let newRuleDetection = null;
            if (generatedRules.length > 0) {
                const firstRule = generatedRules[0];
                
                // Check if already parsed (should have direct logsource/detection fields)
                if (firstRule.logsource || firstRule.detection) {
                    newRuleLogsource = firstRule.logsource;
                    newRuleDetection = firstRule.detection;
                } else if (firstRule.content) {
                    // Parse YAML content using regex (simple parser for logsource and detection blocks)
                    try {
                        const content = firstRule.content;
                        
                        // Backend should provide parsed fields, but if not available, log warning
                        console.warn('Generated rule missing parsed logsource/detection fields. Backend should provide these.', firstRule);
                        // Set to null - will show N/A in UI
                        newRuleLogsource = null;
                        newRuleDetection = null;
                    } catch (e) {
                        console.warn('Could not parse generated rule YAML:', e);
                    }
                }
            }
            
            matchesHtml = matches.map((match, index) => {
                const similarityPercent = (match.similarity_score * 100).toFixed(1);
                const coverageStatus = match.coverage_status || 'unknown';
                const statusColor = coverageStatus === 'covered' ? 'green' : 
                                   coverageStatus === 'extend' ? 'yellow' : 'purple';
                const statusIcon = coverageStatus === 'covered' ? '‚úì' : 
                                  coverageStatus === 'extend' ? '‚ö°' : '‚ú®';
                // Escape rule_id for JavaScript
                const escapedRuleId = match.rule_id ? match.rule_id.replace(/'/g, "\\'") : '';
                // Escape logsource and detection for safe JSON display (escape HTML entities, keep JSON quotes)
                const logsourceJson = match.logsource ? JSON.stringify(match.logsource, null, 2).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : 'N/A';
                const detectionJson = match.detection ? JSON.stringify(match.detection, null, 2).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : 'N/A';
                // Escape new rule logsource and detection
                const newRuleLogsourceJson = newRuleLogsource ? JSON.stringify(newRuleLogsource, null, 2).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : 'N/A';
                const newRuleDetectionJson = newRuleDetection ? JSON.stringify(newRuleDetection, null, 2).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : 'N/A';
                
                return `
                    <div class="border border-gray-200 rounded-lg p-4 hover:bg-gray-50 transition-colors cursor-pointer" 
                         onclick="showFullSigmaRule('${escapedRuleId}')"
                         title="Click to view full rule details">
                        <div class="flex items-start justify-between">
                            <div class="flex-1">
                                <h5 class="font-medium text-gray-900">${match.title || 'Untitled Rule'}</h5>
                                <p class="text-sm text-gray-600 mt-1">${match.description || 'No description'}</p>
                            </div>
                            <div class="ml-4 flex flex-col items-end">
                                <div class="text-2xl font-bold text-${statusColor}-600">${similarityPercent}%</div>
                                <div class="text-xs text-${statusColor}-600 bg-${statusColor}-100 px-2 py-1 rounded mt-1">
                                    ${statusIcon} ${coverageStatus.toUpperCase()}
                                </div>
                            </div>
                        </div>
                        
                        ${match.llm_explanation ? `
                            <div class="mt-3 p-2 bg-green-50 border border-green-200 rounded">
                                <div class="text-xs font-bold text-green-900 mb-1">ü§ñ LLM Explanation:</div>
                                <div class="text-xs text-green-800 italic">${match.llm_explanation}</div>
                            </div>
                        ` : ''}
                        
                        ${match.similarity_breakdown || match.atom_jaccard !== undefined ? renderSimilarityDisplay(match, { 
                            mode: 'compact', 
                            includeExplainability: true,
                            ruleALabel: 'Current Rule',
                            ruleBLabel: 'Similar Rule'
                        }) : ''}
                        
                        <div class="mt-3 grid grid-cols-2 gap-2 text-xs">
                            <div><span class="font-medium">Rule ID:</span> <code class="text-xs bg-gray-100 px-1 rounded">${match.rule_id || 'N/A'}</code></div>
                            <div><span class="font-medium">Status:</span> ${match.status || 'N/A'}</div>
                        </div>
                        
                        ${match.tags && match.tags.length > 0 ? `
                            <div class="mt-2">
                                <div class="text-xs font-medium text-gray-700">Tags:</div>
                                <div class="flex flex-wrap gap-1 mt-1">
                                    ${match.tags.slice(0, 5).map(tag => 
                                        `<span class="text-xs px-2 py-0.5 bg-indigo-100 text-indigo-700 rounded">${tag}</span>`
                                    ).join('')}
                                    ${match.tags.length > 5 ? `<span class="text-xs text-gray-500">+${match.tags.length - 5} more</span>` : ''}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${match.matched_discriminators && match.matched_discriminators.length > 0 ? `
                            <div class="mt-2">
                                <div class="text-xs font-medium text-gray-700">Matched Behaviors:</div>
                                <div class="flex flex-wrap gap-1 mt-1">
                                    ${match.matched_discriminators.slice(0, 5).map(d => 
                                        `<span class="text-xs px-2 py-1 bg-blue-100 text-blue-700 rounded">${d}</span>`
                                    ).join('')}
                                    ${match.matched_discriminators.length > 5 ? `<span class="text-xs text-gray-500">+${match.matched_discriminators.length - 5} more</span>` : ''}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${(match.logsource || match.detection || (generatedRules.length > 0 && (generatedRules[0].logsource || generatedRules[0].detection))) ? `
                            <div class="mt-3 border-t border-gray-200 pt-3">
                                <button onclick="event.stopPropagation(); toggleRuleDetails('rule-details-${index}', 'toggle-icon-${index}')" 
                                        class="text-xs text-blue-600 hover:text-blue-800 font-medium flex items-center">
                                    <svg id="toggle-icon-${index}" class="w-4 h-4 mr-1 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                    </svg>
                                    <span>Show Logsource & Detection Comparison</span>
                                </button>
                                <div id="rule-details-${index}" class="hidden mt-2">
                                    ${generatedRules.length > 0 ? `
                                        <div class="mb-4 p-2 bg-yellow-50 border border-yellow-200 rounded">
                                            <h6 class="text-xs font-bold text-yellow-900 mb-1">üìù New Rule: ${generatedRules[0].title || 'Untitled'}</h6>
                                        </div>
                                    ` : ''}
                                    <div class="space-y-4">
                                        <!-- Logsource Comparison -->
                                        <div>
                                            <h6 class="text-xs font-bold text-gray-700 mb-2">üìã Logsource Comparison</h6>
                                            <div class="grid grid-cols-2 gap-4">
                                                <div class="border border-gray-200 rounded p-2 bg-yellow-50">
                                                    <h6 class="text-xs font-bold text-yellow-900 mb-2">New Rule</h6>
                                                    <pre class="text-xs bg-white p-2 rounded border border-gray-200 overflow-x-auto whitespace-pre-wrap font-mono max-h-48">${newRuleLogsourceJson}</pre>
                                                </div>
                                                <div class="border border-gray-200 rounded p-2 bg-blue-50">
                                                    <h6 class="text-xs font-bold text-blue-900 mb-2">Similar Rule</h6>
                                                    <pre class="text-xs bg-white p-2 rounded border border-gray-200 overflow-x-auto whitespace-pre-wrap font-mono max-h-48">${logsourceJson}</pre>
                                                </div>
                                            </div>
                                        </div>
                                        <!-- Detection Comparison -->
                                        <div>
                                            <h6 class="text-xs font-bold text-gray-700 mb-2">üîç Detection Comparison</h6>
                                            <div class="grid grid-cols-2 gap-4">
                                                <div class="border border-gray-200 rounded p-2 bg-yellow-50">
                                                    <h6 class="text-xs font-bold text-yellow-900 mb-2">New Rule</h6>
                                                    <pre class="text-xs bg-white p-2 rounded border border-gray-200 overflow-x-auto whitespace-pre-wrap font-mono max-h-64">${newRuleDetectionJson}</pre>
                                                </div>
                                                <div class="border border-gray-200 rounded p-2 bg-green-50">
                                                    <h6 class="text-xs font-bold text-green-900 mb-2">Similar Rule</h6>
                                                    <pre class="text-xs bg-white p-2 rounded border border-gray-200 overflow-x-auto whitespace-pre-wrap font-mono max-h-64">${detectionJson}</pre>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ` : ''}
                        
                        <div class="mt-2 text-xs text-gray-500">
                            üìÅ ${match.file_path || 'N/A'} | <span class="text-blue-600 font-medium">üîç View full rule ‚Üí</span>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-6xl shadow-lg rounded-md" style="background-color: rgba(134, 153, 177, 1);">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium text-gray-900">üîç Similar Rules in SigmaHQ Repository</h3>
                    <button onclick="closeSimilarRulesModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-4 text-sm text-gray-600">
                    Found ${matches ? matches.length : 0} most similar rules${matches && matches.length > 0 && matches[0].similarity_method === 'llm_reranked' ? ' (LLM-reranked)' : matches && matches.length > 0 && matches[0].similarity_method === 'novelty_assessment' ? ' (behavioral novelty assessment)' : ' (behavioral novelty assessment)'} (sorted by similarity)
                    ${matches && matches[0] && matches[0].similarity_method === 'llm_reranked' ? `
                        <div class="mt-1 text-xs text-gray-500">
                            Analysis by: ${matches[0].llm_provider || 'unknown'}${matches[0].llm_model ? ' ‚Äî ' + matches[0].llm_model : ''}
                        </div>
                    ` : ''}
                </div>
                
                <div class="space-y-3 max-h-96 overflow-y-auto">
                    ${matchesHtml}
                </div>
                
                <div class="mt-6 flex justify-end">
                    <button onclick="closeSimilarRulesModal()" 
                            class="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Ensure modal is visible
        modal.classList.remove('hidden');
        
        // Register and open with ModalManager
        if (window.ModalManager) {
            setTimeout(() => {
                window.ModalManager.register('similarRulesModal', {
                    isDynamic: true,
                    hasInput: false
                });
                window.ModalManager.open('similarRulesModal');
                modal.classList.remove('hidden');
            }, 50);
        }
    }
    
    function closeSimilarRulesModal() {
        const modal = document.getElementById('similarRulesModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function toggleRuleDetails(detailsId, iconId) {
        const detailsDiv = document.getElementById(detailsId);
        const iconSvg = document.getElementById(iconId);
        const button = iconSvg ? iconSvg.closest('button') : null;
        
        if (!detailsDiv || !iconSvg) {
            return;
        }
        
        const isHidden = detailsDiv.classList.contains('hidden');
        
        if (isHidden) {
            detailsDiv.classList.remove('hidden');
            iconSvg.style.transform = 'rotate(180deg)';
            if (button) {
                const span = button.querySelector('span');
                if (span) span.textContent = 'Hide Logsource & Detection Comparison';
            }
        } else {
            detailsDiv.classList.add('hidden');
            iconSvg.style.transform = 'rotate(0deg)';
            if (button) {
                const span = button.querySelector('span');
                if (span) span.textContent = 'Show Logsource & Detection Comparison';
            }
        }
    }
    
    async function showFullSigmaRule(ruleId) {
        // Show loading indicator
        showNotification('Loading rule details...', 'info');
        
        try {
            // Fetch the full rule details
            const response = await fetch(`/api/articles/sigma-rules/${ruleId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.success && data.rule) {
                displaySigmaRuleDetails(data.rule);
            } else {
                showNotification('Failed to load rule details', 'error');
            }
        } catch (error) {
            console.error('Error fetching sigma rule:', error);
            showNotification('Error loading rule details: ' + error.message, 'error');
        }
    }
    
    function displaySigmaRuleDetails(rule) {
        // Remove any existing modal
        closeSigmaRuleDetailsModal();
        
        const modal = document.createElement('div');
        modal.id = 'sigmaRuleDetailsModal';
        modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeSigmaRuleDetailsModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeSigmaRuleDetailsModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        // Format detection logic
        const detectionHtml = rule.detection ? `
            <div class="mb-4">
                <h4 class="text-sm font-medium text-gray-900 mb-2">Detection Logic:</h4>
                <pre class="bg-gray-50 p-3 rounded text-xs overflow-x-auto border border-gray-200">
${JSON.stringify(rule.detection, null, 2)}
                </pre>
            </div>
        ` : '';
        
        // Format logsource
        const logsourceHtml = rule.logsource ? `
            <div class="mb-4">
                <h4 class="text-sm font-medium text-gray-900 mb-2">Log Source:</h4>
                <pre class="bg-gray-50 p-3 rounded text-xs overflow-x-auto border border-gray-200">
${JSON.stringify(rule.logsource, null, 2)}
                </pre>
            </div>
        ` : '';
        
        // Format tags
        const tagsHtml = rule.tags && rule.tags.length > 0 ? `
            <div class="mb-4">
                <h4 class="text-sm font-medium text-gray-900 mb-2">Tags:</h4>
                <div class="flex flex-wrap gap-2">
                    ${rule.tags.map(tag => 
                        `<span class="px-3 py-1 bg-indigo-100 text-indigo-700 rounded text-sm">${tag}</span>`
                    ).join('')}
                </div>
            </div>
        ` : '';
        
        // Format false positives
        const falsePositivesHtml = rule.false_positives && rule.false_positives.length > 0 ? `
            <div class="mb-4">
                <h4 class="text-sm font-medium text-gray-900 mb-2">False Positives:</h4>
                <ul class="list-disc list-inside text-sm text-gray-700">
                    ${rule.false_positives.map(fp => `<li>${fp}</li>`).join('')}
                </ul>
            </div>
        ` : '';
        
        // Format references
        const referencesHtml = rule.rule_references && rule.rule_references.length > 0 ? `
            <div class="mb-4">
                <h4 class="text-sm font-medium text-gray-900 mb-2">References:</h4>
                <ul class="list-disc list-inside text-sm text-gray-700">
                    ${rule.rule_references.map(ref => `<li>${ref}</li>`).join('')}
                </ul>
            </div>
        ` : '';
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-6xl shadow-lg rounded-md max-h-[90vh] overflow-y-auto" style="background-color: rgba(134, 153, 177, 1);">
                <div class="flex justify-between items-center mb-4 sticky top-0 bg-white border-b pb-4">
                    <div>
                        <h3 class="text-lg font-medium text-gray-900">üîç Sigma Rule Details</h3>
                        <p class="text-sm text-gray-600 mt-1">${rule.rule_id}</p>
                    </div>
                    <button onclick="closeSigmaRuleDetailsModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="space-y-4">
                    <!-- Title and Description -->
                    <div>
                        <h4 class="text-xl font-bold text-gray-900 mb-2">${rule.title || 'Untitled Rule'}</h4>
                        <p class="text-sm text-gray-700">${rule.description || 'No description available'}</p>
                    </div>
                    
                    <!-- Metadata Grid -->
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                        ${rule.level ? `
                            <div>
                                <div class="text-xs text-gray-500 uppercase">Level</div>
                                <div class="text-sm font-medium">${rule.level}</div>
                            </div>
                        ` : ''}
                        
                        ${rule.status ? `
                            <div>
                                <div class="text-xs text-gray-500 uppercase">Status</div>
                                <div class="text-sm font-medium">${rule.status}</div>
                            </div>
                        ` : ''}
                        
                        ${rule.author ? `
                            <div>
                                <div class="text-xs text-gray-500 uppercase">Author</div>
                                <div class="text-sm font-medium">${rule.author}</div>
                            </div>
                        ` : ''}
                        
                        ${rule.date ? `
                            <div>
                                <div class="text-xs text-gray-500 uppercase">Date</div>
                                <div class="text-sm font-medium">${new Date(rule.date).toLocaleDateString()}</div>
                            </div>
                        ` : ''}
                    </div>
                    
                    ${logsourceHtml}
                    ${detectionHtml}
                    ${tagsHtml}
                    ${falsePositivesHtml}
                    ${referencesHtml}
                    
                    <!-- File Path -->
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <div class="text-xs text-gray-500">
                            <strong>File Path:</strong> ${rule.file_path || 'N/A'}
                        </div>
                        ${rule.repo_commit_sha ? `
                            <div class="text-xs text-gray-500 mt-1">
                                <strong>Commit:</strong> <code class="bg-gray-100 px-1 rounded">${rule.repo_commit_sha}</code>
                            </div>
                        ` : ''}
                    </div>
                </div>
                
                <div class="mt-6 flex justify-end space-x-3">
                    <button onclick="openSimilarityTest('${rule.rule_id}')" 
                            class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors">
                        üîç Test Similarity
                    </button>
                    <button onclick="closeSigmaRuleDetailsModal()" 
                            class="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Ensure modal is visible
        modal.classList.remove('hidden');
        
        // Register and open with ModalManager
        if (window.ModalManager) {
            setTimeout(() => {
                window.ModalManager.register('sigmaRuleDetailsModal', {
                    isDynamic: true,
                    hasInput: false
                });
                window.ModalManager.open('sigmaRuleDetailsModal');
                modal.classList.remove('hidden');
            }, 50);
        }
    }
    
    function closeSigmaRuleDetailsModal() {
        const modal = document.getElementById('sigmaRuleDetailsModal');
        if (modal) {
            modal.remove();
        }
    }
    
    async function openSimilarityTest(ruleId) {
        try {
            // Fetch YAML from API
            const response = await fetch(`/api/sigma-rules-yaml/${encodeURIComponent(ruleId)}`);
            if (!response.ok) {
                throw new Error(`Failed to fetch rule YAML: ${response.statusText}`);
            }
            
            const data = await response.json();
            const ruleYaml = data.yaml_content || data.yaml || data;
            
            if (!ruleYaml) {
                throw new Error('YAML content not found in API response');
            }
            
            // Store YAML in localStorage (similarity test page reads from this key)
            localStorage.setItem('sigma_similarity_test_rule', ruleYaml);
            
            // Open similarity test page in new tab
            window.open('/sigma-similarity-test', '_blank');
        } catch (error) {
            console.error('Error opening similarity test:', error);
            showNotification('Failed to load rule YAML: ' + error.message, 'error');
        }
    }
    
    function regenerateIOCs() {
        // Get LLM validation setting from checkbox
        const llmValidationToggle = document.getElementById('llmValidationToggle');
        const useLLMValidation = llmValidationToggle ? llmValidationToggle.checked : false;
        
        // Close current modal
        closeIOCsModal();
        
        // Call generateAIAnalysis with force regeneration and LLM validation setting
        generateAIAnalysis('iocs', true, useLLMValidation);
    }

    function regenerateCommandLines() {
        closeCommandLinesModal();
        generateAIAnalysis('cmdlines', true);
    }
    
    function regenerateGPT4oRanking() {
        // Close current modal
        closeGPT4oRankingModal();
        
        // Call generateAIAnalysis with force regeneration
        generateAIAnalysis('ranking', true);
    }
    
    // Text annotation system now handled by LayeredTextManager
    
    // Delete article function
    function deleteArticle(articleId) {
        if (confirm('Are you sure you want to delete this article? This action cannot be undone and will also delete all annotations for this article.')) {
            fetch(`/api/articles/${articleId}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Article deleted successfully!');
                    // Redirect to articles page
                    window.location.href = '/articles';
                } else {
                    alert('Failed to delete article: ' + (data.message || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Failed to delete article: ' + error.message);
            });
        }
    }
    
    // Explicitly attach to window for inline onclick handlers
    window.deleteArticle = deleteArticle;
    
    // Check for pending completion notifications from other pages
    function checkPendingCompletions() {
        const pendingCompletions = JSON.parse(localStorage.getItem('pendingCompletions') || '[]');
        
        pendingCompletions.forEach(completion => {
            // Show completion banner
            showCompletionBanner(completion.type, completion.typeText, completion.typeIcon, completion.articleId, completion.articleTitle);
        });
        
        // Clear pending completions after showing them
        localStorage.removeItem('pendingCompletions');
    }
    // Handle URL fragments to auto-open results
    console.log('Setting up URL fragment handler...');
    
    function processUrlHash() {
        console.log('Processing URL hash...');
        
        const hash = window.location.hash.substring(1); // Remove the #
        console.log('URL hash:', hash);
        
        if (hash === 'sigma') {
            console.log('Processing sigma hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id|default(0)|int }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasSigmaRules = {{ 'true' if article.article_metadata and article.article_metadata.get('sigma_rules') else 'false' }};
                console.log('Has sigma rules (template):', hasSigmaRules);
                
                if (hasSigmaRules) {
                    const sigmaData = {{ article.article_metadata.get('sigma_rules') | tojson if article.article_metadata and article.article_metadata.get('sigma_rules') else 'null' }};
                    console.log('Sigma data (template):', sigmaData);
                    
                    // Parse conversation log if it's a string
                    if (sigmaData && sigmaData.metadata && sigmaData.metadata.conversation && typeof sigmaData.metadata.conversation === 'string') {
                        try {
                            sigmaData.metadata.conversation = JSON.parse(sigmaData.metadata.conversation);
                        } catch (e) {
                            console.error('Failed to parse conversation log:', e);
                            sigmaData.metadata.conversation = [];
                        }
                    }
                    
                    if (sigmaData) {
                        console.log('Auto-opening SIGMA modal from URL fragment (template)');
                        setTimeout(() => showSigmaRulesModal(sigmaData.rules, sigmaData), 500);
                    }
                } else {
                    console.log('No SIGMA rules found in template data');
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching SIGMA data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for SIGMA:', data);
                        if (data.article_metadata && data.article_metadata.sigma_rules) {
                            // Parse conversation log if it's a string
                            if (data.article_metadata.sigma_rules.metadata && data.article_metadata.sigma_rules.metadata.conversation && typeof data.article_metadata.sigma_rules.metadata.conversation === 'string') {
                                try {
                                    data.article_metadata.sigma_rules.metadata.conversation = JSON.parse(data.article_metadata.sigma_rules.metadata.conversation);
                                } catch (e) {
                                    console.error('Failed to parse conversation log:', e);
                                    data.article_metadata.sigma_rules.metadata.conversation = [];
                                }
                            }
                            console.log('Auto-opening SIGMA modal from URL fragment (API)');
                            setTimeout(() => showSigmaRulesModal(data.article_metadata.sigma_rules.rules, data.article_metadata.sigma_rules), 500);
                        } else {
                            console.log('No SIGMA rules found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for sigma:', error);
                    });
            }
        } else if (hash === 'iocs') {
            console.log('Processing iocs hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id|default(0)|int }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasIOCs = {{ 'true' if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'false' }};
                console.log('Has iocs (template):', hasIOCs);
                
                if (hasIOCs) {
                    const iocData = {{ article.article_metadata.get('extracted_iocs') | tojson if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'null' }};
                    console.log('IOCs data (template):', iocData);
                    
                    if (iocData) {
                        console.log('Auto-opening IOCs modal from URL fragment (template)');
                        setTimeout(() => showIOCsModal(JSON.stringify(iocData.iocs, null, 2), iocData), 500);
                    }
                } else {
                    console.log('No IOCs found in template data');
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching IOCs data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for IOCs:', data);
                        if (data.article_metadata && data.article_metadata.extracted_iocs) {
                            console.log('Auto-opening IOCs modal from URL fragment (API)');
                            setTimeout(() => showIOCsModal(JSON.stringify(data.article_metadata.extracted_iocs.iocs, null, 2), data.article_metadata.extracted_iocs), 500);
                        } else {
                            console.log('No IOCs found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for IOCs:', error);
                    });
            }
        } else if (hash === 'cmdlines') {
            console.log('Processing cmdlines hash...');

            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id|default(0)|int }};

            if (currentArticleId == templateArticleId) {
                const hasCmdlines = {{ 'true' if article.article_metadata and article.article_metadata.get('extracted_command_lines') else 'false' }};
                console.log('Has cmdlines (template):', hasCmdlines);

                if (hasCmdlines) {
                    const cmdlineData = {{ article.article_metadata.get('extracted_command_lines') | tojson if article.article_metadata and article.article_metadata.get('extracted_command_lines') else 'null' }};
                    console.log('Command lines data (template):', cmdlineData);

                    if (cmdlineData) {
                        console.log('Auto-opening Command Lines modal from URL fragment (template)');
                        setTimeout(() => showCommandLinesModal(cmdlineData.command_lines, cmdlineData), 500);
                    }
                } else {
                    console.log('No command lines found in template data');
                }
            } else {
                console.log('Different article, fetching command line data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for command lines:', data);
                        if (data.article_metadata && data.article_metadata.extracted_command_lines) {
                            console.log('Auto-opening Command Lines modal from URL fragment (API)');
                            setTimeout(() => showCommandLinesModal(data.article_metadata.extracted_command_lines.command_lines, data.article_metadata.extracted_command_lines), 500);
                        } else {
                            console.log('No command lines found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for command lines:', error);
                    });
            }
        } else if (hash === 'cmdlines') {
            console.log('Processing cmdlines hash...');

            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id|default(0)|int }};

            if (currentArticleId == templateArticleId) {
                const hasCmdlines = {{ 'true' if article.article_metadata and article.article_metadata.get('extracted_command_lines') else 'false' }};
                console.log('Has cmdlines (template):', hasCmdlines);

                if (hasCmdlines) {
                    const cmdlineData = {{ article.article_metadata.get('extracted_command_lines') | tojson if article.article_metadata and article.article_metadata.get('extracted_command_lines') else 'null' }};
                    console.log('Command lines data (template):', cmdlineData);

                    if (cmdlineData) {
                        console.log('Auto-opening Command Lines modal from URL fragment (template)');
                        setTimeout(() => showCommandLinesModal(cmdlineData.command_lines, cmdlineData), 500);
                    }
                } else {
                    console.log('No command lines found in template data');
                }
            } else {
                console.log('Different article, fetching command line data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for command lines:', data);
                        if (data.article_metadata && data.article_metadata.extracted_command_lines) {
                            console.log('Auto-opening Command Lines modal from URL fragment (API)');
                            setTimeout(() => showCommandLinesModal(data.article_metadata.extracted_command_lines.command_lines, data.article_metadata.extracted_command_lines), 500);
                        } else {
                            console.log('No command lines found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for command lines:', error);
                    });
            }
        } else if (hash === 'ranking') {
            console.log('Processing ranking hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id|default(0)|int }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasRanking = {{ 'true' if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'false' }};
                console.log('Has ranking (template):', hasRanking);
                
                if (hasRanking) {
                    const rankingData = {{ article.article_metadata.get('gpt4o_ranking') | tojson if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'null' }};
                    console.log('Ranking data (template):', rankingData);
                    
                    if (rankingData && rankingData.analysis) {
                        console.log('Auto-opening GPT4o ranking from URL fragment (template)');
                        setTimeout(() => {
                            showGPT4oRankingModal(rankingData.analysis, rankingData);
                        }, 500);
                    }
                } else {
                    console.log('No ranking found in template data');
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching ranking data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for ranking:', data);
                        if (data.article_metadata && data.article_metadata.gpt4o_ranking && data.article_metadata.gpt4o_ranking.analysis) {
                            console.log('Auto-opening GPT4o ranking from URL fragment (API)');
                            setTimeout(() => {
                                showGPT4oRankingModal(data.article_metadata.gpt4o_ranking.analysis, data.article_metadata.gpt4o_ranking);
                            }, 500);
                        } else {
                            console.log('No ranking found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for ranking:', error);
                    });
            }
        }
        
        // Clear the hash from URL after handling (with delay to allow modal to open)
        if (hash) {
            console.log('Clearing URL hash:', hash);
            setTimeout(() => {
                window.history.replaceState(null, null, window.location.pathname);
            }, 1000);
        }
    }
    
    // Set up event listeners for URL hash changes
    window.addEventListener('load', function() {
        console.log('Page loaded, checking URL fragments...');
        checkPendingCompletions();
        processUrlHash();
    });
    
    window.addEventListener('hashchange', function() {
        console.log('URL hash changed');
        processUrlHash();
    });

    // Handle URL fragments to auto-open results
    console.log('Setting up URL fragment handler...');
    window.addEventListener('load', function() {
        console.log('Page loaded, checking URL fragments...');
        
        // Check for pending completions first
        checkPendingCompletions();
        
        const hash = window.location.hash.substring(1); // Remove the #
        console.log('URL hash:', hash);
        
        if (hash === 'sigma') {
            console.log('Processing sigma hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id|default(0)|int }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasSigma = {{ 'true' if article.article_metadata and article.article_metadata.get('sigma_rules') else 'false' }};
                console.log('Has sigma (template):', hasSigma);
                
                if (hasSigma) {
                    const sigmaData = {{ article.article_metadata.get('sigma_rules') | tojson if article.article_metadata and article.article_metadata.get('sigma_rules') else 'null' }};
                    console.log('Sigma data (template):', sigmaData);
                    
                    // Parse conversation log if it's a string
                    if (sigmaData && sigmaData.metadata && sigmaData.metadata.conversation && typeof sigmaData.metadata.conversation === 'string') {
                        try {
                            sigmaData.metadata.conversation = JSON.parse(sigmaData.metadata.conversation);
                        } catch (e) {
                            console.error('Failed to parse conversation log:', e);
                            sigmaData.metadata.conversation = [];
                        }
                    }
                    
                    if (sigmaData) {
                        console.log('Auto-opening sigma modal from URL fragment (template)');
                        setTimeout(() => showSigmaRulesModal(sigmaData.rules, sigmaData), 500);
                    }
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching sigma data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for sigma:', data);
                        if (data.metadata && data.metadata.sigma_rules) {
                            // Parse conversation log if it's a string
                            if (data.metadata.sigma_rules.metadata && data.metadata.sigma_rules.metadata.conversation && typeof data.metadata.sigma_rules.metadata.conversation === 'string') {
                                try {
                                    data.metadata.sigma_rules.metadata.conversation = JSON.parse(data.metadata.sigma_rules.metadata.conversation);
                                } catch (e) {
                                    console.error('Failed to parse conversation log:', e);
                                    data.metadata.sigma_rules.metadata.conversation = [];
                                }
                            }
                            console.log('Auto-opening sigma modal from URL fragment (API)');
                            setTimeout(() => showSigmaRulesModal(data.metadata.sigma_rules.rules, data.metadata.sigma_rules), 500);
                        } else {
                            console.log('No sigma data found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for sigma:', error);
                    });
            }
        } else if (hash === 'iocs') {
            console.log('Processing iocs hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id|default(0)|int }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasIOCs = {{ 'true' if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'false' }};
                console.log('Has iocs (template):', hasIOCs);
                
                if (hasIOCs) {
                    const iocData = {{ article.article_metadata.get('extracted_iocs') | tojson if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'null' }};
                    console.log('IOCs data (template):', iocData);
                    
                    if (iocData) {
                        console.log('Auto-opening IOCs modal from URL fragment (template)');
                        setTimeout(() => showIOCsModal(JSON.stringify(iocData.iocs, null, 2), iocData), 500);
                    }
                } else {
                    console.log('No IOCs found in template data');
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching IOCs data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for IOCs:', data);
                        if (data.article_metadata && data.article_metadata.extracted_iocs) {
                            console.log('Auto-opening IOCs modal from URL fragment (API)');
                            setTimeout(() => showIOCsModal(JSON.stringify(data.article_metadata.extracted_iocs.iocs, null, 2), data.article_metadata.extracted_iocs), 500);
                        } else {
                            console.log('No IOCs found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for IOCs:', error);
                    });
            }
        } else if (hash === 'ranking') {
            console.log('Processing ranking hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id|default(0)|int }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasRanking = {{ 'true' if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'false' }};
                console.log('Has ranking (template):', hasRanking);
                
                if (hasRanking) {
                    const rankingData = {{ article.article_metadata.get('gpt4o_ranking') | tojson if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'null' }};
                    console.log('Ranking data (template):', rankingData);
                    
                    if (rankingData && rankingData.analysis) {
                        console.log('Auto-opening GPT4o ranking from URL fragment (template)');
                        setTimeout(() => {
                            showGPT4oRankingModal(rankingData.analysis, rankingData);
                        }, 500);
                    }
                } else {
                    console.log('No ranking found in template data');
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching ranking data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for ranking:', data);
                        if (data.article_metadata && data.article_metadata.gpt4o_ranking && data.article_metadata.gpt4o_ranking.analysis) {
                            console.log('Auto-opening GPT4o ranking from URL fragment (API)');
                            setTimeout(() => {
                                showGPT4oRankingModal(data.article_metadata.gpt4o_ranking.analysis, data.article_metadata.gpt4o_ranking);
                            }, 500);
                        } else {
                            console.log('No ranking found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for ranking:', error);
                    });
            }
        }
        
        // Clear the hash from URL after handling (with delay to allow modal to open)
        if (hash) {
            console.log('Clearing URL hash:', hash);
            setTimeout(() => {
                window.history.replaceState(null, null, window.location.pathname);
            }, 1000);
        }
    });
    
    // Chunk Debug Modal Functions
    async function showChunkDebugModal() {
        closeAIAssistantModal();
        
        // Show loading modal
        const loadingModal = document.createElement('div');
        loadingModal.id = 'chunkDebugLoadingModal';
        loadingModal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50 flex items-center justify-center p-4';
        loadingModal.innerHTML = `
            <div class="mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-blue-100">
                        <svg class="animate-spin h-6 w-6 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <h3 class="text-lg font-medium text-gray-900 mt-4">Analyzing Chunks</h3>
                    <p class="text-sm text-gray-500 mt-2">Processing article content and analyzing chunking decisions...</p>
                    <div class="mt-6 flex flex-col items-center space-y-3">
                        <button id="cancelBtnChunk" class="px-6 py-2.5 bg-red-600 text-white text-sm font-medium rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 shadow-sm transition-colors">
                            Cancel Operation
                        </button>
                        <div class="flex items-center space-x-2 text-sm text-gray-600">
                            <span>Press</span>
                            <kbd class="px-2 py-1 bg-gray-100 border border-gray-300 rounded text-xs font-semibold text-gray-700 shadow-sm">ESC</kbd>
                            <span>or click outside to dismiss (operation continues)</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(loadingModal);
        
        // Track if request has started
        let chunkRequestStarted = false;
        
        // Create AbortController for cancellation
        const chunkAbortController = new AbortController();
        let chunkIsCancelled = false;
        
        // Cancel handler function
        const handleChunkCancel = function() {
            if (chunkRequestStarted && !chunkIsCancelled) {
                chunkIsCancelled = true;
                chunkAbortController.abort();
                showNotification('Chunk debug analysis cancelled', 'info');
            }
            const modal = document.getElementById('chunkDebugLoadingModal');
            if (modal && modal.parentNode) {
                modal.remove();
            }
            document.removeEventListener('keydown', handleChunkEsc);
        };
        
        // Close modal when clicking outside (dismiss without cancelling)
        loadingModal.addEventListener('click', function(e) {
            if (e.target === loadingModal) {
                const modal = document.getElementById('chunkDebugLoadingModal');
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleChunkEsc);
            }
        });
        
        // Add ESC key handler to close loading modal (dismiss without cancelling)
        const handleChunkEsc = function(e) {
            if (e.key === 'Escape') {
                // ESC just closes the modal, operation continues in background
                const modal = document.getElementById('chunkDebugLoadingModal');
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleChunkEsc);
            }
        };
        document.addEventListener('keydown', handleChunkEsc);
        
        // Wire up cancel button
        const cancelBtnChunk = loadingModal.querySelector('#cancelBtnChunk');
        if (cancelBtnChunk) {
            cancelBtnChunk.addEventListener('click', handleChunkCancel);
        }
        
        try {
            // Create a timeout promise - shorter for faster response
            const chunkDebugTimeoutMs = 180000;
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Request timed out after 180 seconds')), chunkDebugTimeoutMs);
            });
            
            // Create the fetch promise
            chunkRequestStarted = true;
            const fetchPromise = (async () => {
                const currentThreshold = window.chunkDebugThreshold || 0.7;
                const response = await fetch(`/api/articles/{{ article.id|default(0)|int }}/chunk-debug?chunk_size=1000&overlap=200&min_confidence=${currentThreshold}`, {
                    signal: chunkAbortController.signal
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            })();
            
            // Race between fetch and timeout
            const debugData = await Promise.race([fetchPromise, timeoutPromise]);
            
            // Remove loading modal and clean up ESC handler
            if (loadingModal && loadingModal.parentNode) {
                loadingModal.remove();
            }
            document.removeEventListener('keydown', handleChunkEsc);
            
            // Show truncation warnings if any
            if (debugData.warnings && Array.isArray(debugData.warnings) && debugData.warnings.length > 0) {
                debugData.warnings.forEach(warning => {
                    showNotification(`‚ö†Ô∏è LMStudio Truncation: ${warning}`, 'warning');
                });
            }
            
            // Show chunk debug modal
            showChunkDebugResults(debugData);
            
        } catch (error) {
            console.error('Chunk debug error:', error);
            // Don't show error if request was cancelled
            if (chunkIsCancelled || error.name === 'AbortError') {
                return; // Already handled in handleChunkCancel
            }
            if (loadingModal && loadingModal.parentNode) {
                loadingModal.remove();
            }
            document.removeEventListener('keydown', handleChunkEsc);
            
            if (error.message.includes('timed out')) {
                showNotification('Chunk debug analysis timed out after 180 seconds. Showing partial results.', 'warning');
            } else {
                showNotification('Failed to load chunk debug data: ' + error.message, 'error');
            }
        }
    }
    function generateProcessingSummary(summary) {
        if (!summary) {
            return '';
        }
        
        const {
            processed_chunks = 0,
            total_chunks = 0,
            chunk_limit_applied = false,
            concurrency_limit = 1,
            per_chunk_timeout_seconds = 0,
            full_analysis = false,
            remaining_chunks = null
        } = summary;
        const timeoutSeconds = Number(per_chunk_timeout_seconds || 0);
        const remaining = remaining_chunks !== null ? remaining_chunks : Math.max(total_chunks - processed_chunks, 0);
        const showFinishButton = chunk_limit_applied && !full_analysis;
        
        const statusClass = chunk_limit_applied 
            ? 'bg-amber-500/10 border-amber-500/30 text-amber-400' 
            : 'bg-emerald-500/10 border-emerald-500/30 text-emerald-400';
        const statusLabel = chunk_limit_applied ? '‚ö†Ô∏è Partial Analysis' : '‚úÖ Full Analysis';
        const details = chunk_limit_applied
            ? `Processed ${processed_chunks} of ${total_chunks} chunks (${remaining} remaining).`
            : `Processed all ${processed_chunks} chunks.`;
        
        const buttonHtml = showFinishButton ? `
            <div class="mt-3">
                <button id="chunkFinishAnalysisButton"
                        onclick="runFullChunkAnalysis()"
                        class="inline-flex items-center gap-2 px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white text-xs font-semibold rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition-colors">
                    <span class="finish-text">Finish Full Analysis</span>
                    <svg class="finish-spinner hidden animate-spin h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </button>
            </div>
        ` : '';
        
        return `
            <div class="mb-6 p-4 ${statusClass} rounded-lg border">
                <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-2">
                    <div>
                        <div class="text-sm font-semibold">${statusLabel}</div>
                        <div class="text-xs mt-1">${details}</div>
                        ${buttonHtml}
                    </div>
                    <div class="text-xs text-gray-300 md:text-right">
                        <div>Concurrency: ${concurrency_limit}</div>
                        <div>Chunk timeout: ${timeoutSeconds.toFixed(1)}s</div>
                    </div>
                </div>
            </div>
        `;
    }
    
    async function runFullChunkAnalysis() {
        if (!window.chunkDebugData || window.chunkDebugFullAnalysisInProgress) {
            return;
        }
        
        window.chunkDebugFullAnalysisInProgress = true;
        
        const button = document.getElementById('chunkFinishAnalysisButton');
        const spinner = button ? button.querySelector('.finish-spinner') : null;
        const text = button ? button.querySelector('.finish-text') : null;
        if (button) {
            button.disabled = true;
            if (spinner) {
                spinner.classList.remove('hidden');
            }
            if (text) {
                text.textContent = 'Analyzing...';
            }
        }
        
        try {
            const articleId = window.chunkDebugData.article_id;
            const chunkSize = window.chunkDebugData.chunk_size || 1000;
            const overlap = window.chunkDebugData.overlap || 200;
            const currentThreshold = window.chunkDebugThreshold || window.chunkDebugData.min_confidence || 0.7;
            
            showNotification('Completing full chunk analysis...', 'info');
            
            const params = new URLSearchParams({
                chunk_size: String(chunkSize),
                overlap: String(overlap),
                min_confidence: String(currentThreshold),
                full_analysis: 'true'
            });
            
            const response = await fetch(`/api/articles/${articleId}/chunk-debug?${params.toString()}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const debugData = await response.json();
            
            // Show truncation warnings if any
            if (debugData.warnings && Array.isArray(debugData.warnings) && debugData.warnings.length > 0) {
                debugData.warnings.forEach(warning => {
                    showNotification(`‚ö†Ô∏è LMStudio Truncation: ${warning}`, 'warning');
                });
            }
            
            updateChunkDebugResults(debugData);
            
            showNotification('Full chunk analysis completed successfully.', 'success');
        } catch (error) {
            console.error('Full chunk analysis error:', error);
            showNotification('Failed to complete full analysis: ' + error.message, 'error');
        } finally {
            if (button) {
                button.disabled = false;
                if (spinner) {
                    spinner.classList.add('hidden');
                }
                if (text) {
                    text.textContent = 'Finish Full Analysis';
                }
            }
            window.chunkDebugFullAnalysisInProgress = false;
        }
    }
    
    function showChunkDebugResults(data) {
        try {
            if (!data) {
                console.error('showChunkDebugResults: data is required');
                return;
            }
            // Create modal
            const modal = document.createElement('div');
            // Clean up existing modal
            const existingModal = document.getElementById('chunkDebugModal');
            if (existingModal) {
                if (window.ModalManager) {
                    const stack = window.ModalManager.getStack();
                    while (stack.includes('chunkDebugModal')) {
                        const index = stack.indexOf('chunkDebugModal');
                        stack.splice(index, 1);
                    }
                }
                existingModal.remove();
            }
            
            modal.id = 'chunkDebugModal';
            modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm overflow-y-auto h-full w-full z-50';
            
            // Generate chunk visualization
            let chunkVisualization = '';
            try {
                if (typeof generateChunkVisualization === 'function') {
                    chunkVisualization = generateChunkVisualization(data);
                }
            } catch (e) {
                console.error('Error generating chunk visualization:', e);
                chunkVisualization = '<div class="p-4 text-red-400">Error generating visualization</div>';
            }
            
            modal.innerHTML = `
            <div class="relative top-4 mx-auto p-6 border border-gray-700 w-11/12 max-w-7xl shadow-lg rounded-xl bg-gray-800 max-h-[90vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-6">
                    <h3 class="text-2xl font-bold text-gray-50">üîç Junk Filter Tuning</h3>
                    <button onclick="closeChunkDebugModal()" class="text-gray-400 hover:text-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <!-- Threshold Selector -->
                <div class="mb-6 p-4 bg-blue-500/10 border border-blue-500/30 rounded-lg">
                    <div class="flex items-center justify-between">
                        <div>
                            <h4 class="text-lg font-semibold text-blue-400 mb-2">üéØ ML Confidence Threshold</h4>
                            <p class="text-sm text-gray-300">Adjust the minimum ML model confidence required to keep chunks for the LLM</p>
                        </div>
                        <div class="flex items-center space-x-4">
                            <label for="thresholdSlider" class="text-sm font-medium text-gray-300">Threshold:</label>
                            <input type="range" id="thresholdSlider" min="0" max="2" step="1" value="1" 
                                   class="w-32 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer
                                          [&::-webkit-slider-thumb]:appearance-none
                                          [&::-webkit-slider-thumb]:w-4 [&::-webkit-slider-thumb]:h-4
                                          [&::-webkit-slider-thumb]:bg-purple-500 [&::-webkit-slider-thumb]:rounded-full
                                          [&::-webkit-slider-thumb]:cursor-pointer
                                          [&::-webkit-slider-thumb]:hover:bg-purple-400"
                                   onchange="updateThresholdFromSlider(this.value)">
                            <span id="thresholdValue" class="text-lg font-bold text-blue-400">0.7</span>
                        </div>
                    </div>
                    <div class="mt-3 grid grid-cols-3 gap-2 text-xs">
                        <div class="text-center p-2 bg-[#0a0e1a] border border-gray-700 rounded-lg">
                            <div class="font-semibold text-emerald-400">0.5 (Aggressive)</div>
                            <div class="text-gray-400">Keeps more chunks</div>
                        </div>
                        <div class="text-center p-2 bg-[#0a0e1a] border border-purple-500/50 rounded-lg">
                            <div class="font-semibold text-blue-400">0.7 (Balanced)</div>
                            <div class="text-gray-400">Current setting</div>
                        </div>
                        <div class="text-center p-2 bg-[#0a0e1a] border border-gray-700 rounded-lg">
                            <div class="font-semibold text-red-400">0.8 (Conservative)</div>
                            <div class="text-gray-400">Removes more chunks</div>
                        </div>
                    </div>
                </div>

                <!-- Statistics Overview -->
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                    <div class="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
                        <div id="totalChunksCount" class="text-2xl font-bold text-blue-400">${data.total_chunks !== undefined ? data.total_chunks : 0}</div>
                        <div class="text-sm text-gray-300">Total Chunks</div>
                    </div>
                    <div class="bg-emerald-500/10 border border-emerald-500/30 rounded-lg p-4">
                        <div id="keptChunksCount" class="text-2xl font-bold text-emerald-400">${data.kept_chunks !== undefined ? data.kept_chunks : 0}</div>
                        <div class="text-sm text-gray-300">Kept for LLM</div>
                    </div>
                    <div class="bg-red-500/10 border border-red-500/30 rounded-lg p-4">
                        <div id="removedChunksCount" class="text-2xl font-bold text-red-400">${data.removed_chunks !== undefined ? data.removed_chunks : 0}</div>
                        <div class="text-sm text-gray-300">Filtered Out</div>
                    </div>
                    <div class="bg-purple-500/10 border border-purple-500/30 rounded-lg p-4">
                        <div id="contentReductionPercent" class="text-2xl font-bold text-purple-400">${data.filtering_stats && data.filtering_stats.reduction_percent ? data.filtering_stats.reduction_percent.toFixed(1) : '0.0'}%</div>
                        <div class="text-sm text-gray-300">Content Reduction</div>
                    </div>
                </div>
                
                <div id="chunkProcessingSummary">
                    ${(typeof generateProcessingSummary === 'function' && data.processing_summary) ? generateProcessingSummary(data.processing_summary) : '<div class="p-4 text-gray-400">No processing summary available</div>'}
                </div>
                
                <!-- ML Accuracy Statistics -->
                <div class="bg-indigo-500/10 border border-indigo-500/30 rounded-lg p-4 mb-6">
                    <h4 class="text-lg font-semibold text-indigo-400 mb-3">ü§ñ ML Model Performance</h4>
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                        <div>
                            <div class="text-sm text-gray-300">ML Predictions</div>
                            <div class="text-lg font-semibold text-gray-50">${data.ml_stats && data.ml_stats.total_predictions !== undefined ? data.ml_stats.total_predictions : 0}</div>
                        </div>
               <div>
                   <div class="text-sm text-gray-300">Matching Predictions</div>
                   <div class="text-lg font-semibold text-emerald-400">${data.ml_stats && data.ml_stats.correct_predictions !== undefined ? data.ml_stats.correct_predictions : 0}</div>
               </div>
                        <div>
                            <div class="text-sm text-gray-300">Accuracy</div>
                            <div class="text-lg font-semibold ${data.ml_stats && data.ml_stats.accuracy_percent !== undefined ? (data.ml_stats.accuracy_percent >= 80 ? 'text-emerald-400' : data.ml_stats.accuracy_percent >= 60 ? 'text-amber-400' : 'text-red-400') : 'text-gray-400'}">${data.ml_stats && data.ml_stats.accuracy_percent !== undefined ? data.ml_stats.accuracy_percent.toFixed(1) : '0.0'}%</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-300">Mismatches</div>
                            <div class="text-lg font-semibold text-amber-400">${data.ml_stats && data.ml_stats.mismatches !== undefined ? data.ml_stats.mismatches : 0}</div>
                        </div>
                    </div>
                </div>
                
                <!-- Cost Analysis -->
                <div class="bg-gray-800 border border-gray-700 rounded-lg p-4 mb-6">
                    <div class="flex items-center justify-between mb-3">
                        <h4 class="text-lg font-semibold text-gray-50">üí∞ Cost Analysis</h4>
                        <div class="relative group">
                            <button class="text-gray-400 hover:text-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-900" onclick="showCostAnalysisHelp()">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"></path>
                                </svg>
                            </button>
                            <div id="costAnalysisTooltip" class="absolute right-0 top-8 w-64 p-3 bg-gray-800 border border-gray-700 text-gray-300 text-sm rounded-lg shadow-lg opacity-0 invisible transition-all duration-200 z-50">
                                <div class="absolute -top-1 right-4 w-2 h-2 bg-gray-800 border-l border-t border-gray-700 transform rotate-45"></div>
                                These estimates are based on OpenAI API call costs and are not literal when using Local LLM. They represent potential savings if using OpenAI's GPT-4o service.
                            </div>
                        </div>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div>
                            <div class="text-sm text-gray-300">Original Content</div>
                            <div id="originalContentLength" class="text-lg font-semibold text-gray-50">${data.content_length !== undefined ? data.content_length.toLocaleString() : '0'} chars</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-300">Estimated Cost Savings per Article</div>
                            <div id="costSavings" class="text-lg font-semibold text-emerald-400">$${data.filtering_stats && data.filtering_stats.cost_savings ? data.filtering_stats.cost_savings.toFixed(4) : '0.0000'}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-300">Tokens Saved</div>
                            <div id="tokensSaved" class="text-lg font-semibold text-blue-400">${data.filtering_stats && data.filtering_stats.tokens_saved ? data.filtering_stats.tokens_saved.toLocaleString() : '0'}</div>
                        </div>
                    </div>
                </div>
                
                <!-- Chunk Visualization -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-gray-50 mb-3">üìä Chunk Visualization</h4>
                    <div class="bg-[#0a0e1a] border border-gray-700 rounded-lg p-4">
                        <div id="chunkVisualizationContainer">
                            ${chunkVisualization}
                        </div>
                    </div>
                </div>
                
                <!-- Filter Controls -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-gray-50 mb-3">üéõÔ∏è Filter Controls</h4>
                    <div class="flex flex-wrap gap-4">
                        <button onclick="filterChunks('all')" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition-colors">
                            Show All Chunks
                        </button>
                        <button onclick="filterChunks('kept')" class="px-4 py-2 bg-emerald-500 hover:bg-emerald-600 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition-colors">
                            Show Kept Only
                        </button>
                        <button onclick="filterChunks('removed')" class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition-colors">
                            Show Removed Only
                        </button>
                        <button onclick="filterChunks('threat')" class="px-4 py-2 bg-amber-500 hover:bg-amber-600 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-amber-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition-colors">
                            Show Threat Keywords
                        </button>
                        <button onclick="filterChunks('perfect')" class="px-4 py-2 bg-purple-500 hover:bg-purple-600 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition-colors">
                            Show Perfect Discriminators
                        </button>
                        <button onclick="filterChunks('ml')" class="px-4 py-2 bg-purple-500 hover:bg-purple-600 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition-colors">
                            Show ML Predictions
                        </button>
                        <button onclick="filterChunks('confidenceBand')" class="px-4 py-2 bg-teal-500 hover:bg-teal-600 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition-colors" title="Show chunks with confidence between 40% and 60%">
                            Show 40-60% Confidence
                        </button>
                        <button onclick="filterChunks('mismatch')" class="px-4 py-2 bg-amber-500 hover:bg-amber-600 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-amber-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition-colors" title="Show chunks where ML prediction differs from actual decision">
                            Show ML Mismatches
                        </button>
                    </div>
                </div>
                
                <!-- Chunk Details -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-gray-900 mb-3">üìù Chunk Details</h4>
                    <div id="chunkDetails" class="space-y-4">
                        ${(typeof generateChunkDetails === 'function' && data.chunk_analysis) ? generateChunkDetails(data.chunk_analysis) : '<div class="p-4 text-gray-500">No chunk analysis data available</div>'}
                    </div>
                </div>
                
                <div class="flex justify-end">
                    <button onclick="closeChunkDebugModal()" 
                            class="px-6 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 transition-colors">
                        Close
                    </button>
                </div>
            </div>
            `;
            
            document.body.appendChild(modal);
            
            // Ensure modal is visible
            modal.classList.remove('hidden');
            
            // Register and open with ModalManager
            if (window.ModalManager) {
                setTimeout(() => {
                    window.ModalManager.register('chunkDebugModal', {
                        isDynamic: true,
                        hasInput: false
                    });
                    window.ModalManager.open('chunkDebugModal');
                    modal.classList.remove('hidden');
                }, 50);
            }
            
            // Store debug data globally for filtering
            window.chunkDebugData = data;
            window.chunkDebugFullAnalysisInProgress = false;
        } catch (e) {
            console.error('Error in showChunkDebugResults:', e);
            alert('Error displaying chunk debug results: ' + e.message);
            return;
        }
        
        // Post-processing (only if modal was successfully created)
        if (data && data.processing_summary?.chunk_limit_applied) {
            showNotification(
                `Processed ${data.processing_summary.processed_chunks} of ${data.processing_summary.total_chunks} chunks (analysis limit applied).`,
                'warning'
            );
        }
        
        // Initialize slider position based on current threshold
        if (data) {
            const thresholdSlider = document.getElementById('thresholdSlider');
            if (thresholdSlider && data.min_confidence !== undefined) {
                thresholdSlider.value = getSliderFromThreshold(data.min_confidence);
            }
            
            // Load existing feedback for all chunks
            if (data.chunk_analysis && Array.isArray(data.chunk_analysis)) {
                for (let i = 0; i < data.chunk_analysis.length; i++) {
                    loadExistingFeedback(i);
                }
            }
        }
    }
    
    function generateChunkVisualization(data) {
        if (!data) return '';
        const totalLength = data.content_length !== undefined ? data.content_length : 0;
        const chunks = data.chunk_analysis || [];
        
        let html = '<div class="relative bg-gray-700 rounded-lg p-2 mb-4" style="height: 60px;">';
        
        chunks.forEach((chunk, index) => {
            const width = (chunk.length / totalLength) * 100;
            const left = (chunk.start / totalLength) * 100;
            const color = chunk.is_kept ? 'bg-emerald-500' : 'bg-red-500';
            const opacity = chunk.is_kept ? 'opacity-80' : 'opacity-60';
            
            // Add mismatch indicator
            const mismatchClass = chunk.ml_mismatch ? 'ring-2 ring-amber-400' : '';
            const mismatchTitle = chunk.ml_mismatch ? ' (ML MISMATCH)' : '';
            
            html += `
                <div class="absolute ${color} ${opacity} ${mismatchClass} rounded cursor-pointer hover:opacity-100 transition-opacity"
                     style="left: ${left}%; width: ${width}%; height: 100%;"
                     title="Chunk ${chunk.chunk_id}: ${chunk.length} chars (${chunk.is_kept ? 'KEPT' : 'REMOVED'})${mismatchTitle}"
                     onclick="highlightChunk(${index})">
                </div>
            `;
        });
        
        html += '</div>';
        
        // Add legend
        html += `
            <div class="flex items-center space-x-4 text-sm text-gray-300">
                <div class="flex items-center">
                    <div class="w-4 h-4 bg-emerald-500 rounded mr-2"></div>
                    <span>Kept for LLM</span>
                </div>
                <div class="flex items-center">
                    <div class="w-4 h-4 bg-red-500 rounded mr-2"></div>
                    <span>Filtered Out</span>
                </div>
                <div class="flex items-center">
                    <div class="w-4 h-4 bg-amber-400 rounded mr-2 ring-2 ring-amber-400"></div>
                    <span>ML Mismatch</span>
                </div>
            </div>
        `;
        
        return html;
    }
    function generateChunkDetails(chunks) {
        return chunks.map((chunk, index) => `
            <div class="chunk-detail border rounded-lg p-4 ${chunk.is_kept ? 'bg-emerald-500/10 border-emerald-500/30' : 'bg-red-500/10 border-red-500/30'}" data-chunk-id="${index}">
                <div class="flex justify-between items-start mb-2">
                    <div class="flex items-center space-x-2">
                        <span class="font-semibold text-gray-50">Chunk ${chunk.chunk_id}</span>
                        <span class="px-2 py-0.5 text-xs rounded ${chunk.is_kept ? 'bg-emerald-500/10 text-emerald-400 border border-emerald-500/30' : 'bg-red-500/10 text-red-400 border border-red-500/30'}">
                            ${chunk.is_kept ? 'KEPT' : 'REMOVED'}
                        </span>
                        ${chunk.has_threat_keywords ? '<span class="px-2 py-0.5 text-xs rounded bg-amber-500/10 text-amber-400 border border-amber-500/30">THREAT</span>' : ''}
                        ${chunk.has_command_patterns ? '<span class="px-2 py-0.5 text-xs rounded bg-blue-500/10 text-blue-400 border border-blue-500/30">COMMAND</span>' : ''}
                        ${chunk.has_perfect_discriminators ? '<span class="px-2 py-0.5 text-xs rounded bg-purple-500/10 text-purple-400 border border-purple-500/30">PERFECT</span>' : ''}
                        ${chunk.ml_mismatch ? '<span class="px-2 py-0.5 text-xs rounded bg-amber-500/10 text-amber-400 border border-amber-500/30">ML MISMATCH</span>' : ''}
                    </div>
                    <div class="text-sm text-gray-300">
                        ${chunk.length} chars (${chunk.start}-${chunk.end})
                    </div>
                </div>
                
                <!-- ML Prediction Details -->
                ${chunk.ml_details && !chunk.ml_details.error ? `
                    <div class="bg-blue-500/10 border border-blue-500/30 rounded-lg p-3 mb-3">
                        <div class="flex items-center justify-between mb-2">
                            <h5 class="font-semibold text-blue-400">ü§ñ Random Forest Prediction</h5>
                            <span class="px-2 py-0.5 text-xs rounded ${chunk.ml_details.prediction_label === 'Huntable' ? 'bg-emerald-500/10 text-emerald-400 border border-emerald-500/30' : 'bg-red-500/10 text-red-400 border border-red-500/30'}">
                                ${chunk.ml_details.prediction_label}
                            </span>
                        </div>
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <div>
                                <div class="text-gray-300">Confidence:</div>
                                <div class="font-semibold text-gray-50">${(() => {
                                    let conf = chunk.ml_details.confidence;
                                    if (conf === undefined || conf === null) {
                                        conf = Math.max(chunk.ml_details.probabilities.huntable, chunk.ml_details.probabilities.not_huntable);
                                    }
                                    return (conf * 100).toFixed(1);
                                })()}%</div>
                            </div>
                            <div>
                                <div class="text-gray-300">Probabilities:</div>
                                <div class="font-semibold text-gray-50">
                                    Huntable: ${(chunk.ml_details.probabilities.huntable * 100).toFixed(1)}% | 
                                    Not Huntable: ${(chunk.ml_details.probabilities.not_huntable * 100).toFixed(1)}%
                                </div>
                            </div>
                        </div>
                        
                        <!-- Top Features -->
                        ${chunk.ml_details.top_features ? `
                            <div class="mt-3">
                                <div class="text-gray-300 text-sm mb-1">Top Contributing Features:</div>
                                <div class="flex flex-wrap gap-1">
                                    ${Object.entries(chunk.ml_details.top_features).slice(0, 5).map(([feature, importance]) => `
                                        <span class="px-2 py-1 text-xs bg-blue-500/10 text-blue-400 border border-blue-500/30 rounded" title="Contribution: ${importance.toFixed(3)}">
                                            ${feature}: ${importance.toFixed(3)}
                                        </span>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                ` : chunk.ml_details && chunk.ml_details.error ? `
                    <div class="bg-amber-500/10 border border-amber-500/30 rounded-lg p-3 mb-3">
                        <div class="text-amber-400 text-sm">
                            <strong>ML Error:</strong> ${chunk.ml_details.error}
                        </div>
                    </div>
                ` : `
                    <div class="bg-gray-800 border border-gray-700 rounded-lg p-3 mb-3">
                        <div class="text-gray-300 text-sm">
                            <strong>Pattern-based Classification</strong> (ML model not available)
                        </div>
                    </div>
                `}
                
                <div class="text-sm text-gray-300 mb-2">
                    <strong>Reason:</strong> ${chunk.reason}
                    ${chunk.confidence && !isNaN(chunk.confidence) && chunk.confidence > 0 ? ` | <strong>Confidence:</strong> ${(chunk.confidence * 100).toFixed(1)}%` : ''}
                </div>
                
                <!-- Feedback Section (only show when ML model is available) -->
                ${chunk.ml_details && !chunk.ml_details.error ? `
                <div class="mb-3 p-3 bg-gray-800 border border-gray-700 rounded-lg">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm font-medium text-gray-300">Was this ML classification correct?</span>
                        <div class="flex gap-2">
                            <button onclick="submitChunkFeedback(${index}, true)" 
                                    class="px-3 py-1 text-xs bg-emerald-500/10 text-emerald-400 border border-emerald-500/30 rounded-lg hover:bg-emerald-500/20 transition-colors focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                                ‚úÖ Correct - ${chunk.ml_details.prediction_label}
                            </button>
                            <button onclick="submitChunkFeedback(${index}, false)" 
                                    class="px-3 py-1 text-xs bg-red-500/10 text-red-400 border border-red-500/30 rounded-lg hover:bg-red-500/20 transition-colors focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                                ‚ùå Incorrect - ${chunk.ml_details.prediction_label === 'Huntable' ? 'Not Huntable' : 'Huntable'}
                            </button>
                        </div>
                    </div>
                    <div id="feedbackSubmitted${index}" class="hidden text-xs text-emerald-400">
                        ‚úÖ Feedback submitted - Thank you!
                    </div>
                    <div id="existingFeedback${index}" class="hidden mt-2">
                        <!-- Previous feedback will be loaded here -->
                    </div>
                </div>
                ` : ''}
                
                <!-- Feature Details -->
                <div class="mb-3">
                    <button onclick="toggleFeatureDetails(${index})" class="w-full flex items-center justify-between p-2 text-sm text-gray-300 hover:text-gray-50 hover:bg-gray-700/50 rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                        <span class="font-medium">üìä Feature Details</span>
                        <svg id="featureDetailsIcon${index}" class="w-4 h-4 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </button>
                    <div id="featureDetails${index}" class="hidden mt-2 bg-[#0a0e1a] border border-gray-700 rounded-lg p-3 text-xs">
                        <div class="grid grid-cols-2 gap-2">
                            ${Object.entries(chunk.features).map(([key, value]) => `
                                <div class="flex justify-between">
                                    <span class="text-gray-300">${key}:</span>
                                    <span class="font-mono text-gray-50">${typeof value === 'number' ? value.toFixed(3) : value}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
                
                <div class="text-sm bg-[#0a0e1a] border border-gray-700 rounded-lg p-3">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-xs text-gray-400">Chunk Content (${chunk.length} chars)</span>
                        <!-- COMMENTED OUT: Truncation control button -->
                        <!-- <button onclick="toggleChunkContent(${index})" class="text-xs text-blue-400 hover:text-blue-300 font-medium">
                            üìÑ ${chunk.text.length > 200 ? 'Show Full Text' : 'View Text'}
                        </button> -->
                    </div>
                    <!-- COMMENTED OUT: Truncation control - showing full content directly -->
                    <div id="chunkContent${index}" class="max-h-96 overflow-y-auto text-xs font-mono whitespace-pre-wrap text-gray-300">
                        ${chunk.text}
                    </div>
                    <!-- <div id="chunkContent${index}" class="max-h-32 overflow-y-auto">
                        ${chunk.text.substring(0, 200)}${chunk.text.length > 200 ? '...' : ''}
                    </div>
                    <div id="chunkContentFull${index}" class="hidden max-h-96 overflow-y-auto text-xs font-mono whitespace-pre-wrap">
                        ${chunk.text}
                    </div> -->
                </div>
            </div>
        `).join('');
    }
    
    function getNormalizedConfidence(chunkData) {
        if (!chunkData) {
            return null;
        }
        
        let confidence = null;
        
        // First try to get confidence from ml_details.confidence
        if (chunkData.ml_details && typeof chunkData.ml_details.confidence !== 'undefined' && chunkData.ml_details.confidence !== null) {
            confidence = parseFloat(chunkData.ml_details.confidence);
        }
        
        // If not found, calculate from probabilities
        if ((confidence === null || Number.isNaN(confidence)) && chunkData.ml_details && chunkData.ml_details.probabilities) {
            const probs = chunkData.ml_details.probabilities;
            if (probs.huntable !== undefined && probs.not_huntable !== undefined) {
                confidence = Math.max(parseFloat(probs.huntable), parseFloat(probs.not_huntable));
            }
        }
        
        // Fallback to chunk confidence
        if ((confidence === null || Number.isNaN(confidence)) && typeof chunkData.confidence !== 'undefined' && chunkData.confidence !== null) {
            confidence = parseFloat(chunkData.confidence);
        }
        
        if (confidence === null || Number.isNaN(confidence)) {
            return null;
        }
        
        // Normalize percentage values into 0-1 range
        if (confidence > 1) {
            confidence = confidence / 100;
        }
        
        // Clamp to [0,1]
        confidence = Math.min(Math.max(confidence, 0), 1);
        return confidence;
    }
    
    function filterChunks(filter) {
        const chunkDetails = document.getElementById('chunkDetails');
        const chunks = chunkDetails.querySelectorAll('.chunk-detail');
        
        chunks.forEach(chunk => {
            const chunkId = parseInt(chunk.dataset.chunkId);
            const chunkData = window.chunkDebugData.chunk_analysis[chunkId];
            
            let show = false;
            
            switch(filter) {
                case 'all':
                    show = true;
                    break;
                case 'kept':
                    show = chunkData.is_kept;
                    break;
                case 'removed':
                    show = !chunkData.is_kept;
                    break;
                case 'threat':
                    show = chunkData.has_threat_keywords || chunkData.has_command_patterns;
                    break;
                case 'perfect':
                    show = chunkData.has_perfect_discriminators;
                    break;
                case 'ml':
                    show = chunkData.ml_details && !chunkData.ml_details.error;
                    break;
                case 'confidenceBand': {
                    const confidence = getNormalizedConfidence(chunkData);
                    if (confidence !== null && confidence >= 0.4 && confidence <= 0.6) {
                        show = true;
                    }
                    break;
                }
                case 'mismatch':
                    show = chunkData.ml_mismatch === true;
                    break;
            }
            
            chunk.style.display = show ? 'block' : 'none';
        });
    }
    
    function highlightChunk(chunkIndex) {
        // Scroll to chunk detail
        const chunkDetail = document.querySelector(`[data-chunk-id="${chunkIndex}"]`);
        if (chunkDetail) {
            chunkDetail.scrollIntoView({ behavior: 'smooth', block: 'center' });
            chunkDetail.classList.add('ring-2', 'ring-blue-500');
            setTimeout(() => {
                chunkDetail.classList.remove('ring-2', 'ring-blue-500');
            }, 2000);
        }
    }
    
    function closeChunkDebugModal() {
        const modal = document.getElementById('chunkDebugModal');
        if (modal) {
            modal.remove();
        }
        // Clear global data
        window.chunkDebugData = null;
    }
    
    // Threshold mapping function
    function getThresholdFromSlider(sliderValue) {
        const thresholds = [0.5, 0.7, 0.8];
        return thresholds[parseInt(sliderValue)];
    }
    
    function getSliderFromThreshold(threshold) {
        const thresholds = [0.5, 0.7, 0.8];
        return thresholds.indexOf(threshold);
    }
    
    // Update threshold from slider position
    async function updateThresholdFromSlider(sliderValue) {
        const threshold = getThresholdFromSlider(sliderValue);
        await updateThreshold(threshold);
    }
    // Threshold update function
    async function updateThreshold(newThreshold) {
        try {
            // Update the display value
            const thresholdValueEl = document.getElementById('thresholdValue');
            if (thresholdValueEl) {
                thresholdValueEl.textContent = newThreshold;
            }
            
            // Update slider position
            const thresholdSlider = document.getElementById('thresholdSlider');
            if (thresholdSlider) {
                thresholdSlider.value = getSliderFromThreshold(parseFloat(newThreshold));
                thresholdSlider.disabled = true; // Show loading state
            }
            
            // Store the threshold globally
            window.chunkDebugThreshold = parseFloat(newThreshold);
            
            // Reload chunk debug data with new threshold
            const chunkSize = window.chunkDebugData?.chunk_size || 1000;
            const overlap = window.chunkDebugData?.overlap || 200;
            const fullAnalysis = window.chunkDebugData?.processing_summary?.full_analysis ? 'true' : 'false';
            
            const params = new URLSearchParams({
                chunk_size: String(chunkSize),
                overlap: String(overlap),
                min_confidence: String(newThreshold),
                full_analysis: fullAnalysis
            });
            
            const response = await fetch(`/api/articles/{{ article.id|default(0)|int }}/chunk-debug?${params.toString()}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const debugData = await response.json();
            
            // Show truncation warnings if any
            if (debugData.warnings && Array.isArray(debugData.warnings) && debugData.warnings.length > 0) {
                debugData.warnings.forEach(warning => {
                    showNotification(`‚ö†Ô∏è LMStudio Truncation: ${warning}`, 'warning');
                });
            }
            
            // Update the modal with new data
            updateChunkDebugResults(debugData);
            
        } catch (error) {
            console.error('Threshold update error:', error);
            showNotification('Failed to update threshold: ' + error.message, 'error');
        } finally {
            // Re-enable slider
            const thresholdSlider = document.getElementById('thresholdSlider');
            if (thresholdSlider) {
                thresholdSlider.disabled = false;
            }
        }
    }
    
    function showCostAnalysisHelp() {
        const tooltip = document.getElementById('costAnalysisTooltip');
        if (tooltip) {
            tooltip.classList.toggle('opacity-0');
            tooltip.classList.toggle('invisible');
            tooltip.classList.toggle('opacity-100');
            tooltip.classList.toggle('visible');
        }
    }

    function updateChunkDebugResults(data) {
        // Update statistics cards using IDs
        const totalChunksEl = document.getElementById('totalChunksCount');
        const keptChunksEl = document.getElementById('keptChunksCount');
        const removedChunksEl = document.getElementById('removedChunksCount');
        const reductionEl = document.getElementById('contentReductionPercent');
        
        if (totalChunksEl) totalChunksEl.textContent = data.total_chunks;
        if (keptChunksEl) keptChunksEl.textContent = data.kept_chunks;
        if (removedChunksEl) removedChunksEl.textContent = data.removed_chunks;
        if (reductionEl) reductionEl.textContent = `${data.filtering_stats && data.filtering_stats.reduction_percent ? data.filtering_stats.reduction_percent.toFixed(1) : '0.0'}%`;
        
        // Update cost analysis
        const originalContentEl = document.getElementById('originalContentLength');
        const costSavingsEl = document.getElementById('costSavings');
        const tokensSavedEl = document.getElementById('tokensSaved');
        
        if (originalContentEl) originalContentEl.textContent = `${data.content_length !== undefined ? data.content_length.toLocaleString() : '0'} chars`;
        if (costSavingsEl) costSavingsEl.textContent = `$${data.filtering_stats && data.filtering_stats.cost_savings ? data.filtering_stats.cost_savings.toFixed(4) : '0.0000'}`;
        if (tokensSavedEl) tokensSavedEl.textContent = `${data.filtering_stats && data.filtering_stats.tokens_saved ? data.filtering_stats.tokens_saved.toLocaleString() : '0'}`;
        
        // Update chunk details
        const chunkDetails = document.getElementById('chunkDetails');
        if (chunkDetails) {
            chunkDetails.innerHTML = generateChunkDetails(data.chunk_analysis);
        }
        
        // Update chunk visualization
        const chunkVisualizationContainer = document.getElementById('chunkVisualizationContainer');
        if (chunkVisualizationContainer) {
            chunkVisualizationContainer.innerHTML = generateChunkVisualization(data);
        }
        
        // Update processing summary
        const summaryContainer = document.getElementById('chunkProcessingSummary');
        if (summaryContainer) {
            summaryContainer.innerHTML = generateProcessingSummary(data.processing_summary);
        }
        
        // Update global data
        window.chunkDebugData = data;
        window.chunkDebugFullAnalysisInProgress = false;
        
        // Show notification
        showNotification(`Threshold updated to ${window.chunkDebugThreshold}. ${data.kept_chunks} chunks kept, ${data.removed_chunks} removed.`, 'success');
        if (data.processing_summary?.chunk_limit_applied) {
            showNotification(
                `Processed ${data.processing_summary.processed_chunks} of ${data.processing_summary.total_chunks} chunks after threshold update (limit applied).`,
                'warning'
            );
        }
    }
    
    // Feedback Functions
    async function submitChunkFeedback(chunkIndex, isCorrect) {
        const chunkData = window.chunkDebugData.chunk_analysis[chunkIndex];
        
        await submitFeedback(chunkIndex, {
            is_correct: isCorrect,
            user_classification: isCorrect ? 
                (chunkData.is_kept ? 'Huntable' : 'Not Huntable') : 
                (chunkData.is_kept ? 'Not Huntable' : 'Huntable'),
            comment: isCorrect ? 'User confirmed classification is correct' : 'User marked classification as incorrect'
        });
    }
    
    async function loadExistingFeedback(chunkIndex) {
        try {
            const response = await fetch(`/api/feedback/chunk-classification/${window.chunkDebugData.article_id}/${chunkIndex}`);
            const result = await response.json();
            
            if (result.success && result.feedback) {
                const feedbackDiv = document.getElementById(`existingFeedback${chunkIndex}`);
                if (feedbackDiv) {
                    const feedback = result.feedback;
                    const timestamp = new Date(feedback.timestamp).toLocaleString();
                    const statusIcon = feedback.is_correct ? '‚úÖ' : '‚ùå';
                    const statusText = feedback.is_correct ? 'Correct' : 'Incorrect';
                    
                    feedbackDiv.innerHTML = `
                        <div class="text-xs text-blue-600 bg-blue-50 p-2 rounded border-l-2 border-blue-400">
                            <div class="font-medium">${statusIcon} Feedback provided (${timestamp})</div>
                        </div>
                    `;
                    feedbackDiv.classList.remove('hidden');
                }
            }
        } catch (error) {
            console.error('Failed to load existing feedback:', error);
        }
    }
    
    async function submitFeedback(chunkIndex, feedbackData) {
        try {
            const chunkData = window.chunkDebugData.chunk_analysis[chunkIndex];
            
            // Get the huntable probability specifically
            let huntable_probability = chunkData.confidence;
            if (chunkData.ml_details && chunkData.ml_details.probabilities) {
                huntable_probability = chunkData.ml_details.probabilities.huntable;
            } else if (chunkData.ml_details && chunkData.ml_details.confidence) {
                // If we only have max confidence, assume it's huntable if is_kept is true
                huntable_probability = chunkData.is_kept ? chunkData.ml_details.confidence : (1.0 - chunkData.ml_details.confidence);
            } else {
                // Fallback: assume confidence is huntable if is_kept is true
                huntable_probability = chunkData.is_kept ? chunkData.confidence : (1.0 - chunkData.confidence);
            }
            
            const payload = {
                article_id: window.chunkDebugData.article_id,
                chunk_id: chunkIndex,
                chunk_text: chunkData.text,
                model_classification: chunkData.is_kept ? 'Huntable' : 'Not Huntable',
                model_confidence: huntable_probability,
                model_reason: chunkData.reason,
                ...feedbackData,
                timestamp: new Date().toISOString()
            };
            
            const response = await fetch('/api/feedback/chunk-classification', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });
            
            if (response.ok) {
                // Show success message
                const feedbackSubmitted = document.getElementById(`feedbackSubmitted${chunkIndex}`);
                if (feedbackSubmitted) {
                    feedbackSubmitted.classList.remove('hidden');
                }
                
                // Reload existing feedback to show updated status
                await loadExistingFeedback(chunkIndex);
                
                showNotification('Feedback submitted successfully!', 'success');
            } else {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }
            
        } catch (error) {
            console.error('Feedback submission error:', error);
            let errorMessage = 'Failed to submit feedback';
            
            if (error.message) {
                errorMessage += ': ' + error.message;
            } else if (error instanceof TypeError) {
                errorMessage += ': Network error or server unavailable';
            } else {
                errorMessage += ': Unknown error occurred';
            }
            
            showNotification(errorMessage, 'error');
        }
    }
    
    async function triggerModelRetraining() {
        try {
            // Show confirmation dialog
            const confirmed = confirm('This will retrain the ML model using collected user feedback. This may take a few minutes. Continue?');
            if (!confirmed) {
                return;
            }
            
            // Show loading state
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'üîÑ Retraining...';
            button.disabled = true;
            
            const response = await fetch('/api/model/retrain', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            const result = await response.json();
            
            if (response.ok) {
                showNotification('Model retraining completed successfully!', 'success');
                
                // Check if comparison data is available
                if (result.has_comparison) {
                    // Show comparison modal
                    await showComparisonModal();
                } else {
                    // Ask if user wants to reload the page to see updated model
                    const reload = confirm('Model retraining complete! Reload the page to see the updated model in action?');
                    if (reload) {
                        window.location.reload();
                    }
                }
            } else {
                throw new Error(result.detail || 'Retraining failed');
            }
            
        } catch (error) {
            console.error('Retraining error:', error);
            showNotification('Failed to retrain model: ' + error.message, 'error');
        } finally {
            // Restore button state
            button.textContent = originalText;
            button.disabled = false;
        }
    }
    
    function toggleFeatureDetails(chunkIndex) {
        const featureDetails = document.getElementById(`featureDetails${chunkIndex}`);
        const icon = document.getElementById(`featureDetailsIcon${chunkIndex}`);
        if (featureDetails) {
            featureDetails.classList.toggle('hidden');
            if (icon) {
                icon.classList.toggle('rotate-180');
            }
        }
    }
    
    // COMMENTED OUT: Truncation control function
    // function toggleChunkContent(chunkIndex) {
    //     const preview = document.getElementById(`chunkContent${chunkIndex}`);
    //     const full = document.getElementById(`chunkContentFull${chunkIndex}`);
    //     const button = preview.parentElement.querySelector('button');
    //     
    //     if (preview && full && button) {
    //         const isHidden = full.classList.contains('hidden');
    //         
    //         if (isHidden) {
    //             // Show full content
    //             preview.classList.add('hidden');
    //             full.classList.remove('hidden');
    //             button.textContent = 'üìÑ Hide Text';
    //         } else {
    //             // Show preview
    //             preview.classList.remove('hidden');
    //             full.classList.add('hidden');
    //             button.textContent = 'üìÑ Show Full Text';
    //         }
    //     }
    // }

    // Check AL/ML Assistant button state on page load
    document.addEventListener('DOMContentLoaded', function() {
        checkAIAssistantButtonState();
    });
    
    function checkAIAssistantButtonState() {
        const button = document.getElementById('aiAssistantBtn');
        if (!button) return;
        
        // Get AI model from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const aiModel = settings.aiModel || 'chatgpt';
        
        // Check content size limits
        const contentLength = {{ article.content|length if article.content else 0 }};
        const contentLimit = aiModel === 'chatgpt' ? {{ chatgpt_content_limit|default(1000000)|int }} :
                           aiModel === 'anthropic' ? {{ anthropic_content_limit|default(1000000)|int }} : {{ chatgpt_content_limit|default(1000000)|int }};
        
        if (contentLength > contentLimit) {
            // Disable button and add explanation
            button.disabled = true;
            button.className = button.className.replace('bg-[#4b4e77] hover:bg-[#7C3AED]', 'bg-gray-400 cursor-not-allowed');
            button.removeAttribute('title'); // Remove tooltip to avoid grey box
            
            // Add warning icon
            const icon = button.querySelector('span');
            if (icon) {
                icon.textContent = '‚ö†Ô∏è';
            }
            
            // Update popover content
            const popover = document.getElementById('aiAssistantPopover');
            const popoverContent = document.getElementById('popoverContent');
            if (popover && popoverContent) {
                popoverContent.textContent = `${contentLength.toLocaleString()} characters (limit: ${contentLimit.toLocaleString()})`;
                
                // Add hover event listeners to wrapper
                const wrapper = document.getElementById('aiAssistantWrapper');
                if (wrapper) {
                    wrapper.addEventListener('mouseenter', function() {
                        popover.classList.remove('hidden');
                    });
                    
                    wrapper.addEventListener('mouseleave', function() {
                        popover.classList.add('hidden');
                    });
                }
            }
        }
    }
    
    // Model Comparison Modal Functions
    async function showComparisonModal() {
        try {
            // Get the latest model version for comparison
            const response = await fetch('/api/model/versions');
            const data = await response.json();
            
            if (!data.success || data.versions.length < 2) {
                // No comparison available, just reload
                const reload = confirm('Model retraining complete! Reload the page to see the updated model in action?');
                if (reload) {
                    window.location.reload();
                }
                return;
            }
            
            // Get the latest version (first in the list)
            const latestVersion = data.versions[0];
            
            // Get comparison data
            const compareResponse = await fetch(`/api/model/compare/${latestVersion.id}`);
            const compareData = await compareResponse.json();
            
            if (!compareData.success) {
                throw new Error('Failed to get comparison data');
            }
            
            // Show the comparison modal
            displayComparisonModal(compareData.comparison, latestVersion);
            
        } catch (error) {
            console.error('Error showing comparison modal:', error);
            // Fallback to reload prompt
            const reload = confirm('Model retraining complete! Reload the page to see the updated model in action?');
            if (reload) {
                window.location.reload();
            }
        }
    }
    
    function displayComparisonModal(comparison, version) {
        // Clean up existing modal
        const existingModal = document.getElementById('comparisonModal');
        if (existingModal) {
            if (window.ModalManager) {
                const stack = window.ModalManager.getStack();
                while (stack.includes('comparisonModal')) {
                    const index = stack.indexOf('comparisonModal');
                    stack.splice(index, 1);
                }
            }
            existingModal.remove();
        }
        
        // Create modal HTML
        const modalHTML = `
            <div id="comparisonModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div class="bg-white rounded-lg p-6 max-w-4xl max-h-[90vh] overflow-y-auto">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold text-gray-900">ü§ñ Model Performance Comparison</h2>
                        <button onclick="closeComparisonModal()" class="text-gray-500 hover:text-gray-700">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    
                    <div class="mb-6">
                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                            <h3 class="text-lg font-semibold text-blue-900 mb-2">Model Version ${version.version_number}</h3>
                            <p class="text-blue-700">Trained on ${new Date(version.trained_at).toLocaleString()}</p>
                        </div>
                    </div>
                    
                    <!-- Metrics Comparison Table -->
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">Performance Metrics</h3>
                        <div class="overflow-x-auto">
                            <table class="min-w-full bg-white border border-gray-200">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Metric</th>
                                        <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase">Before</th>
                                        <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase">After</th>
                                        <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase">Change</th>
                                    </tr>
                                </thead>
                                <tbody class="divide-y divide-gray-200">
                                    <tr>
                                        <td class="px-4 py-2 font-medium">Accuracy</td>
                                        <td class="px-4 py-2 text-center">${(comparison.old_version.accuracy * 100).toFixed(1)}%</td>
                                        <td class="px-4 py-2 text-center">${(comparison.new_version.accuracy * 100).toFixed(1)}%</td>
                                        <td class="px-4 py-2 text-center ${comparison.improvements.accuracy_change >= 0 ? 'text-emerald-400' : 'text-red-600'}">
                                            ${comparison.improvements.accuracy_change >= 0 ? '+' : ''}${(comparison.improvements.accuracy_change * 100).toFixed(1)}%
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="px-4 py-2 font-medium">Precision (Huntable)</td>
                                        <td class="px-4 py-2 text-center">${(comparison.old_version.precision_huntable * 100).toFixed(1)}%</td>
                                        <td class="px-4 py-2 text-center">${(comparison.new_version.precision_huntable * 100).toFixed(1)}%</td>
                                        <td class="px-4 py-2 text-center ${comparison.improvements.precision_huntable_change >= 0 ? 'text-emerald-400' : 'text-red-600'}">
                                            ${comparison.improvements.precision_huntable_change >= 0 ? '+' : ''}${(comparison.improvements.precision_huntable_change * 100).toFixed(1)}%
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="px-4 py-2 font-medium">Recall (Huntable)</td>
                                        <td class="px-4 py-2 text-center">${(comparison.old_version.recall_huntable * 100).toFixed(1)}%</td>
                                        <td class="px-4 py-2 text-center">${(comparison.new_version.recall_huntable * 100).toFixed(1)}%</td>
                                        <td class="px-4 py-2 text-center ${comparison.improvements.recall_huntable_change >= 0 ? 'text-emerald-400' : 'text-red-600'}">
                                            ${comparison.improvements.recall_huntable_change >= 0 ? '+' : ''}${(comparison.improvements.recall_huntable_change * 100).toFixed(1)}%
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="px-4 py-2 font-medium">Training Data</td>
                                        <td class="px-4 py-2 text-center">${comparison.old_version.training_data_size}</td>
                                        <td class="px-4 py-2 text-center">${comparison.new_version.training_data_size}</td>
                                        <td class="px-4 py-2 text-center text-blue-600">
                                            +${comparison.improvements.training_data_increase}
                                        </td>
                                    </tr>
                                    <tr>
                                        <td class="px-4 py-2 font-medium">Feedback Samples</td>
                                        <td class="px-4 py-2 text-center">${comparison.old_version.feedback_samples_count}</td>
                                        <td class="px-4 py-2 text-center">${comparison.new_version.feedback_samples_count}</td>
                                        <td class="px-4 py-2 text-center text-blue-600">
                                            +${comparison.improvements.feedback_samples_added}
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Summary -->
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">Summary</h3>
                        ${comparison.summary.key_improvements.length > 0 ? `
                            <div class="mb-3">
                                <h4 class="font-medium text-green-700 mb-2">‚úÖ Key Improvements:</h4>
                                <ul class="list-disc list-inside text-emerald-400">
                                    ${comparison.summary.key_improvements.map(improvement => `<li>${improvement}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                        ${comparison.summary.areas_of_concern.length > 0 ? `
                            <div class="mb-3">
                                <h4 class="font-medium text-yellow-700 mb-2">‚ö†Ô∏è Areas of Concern:</h4>
                                <ul class="list-disc list-inside text-amber-400">
                                    ${comparison.summary.areas_of_concern.map(concern => `<li>${concern}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                    
                    <!-- Actions -->
                    <div class="flex justify-end space-x-3">
                        <button onclick="showFeedbackComparison()" class="px-4 py-2 bg-[#4b4e77] text-white rounded hover:bg-[#7C3AED] transition-colors">
                            View Feedback Impact
                        </button>
                        <button onclick="closeComparisonModal()" class="px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400">
                            Close
                        </button>
                        <button onclick="reloadWithNewModel()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
                            Reload Page with New Model
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        // Add modal to page
        document.body.insertAdjacentHTML('beforeend', modalHTML);
        
        // Get modal element
        const comparisonModal = document.getElementById('comparisonModal');
        if (comparisonModal) {
            // Ensure modal is visible
            comparisonModal.classList.remove('hidden');
            
            // Register and open with ModalManager
            if (window.ModalManager) {
                setTimeout(() => {
                    window.ModalManager.register('comparisonModal', {
                        isDynamic: true,
                        hasInput: false
                    });
                    window.ModalManager.open('comparisonModal');
                    comparisonModal.classList.remove('hidden');
                }, 50);
            }
        }
    }
    
    function closeComparisonModal() {
        const modal = document.getElementById('comparisonModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function reloadWithNewModel() {
        closeComparisonModal();
        window.location.reload();
    }
    
    async function showFeedbackComparison() {
        try {
            const response = await fetch('/api/model/feedback-comparison');
            const data = await response.json();
            
            if (!data.success) {
                throw new Error(data.message || 'Failed to get feedback comparison');
            }
            
            displayFeedbackComparisonModal(data);
            
        } catch (error) {
            console.error('Error showing feedback comparison:', error);
            showNotification('Failed to load feedback comparison: ' + error.message, 'error');
        }
    }
    function displayFeedbackComparisonModal(data) {
        // Close the current modal
        closeComparisonModal();
        
        // Filter to current article by default
        const currentArticleId = window.chunkDebugData?.article_id;
        const filteredData = {
            ...data,
            feedback_comparisons: data.feedback_comparisons.filter(c => c.article_id == currentArticleId)
        };
        
        // Create feedback comparison modal
        const modalHTML = `
            <div id="feedbackComparisonModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div class="bg-white rounded-lg p-6 max-w-6xl max-h-[90vh] overflow-y-auto">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold text-gray-900">üìä Feedback Impact Analysis</h2>
                        <button onclick="closeFeedbackComparisonModal()" class="text-gray-500 hover:text-gray-700">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    
                    <div class="mb-6">
                        <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                            <h3 class="text-lg font-semibold text-green-900 mb-2">Model Version ${filteredData.model_version} vs ${filteredData.previous_model_version}</h3>
                            <p class="text-green-700">Showing confidence changes for ${filteredData.feedback_comparisons.length} chunks from the latest retraining</p>
                            <div class="mt-2 text-sm text-emerald-400">
                                <strong>Comparison Period:</strong> ${filteredData.comparison_period}
                            </div>
                            <div class="mt-1 text-sm text-emerald-400">
                                <strong>Current Article (${currentArticleId || 'N/A'}):</strong> 
                                ${filteredData.feedback_comparisons.length} chunks
                            </div>
                        </div>
                    </div>
                    
                    
                    <!-- Feedback Comparison Table -->
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">Confidence Changes for Your Feedback</h3>
                        <div class="overflow-x-auto">
                            <table class="min-w-full bg-white border border-gray-200">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Chunk Text</th>
                                        <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase">Old Huntable Confidence</th>
                                        <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase">New Huntable Confidence</th>
                                        <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase">Change</th>
                                        <th class="px-4 py-2 text-center text-xs font-medium text-gray-500 uppercase">Your Feedback</th>
                                    </tr>
                                </thead>
                                <tbody class="divide-y divide-gray-200">
                                    ${filteredData.feedback_comparisons.map(comparison => `
                                        <tr>
                                            <td class="px-4 py-2 text-sm" data-article-id="${comparison.article_id}">
                                                <div class="max-w-xs truncate" title="${comparison.chunk_text}">
                                                    ${comparison.chunk_text}
                                                </div>
                                            </td>
                                            <td class="px-4 py-2 text-center">
                                                <span class="text-sm">${(comparison.old_huntable_probability * 100).toFixed(1)}%</span>
                                                <div class="text-xs text-gray-500">${comparison.old_classification}</div>
                                            </td>
                                            <td class="px-4 py-2 text-center">
                                                <span class="text-sm font-medium">${(comparison.new_huntable_probability * 100).toFixed(1)}%</span>
                                                <div class="text-xs text-gray-500">${comparison.new_classification}</div>
                                            </td>
                                            <td class="px-4 py-2 text-center">
                                                <span class="text-sm font-bold ${comparison.huntable_probability_change >= 0 ? 'text-emerald-400' : 'text-red-600'}">
                                                    ${comparison.huntable_probability_change >= 0 ? '+' : ''}${(comparison.huntable_probability_change * 100).toFixed(1)}%
                                                </span>
                                            </td>
                                            <td class="px-4 py-2 text-center">
                                                <span class="text-xs px-2 py-1 rounded ${comparison.is_correct ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">
                                                    ${comparison.is_correct ? '‚úÖ Correct' : '‚ùå Incorrect'}
                                                </span>
                                                <div class="text-xs text-gray-500 mt-1">${comparison.user_classification}</div>
                                            </td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Summary Statistics -->
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">Summary</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                <div class="text-sm text-blue-600">Average Huntable Confidence Change</div>
                                <div class="text-lg font-semibold text-blue-900">
                                    ${(filteredData.feedback_comparisons.reduce((sum, c) => sum + c.huntable_probability_change, 0) / filteredData.feedback_comparisons.length * 100).toFixed(1)}%
                                </div>
                            </div>
                            <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                                <div class="text-sm text-emerald-400">Chunks with Improved Huntable Confidence</div>
                                <div class="text-lg font-semibold text-green-900">
                                    ${filteredData.feedback_comparisons.filter(c => c.huntable_probability_change > 0).length}
                                </div>
                            </div>
                            <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                                <div class="text-sm text-red-600">Chunks with Decreased Huntable Confidence</div>
                                <div class="text-lg font-semibold text-red-900">
                                    ${filteredData.feedback_comparisons.filter(c => c.huntable_probability_change < 0).length}
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Actions -->
                    <div class="flex justify-end space-x-3">
                        <button onclick="closeFeedbackComparisonModal()" class="px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400">
                            Close
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        // Add modal to page
        document.body.insertAdjacentHTML('beforeend', modalHTML);
        
        // Close modal when clicking outside
        const feedbackComparisonModal = document.getElementById('feedbackComparisonModal');
        if (feedbackComparisonModal) {
            feedbackComparisonModal.addEventListener('click', function(e) {
                if (e.target === feedbackComparisonModal) {
                    closeFeedbackComparisonModal();
                }
            });
        }
        
        // Add ESC key handler to close feedback comparison modal
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('feedbackComparisonModal');
                if (modal) {
                    closeFeedbackComparisonModal();
                    document.removeEventListener('keydown', handleEsc);
                }
            }
        };
        document.addEventListener('keydown', handleEsc);
    }
    
    function closeFeedbackComparisonModal() {
        const modal = document.getElementById('feedbackComparisonModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function filterFeedbackTable() {
        const checkbox = document.getElementById('filterCurrentArticle');
        const table = document.querySelector('#feedbackComparisonModal table tbody');
        const currentArticleId = window.chunkDebugData?.article_id;
        
        if (!table || !currentArticleId) return;
        
        const rows = table.querySelectorAll('tr');
        
        rows.forEach(row => {
            const articleIdCell = row.querySelector('td[data-article-id]');
            if (articleIdCell) {
                const rowArticleId = parseInt(articleIdCell.getAttribute('data-article-id'));
                if (checkbox.checked) {
                    // Show only current article
                    row.style.display = rowArticleId === currentArticleId ? '' : 'none';
                } else {
                    // Show all articles
                    row.style.display = '';
                }
            }
        });
    }


    // Toggle Keyword Matches panel
    // toggleKeywordMatches - handled by global initCollapsiblePanels() in base.html
    function toggleKeywordMatches() {
        toggleCollapsible('keyword-matches');
    }
</script>
{% endblock %}
