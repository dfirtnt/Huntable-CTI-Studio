{% extends "base.html" %}

{% block title %}{{ article.title[:50] }}... - CTI Scraper{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <!-- Breadcrumb -->
    <nav class="flex mb-8" aria-label="Breadcrumb">
        <ol class="inline-flex items-center space-x-1 md:space-x-3">
            <li class="inline-flex items-center">
                <a href="/" class="inline-flex items-center text-sm font-medium text-gray-700 dark:text-gray-300 hover:text-blue-600 dark:hover:text-blue-400">
                    <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"></path>
                    </svg>
                    Dashboard
                </a>
            </li>
            <li>
                <div class="flex items-center">
                    <svg class="w-6 h-6 text-gray-400 dark:text-gray-500" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path>
                    </svg>
                    <a href="/articles" class="ml-1 text-sm font-medium text-gray-700 dark:text-gray-300 hover:text-blue-600 dark:hover:text-blue-400 md:ml-2">Articles</a>
                </div>
            </li>
            <li aria-current="page">
                <div class="flex items-center">
                    <svg class="w-6 h-6 text-gray-400 dark:text-gray-500" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path>
                    </svg>
                    <span class="ml-1 text-sm font-medium text-gray-500 dark:text-gray-400 md:ml-2">Article #{{ article.id }}</span>
                </div>
            </li>
        </ol>
    </nav>

    <!-- Article Header -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <div class="flex items-start justify-between">
            <div class="flex-1">
                <h1 class="text-3xl font-bold text-gray-900 dark:text-white mb-6 leading-tight">{{ article.title }}</h1>
                
                <div class="flex items-center space-x-6 text-sm text-gray-600 dark:text-gray-400 mb-6">
                    <div class="flex items-center">
                        <span class="mr-2">üì∞</span>
                        <span>Source: 
                            {% if article.canonical_url %}
                                <a href="{{ article.canonical_url }}" target="_blank" class="text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 hover:underline">
                                    {{ source.name if source else article.source_id }}
                                </a>
                            {% else %}
                                {{ source.name if source else article.source_id }}
                            {% endif %}
                        </span>
                    </div>
                    {% if article.published_at %}
                    <div class="flex items-center">
                        <span class="mr-2">üìÖ</span>
                        <span>{{ article.published_at.strftime('%Y-%m-%d %H:%M:%S') }}</span>
                    </div>
                    {% endif %}
                    <div class="flex items-center">
                        <span class="mr-2">üìä</span>
                        <span>{{ article.content|length }} characters</span>
                    </div>
                    <div class="flex items-center">
                        <span class="mr-2">üÜî</span>
                        <span>#{{ article.id }}</span>
                    </div>
                    {% if article.article_metadata and article.article_metadata.get('threat_hunting_score') is not none %}
                    <div class="flex items-center">
                        <span class="mr-2">üéØ</span>
                        <span>Threat Hunting Score: 
                            {% set score = article.article_metadata.get('threat_hunting_score', 0) %}
                            {% if score >= 80 %}
                                <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 border border-green-200 dark:border-green-700">
                                    üéØ {{ "%.1f"|format(score) }}
                                </span>
                            {% elif score >= 60 %}
                                <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 border border-yellow-200 dark:border-yellow-700">
                                    üü° {{ "%.1f"|format(score) }}
                                </span>
                            {% elif score >= 40 %}
                                <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-orange-100 dark:bg-orange-900 text-orange-800 dark:text-orange-200 border border-orange-200 dark:border-orange-700">
                                    üü† {{ "%.1f"|format(score) }}
                                </span>
                            {% else %}
                                <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-bold bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 border border-red-200 dark:border-red-700">
                                    üî¥ {{ "%.1f"|format(score) }}
                                </span>
                            {% endif %}
                        </span>
                    </div>
                    {% endif %}
                </div>

                {% if article.canonical_url %}
                <div class="mb-4">
                    <a href="{{ article.canonical_url }}" target="_blank" 
                       class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 transition-colors">
                        <span class="mr-2">üîó</span>
                        View Original Source
                    </a>
                </div>
                {% endif %}
                
                <!-- Delete Article Button -->
                <div class="mb-4">
                    <button onclick="deleteArticle({{ article.id }})" 
                            class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700 transition-colors">
                        <span class="mr-2">üóëÔ∏è</span>
                        Delete Article
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Keyword Matches Display -->
    {% if article.article_metadata %}
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <h2 class="text-xl font-bold text-gray-900 dark:text-white mb-6">üéØ Keyword Matches</h2>
        
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
            <!-- Perfect Discriminators -->
            <div class="card bg-green-100 dark:bg-green-800 border border-green-300 dark:border-green-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-green-800 dark:text-green-200 flex items-center">
                        <span class="mr-2">‚úÖ</span>
                        Perfect Discriminators
                    </h3>
                    <span class="text-xs font-bold text-white bg-green-600 dark:bg-green-600 px-2 py-1 rounded-full">
                        75 pts
                    </span>
                </div>
                <div class="flex flex-wrap gap-1">
                    {% for keyword in article.article_metadata.get('perfect_keyword_matches', []) %}
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200 border border-green-200 dark:border-green-600">
                        {{ keyword }}
                    </span>
                    {% endfor %}
                    {% if not article.article_metadata.get('perfect_keyword_matches') %}
                    <span class="text-xs text-gray-500 dark:text-gray-400 italic">No matches</span>
                    {% endif %}
                </div>
            </div>
            
            <!-- Good Discriminators -->
            <div class="card bg-purple-100 dark:bg-purple-800 border border-purple-300 dark:border-purple-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-purple-800 dark:text-purple-200 flex items-center">
                        <span class="mr-2">üü£</span>
                        Good Discriminators
                    </h3>
                    <span class="text-xs font-bold text-white bg-purple-600 dark:bg-purple-600 px-2 py-1 rounded-full">
                        5 pts
                    </span>
                </div>
                <div class="flex flex-wrap gap-1">
                    {% for keyword in article.article_metadata.get('good_keyword_matches', []) %}
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-purple-100 dark:bg-purple-800 text-purple-800 dark:text-purple-200 border border-purple-200 dark:border-purple-600">
                        {{ keyword }}
                    </span>
                    {% endfor %}
                    {% if not article.article_metadata.get('good_keyword_matches') %}
                    <span class="text-xs text-gray-500 dark:text-gray-400 italic">No matches</span>
                    {% endif %}
                </div>
            </div>
            
            <!-- LOLBAS Executables -->
            <div class="card bg-blue-100 dark:bg-blue-800 border border-blue-300 dark:border-blue-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-blue-800 dark:text-blue-200 flex items-center">
                        <span class="mr-2">üîß</span>
                        LOLBAS Executables
                    </h3>
                    <span class="text-xs font-bold text-white bg-blue-600 dark:bg-blue-600 px-2 py-1 rounded-full">
                        10 pts
                    </span>
                </div>
                <div class="flex flex-wrap gap-1">
                    {% for keyword in article.article_metadata.get('lolbas_matches', []) %}
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-blue-100 dark:bg-blue-800 text-blue-800 dark:text-blue-200 border border-blue-200 dark:border-blue-600">
                        {{ keyword }}
                    </span>
                    {% endfor %}
                    {% if not article.article_metadata.get('lolbas_matches') %}
                    <span class="text-xs text-gray-500 dark:text-gray-400 italic">No matches</span>
                    {% endif %}
                </div>
            </div>
            
            <!-- Intelligence Indicators -->
            <div class="card bg-red-100 dark:bg-red-800 border border-red-300 dark:border-red-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-red-800 dark:text-red-200 flex items-center">
                        <span class="mr-2">üéØ</span>
                        Intelligence Indicators
                    </h3>
                    <span class="text-xs font-bold text-white bg-red-600 dark:bg-red-600 px-2 py-1 rounded-full">
                        10 pts
                    </span>
                </div>
                <div class="flex flex-wrap gap-1">
                    {% for keyword in article.article_metadata.get('intelligence_matches', []) %}
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-red-100 dark:bg-red-800 text-red-800 dark:text-red-200 border border-red-200 dark:border-red-600">
                        {{ keyword }}
                    </span>
                    {% endfor %}
                    {% if not article.article_metadata.get('intelligence_matches') %}
                    <span class="text-xs text-gray-500 dark:text-gray-400 italic">No matches</span>
                    {% endif %}
                </div>
            </div>
            
            <!-- Negative Indicators -->
            <div class="card bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-semibold text-gray-800 dark:text-gray-200 flex items-center">
                        <span class="mr-2">‚ö†Ô∏è</span>
                        Negative Indicators
                    </h3>
                    <span class="text-xs font-bold text-white bg-gray-600 dark:bg-gray-600 px-2 py-1 rounded-full">
                        -10 pts
                    </span>
                </div>
                <div class="flex flex-wrap gap-1">
                    {% for keyword in article.article_metadata.get('negative_matches', []) %}
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-gray-100 dark:bg-gray-800 text-gray-800 dark:text-gray-200 border border-gray-200 dark:border-gray-600">
                        {{ keyword }}
                    </span>
                    {% endfor %}
                    {% if not article.article_metadata.get('negative_matches') %}
                    <span class="text-xs text-gray-500 dark:text-gray-400 italic">No matches</span>
                    {% endif %}
                </div>
            </div>
            
        </div>
        
    </div>
    {% endif %}

    <!-- Classification Controls -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <h2 class="text-xl font-bold text-gray-900 dark:text-white mb-6">üè∑Ô∏è Article Classification</h2>
        
        <!-- Settings Status -->
        <!-- Current Classification Status -->
        <div class="mb-6">
            {% if article.article_metadata and article.article_metadata.get('training_category') %}
                <div class="flex items-center space-x-2">
                    <span class="text-sm font-medium text-gray-700">Current Status:</span>
                    <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium
                        {% if article.article_metadata.get('training_category') == 'chosen' %}bg-green-100 text-green-800
                        {% elif article.article_metadata.get('training_category') == 'rejected' %}bg-red-100 text-red-800
                        {% else %}bg-gray-100 text-gray-800{% endif %}">
                        {% if article.article_metadata.get('training_category') == 'chosen' %}‚úÖ Chosen
                        {% elif article.article_metadata.get('training_category') == 'rejected' %}‚ùå Rejected
                        {% else %}‚è≥ Unclassified{% endif %}
                    </span>
                    {% if article.article_metadata.get('training_categorized_at') %}
                        <span class="text-sm text-gray-500">({{ article.article_metadata.get('training_categorized_at')[:19] }})</span>
                    {% endif %}
                </div>
            {% else %}
                <div class="flex items-center space-x-2">
                    <span class="text-sm font-medium text-gray-700">Current Status:</span>
                    <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-100 text-gray-800">
                        ‚è≥ Unclassified
                    </span>
                </div>
            {% endif %}
        </div>
        
        
        <!-- Classification Buttons -->
        <div class="flex flex-wrap gap-4 mb-6">
            <button onclick="classifyArticle('chosen')" 
                    class="inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors">
                <span class="mr-2">‚úÖ</span>
                Mark as Chosen
            </button>
            
            <button onclick="classifyArticle('rejected')" 
                    class="inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors">
                <span class="mr-2">‚ùå</span>
                Mark as Rejected
            </button>
            
            <button onclick="classifyArticle('unclassified')" 
                    class="inline-flex items-center px-6 py-3 border border-gray-300 text-base font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                <span class="mr-2">‚è≥</span>
                Mark as Unclassified
            </button>
            
            <!-- AI Assistant Button with Popover -->
            <div class="relative inline-block" id="aiAssistantWrapper">
                <button id="aiAssistantBtn" onclick="showAIAssistant()" 
                        class="inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-purple-600 hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                    <span class="mr-2">ü§ñ</span>
                    AI Assistant
                </button>
                <!-- Popover explanation -->
                <div id="aiAssistantPopover" class="absolute z-10 top-full left-0 mt-2 hidden w-64">
                    <div class="text-sm text-amber-700 bg-amber-50 border border-amber-200 rounded-md p-3 shadow-lg">
                        <div class="flex items-start">
                            <span class="mr-2 mt-0.5">‚ö†Ô∏è</span>
                            <div>
                                <div class="font-medium">Article too large for AI processing</div>
                                <div class="text-xs text-amber-600 mt-1" id="popoverContent">
                                    Loading...
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Navigation Buttons -->
        <div class="flex flex-wrap gap-4">
            <button onclick="navigateToNextUnclassified()" 
                    class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                <span class="mr-2">‚è≠Ô∏è</span>
                Next Unclassified
            </button>
            
            <button onclick="navigateToPrevious()" 
                    class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                <span class="mr-2">‚èÆÔ∏è</span>
                Previous Article
            </button>
            
            <button onclick="navigateToNext()" 
                    class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                <span class="mr-2">‚è≠Ô∏è</span>
                Next Article
            </button>
        </div>
    </div>
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <h2 class="text-xl font-bold text-gray-900 dark:text-white mb-6">üìÑ Article Content</h2>
        
        <div class="bg-gray-100 dark:bg-gray-900 rounded-lg p-6">
            <div class="flex items-center justify-between mb-6">
                <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200">Article Content</h3>
                <div class="flex items-center space-x-4">
                    <div class="flex items-center space-x-2">
                        <span class="text-sm text-gray-600 dark:text-gray-400">Select text to annotate</span>
                        <div class="flex items-center space-x-1">
                            <span class="w-3 h-3 bg-green-100 dark:bg-green-900 border border-green-300 dark:border-green-700 rounded"></span>
                            <span class="text-xs text-gray-600 dark:text-gray-400">Huntable</span>
                        </div>
                        <div class="flex items-center space-x-1">
                            <span class="w-3 h-3 bg-red-100 dark:bg-red-900 border border-red-300 dark:border-red-700 rounded"></span>
                            <span class="text-xs text-gray-600 dark:text-gray-400">Not Huntable</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="prose max-w-none">
                <div id="article-content" class="whitespace-pre-wrap text-base text-black font-mono leading-relaxed select-text bg-gray-50 dark:bg-gray-950 p-6 rounded-lg border-2 border-gray-300 dark:border-gray-600 shadow-inner">{{ article.content|highlight_keywords(article.article_metadata)|safe }}</div>
            </div>
        </div>
    </div>

    <!-- Article Metadata -->
    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <h2 class="text-xl font-bold text-gray-900 dark:text-white mb-6">üìã Article Metadata</h2>
        
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
                <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4">Basic Information</h3>
                <dl class="space-y-3">
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Article ID</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">#{{ article.id }}</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Source ID</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.source_id }}</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Published At</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.published_at.strftime('%Y-%m-%d %H:%M:%S') if article.published_at else 'N/A' }}</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Discovered At</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.discovered_at.strftime('%Y-%m-%d %H:%M:%S') if article.discovered_at else 'N/A' }}</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Processing Status</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.processing_status }}</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Word Count</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.word_count or 'N/A' }}</dd>
                    </div>
                </dl>
            </div>
            
            <div>
                <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4">Content Details</h3>
                <dl class="space-y-3">
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Content Length</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">{{ article.content|length }} characters</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Content Hash</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100 font-mono">{{ article.content_hash[:20] }}...</dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Authors</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">
                            {% if article.authors %}
                                {{ article.authors|join(', ') }}
                            {% else %}
                                N/A
                            {% endif %}
                        </dd>
                    </div>
                    <div>
                        <dt class="text-sm font-medium text-gray-600 dark:text-gray-400">Tags</dt>
                        <dd class="text-sm text-gray-900 dark:text-gray-100">
                            {% if article.tags %}
                                {{ article.tags|join(', ') }}
                            {% else %}
                                N/A
                            {% endif %}
                        </dd>
                    </div>
                </dl>
            </div>
        </div>
        
        {% if article.article_metadata %}
        <div class="mt-6">
            <h3 class="text-lg font-semibold text-gray-800 mb-2">Additional Metadata</h3>
            <pre class="bg-gray-50 p-4 rounded-lg text-sm text-gray-700 overflow-x-auto">{{ article.article_metadata|tojson(indent=2) }}</pre>
        </div>
        {% endif %}
    </div>

    <!-- Navigation -->
    <div class="flex items-center justify-between">
        <a href="/articles" class="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 transition-colors">
            <span class="mr-2">‚Üê</span>
            Back to Articles
        </a>
        
        <div class="flex space-x-2">
            <button onclick="navigateToPrevious()" 
                    class="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 transition-colors">
                Previous Article
            </button>
            
            <button onclick="navigateToNext()" 
                    class="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 transition-colors">
                Next Article
                <span class="ml-2">‚Üí</span>
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>

    // Add syntax highlighting for matched text
    document.addEventListener('DOMContentLoaded', function() {
        
        // Syntax highlighting for matched text
        const matchedTexts = document.querySelectorAll('.font-mono');
        matchedTexts.forEach(element => {
            element.style.backgroundColor = '#fef3c7';
            element.style.border = '1px solid #f59e0b';
        });
        
        // Initialize current article classification in localStorage
        const currentClassification = '{{ article.article_metadata.get("training_category", "") }}';
        localStorage.setItem('currentArticleClassification', currentClassification);
        
        // Load existing annotations
    });
    
    // Simple Text Management System - Single Source of Truth
    class SimpleTextManager {
        constructor() {
            this.contentElement = document.getElementById('article-content');
            this.userClassifications = new Map();
            this.previousStates = []; // Store previous HTML states for undo
            this.maxUndoStates = 10;
            this.isSubmitting = false; // Prevent duplicate submissions
            
            this.init();
        }
        
        init() {
            // Load existing user classifications
            this.loadExistingClassifications();
            
            // Enable user text selection
            this.enableUserSelection();
            
            // Enable keyboard shortcuts
            this.enableKeyboardShortcuts();
            
            // Enable clicking on annotations to remove them
            this.enableAnnotationClicking();
        }
        
        
        async loadExistingClassifications() {
            try {
                // Loading existing classifications for article {{ article.id }}
                const response = await fetch(`/api/articles/{{ article.id }}/annotations`);
                const data = await response.json();
                
                // API response received
                
                if (data.success && data.annotations) {
                    // Found ${data.annotations.length} existing annotations
                    
                    // Wait a bit for the page to fully load before adding annotations
                    setTimeout(() => {
                        data.annotations.forEach(annotation => {
                            // Loading annotation: ${annotation.annotation_type}
                            this.addExistingClassification(
                                annotation.start_position,
                                annotation.end_position,
                                annotation.annotation_type,
                                annotation.selected_text
                            );
                        });
                    }, 100);
                } else {
                    // No existing annotations found
                }
            } catch (error) {
                console.error('Failed to load existing classifications:', error);
            }
        }
        
        addExistingClassification(start, end, classification, text) {
            // Checking existing annotation: ${classification}
            
            // Check if this text is already highlighted by looking for spans with our classes
            const cssClass = classification === 'huntable' 
                ? 'bg-blue-100 dark:bg-blue-900' 
                : 'bg-red-100 dark:bg-red-900';
            
            // Look for existing spans with our annotation classes
            const existingSpans = this.contentElement.querySelectorAll(`span.${cssClass}`);
            let alreadyHighlighted = false;
            
            for (const span of existingSpans) {
                // Check if this span contains our text (or vice versa for partial matches)
                const spanText = span.textContent.trim();
                const searchText = text.trim();
                
                // More precise matching - check if the span text matches our annotation text
                if (spanText === searchText || spanText.includes(searchText)) {
                    alreadyHighlighted = true;
                    console.log(`Text already highlighted in span: "${spanText.substring(0, 50)}..."`);
                    break;
                }
            }
            
            if (!alreadyHighlighted) {
                console.log('Text not yet highlighted, adding annotation');
                this.addUserClassification(start, end, classification, text);
            } else {
                console.log('Skipping duplicate annotation');
            }
        }
        
        addUserClassification(start, end, classification, text) {
            console.log(`Attempting to add ${classification} classification for: "${text.substring(0, 100)}..."`);
            console.log(`Text length: ${text.length}, Start: ${start}, End: ${end}`);
            
            // For very long text selections, try to highlight more of it
            if (text.length > 2000) {
                console.log('Very long text selection detected, using position-based approach');
                this.addLongTextClassification(start, end, classification, text);
                return;
            }
            
            // Get the current HTML content
            const content = this.contentElement.innerHTML;
            
            // Create the highlight span
            const cssClass = classification === 'huntable' 
                ? 'bg-blue-100 dark:bg-blue-900 border-blue-300 dark:border-blue-700 text-blue-800 dark:text-blue-200' 
                : 'bg-red-100 dark:bg-red-900 border-red-300 dark:border-red-700 text-red-800 dark:text-red-200';
            
            const highlightSpan = `<span class="px-1 py-0.5 rounded text-xs font-medium border ${cssClass}" title="${classification === 'huntable' ? 'Huntable' : 'Not Huntable'}: ${text.substring(0, 50)}...">${text}</span>`;
            
            // Debug: Log what we're looking for vs what's in the content
            // console.log('=== TEXT REPLACEMENT DEBUG ===');
            console.log('Looking for text:', JSON.stringify(text));
            console.log('Text length:', text.length);
            console.log('Content preview:', content.substring(0, 500));
            
            // Use a more reliable approach - replace only the first occurrence
            let newContent = content;
            let replaced = false;
            
            // Approach 1: Exact match using indexOf (most reliable)
            const index = content.indexOf(text);
            console.log('Exact match index:', index);
            
            if (index !== -1) {
                // Verify this is actually the text we want to replace
                const beforeText = content.substring(Math.max(0, index - 20), index);
                const afterText = content.substring(index + text.length, index + text.length + 20);
                console.log('Context before:', beforeText);
                console.log('Context after:', afterText);
                
                newContent = content.substring(0, index) + highlightSpan + content.substring(index + text.length);
                console.log('Found exact text match, replaced');
                replaced = true;
            } else {
                console.log('Exact match failed, trying different approaches...');
                
                // Approach 2: Try with HTML entities decoded
                const decodedText = text.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'");
                const decodedIndex = content.indexOf(decodedText);
                console.log('Decoded text match index:', decodedIndex);
                
                if (decodedIndex !== -1) {
                    newContent = content.substring(0, decodedIndex) + highlightSpan + content.substring(decodedIndex + decodedText.length);
                    console.log('Found decoded text match, replaced');
                    replaced = true;
                } else {
                    // Approach 3: Try with a longer substring (up to 500 chars)
                    const longerText = text.substring(0, Math.min(500, text.length));
                    const longerIndex = content.indexOf(longerText);
                    console.log('Longer text match index:', longerIndex);
                    
                    if (longerIndex !== -1) {
                        newContent = content.substring(0, longerIndex) + highlightSpan + content.substring(longerIndex + longerText.length);
                        console.log('Found longer text match, replaced');
                        replaced = true;
                    } else {
                        // Approach 4: Try with a shorter substring as last resort
                        const shortText = text.substring(0, Math.min(100, text.length));
                        const shortIndex = content.indexOf(shortText);
                        console.log('Short text match index:', shortIndex);
                        
                        if (shortIndex !== -1) {
                            newContent = content.substring(0, shortIndex) + highlightSpan + content.substring(shortIndex + shortText.length);
                            console.log('Found short text match, replaced');
                            replaced = true;
                        } else {
                            console.log('Could not find text to replace, trying position-based approach');
                            // Try position-based highlighting as fallback
                            this.highlightTextAtPosition(start, end, classification, text);
                            return;
                        }
                    }
                }
            }
            
            // console.log('=== END DEBUG ===');
            
            // Save state before making changes
            this.saveState();
            
            // Update the content
            this.contentElement.innerHTML = newContent;
            console.log(`Successfully added ${classification} classification`);
        }
        
        highlightTextAtPosition(start, end, classification, text) {
            console.log('Using position-based highlighting:', { start, end, textLength: text.length });
            
            // Create a range to select the text at the exact position
            const range = document.createRange();
            const walker = document.createTreeWalker(
                this.contentElement,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let currentPos = 0;
            let startNode = null;
            let startOffset = 0;
            let endNode = null;
            let endOffset = 0;
            
            // Find the text nodes that contain our selection
            let node;
            while (node = walker.nextNode()) {
                const nodeLength = node.textContent.length;
                
                if (!startNode && currentPos + nodeLength >= start) {
                    startNode = node;
                    startOffset = start - currentPos;
                }
                
                if (!endNode && currentPos + nodeLength >= end) {
                    endNode = node;
                    endOffset = end - currentPos;
                    break;
                }
                
                currentPos += nodeLength;
            }
            
            if (startNode && endNode) {
                try {
                    range.setStart(startNode, startOffset);
                    range.setEnd(endNode, endOffset);
                    
                    // Create highlight span
                    const cssClass = classification === 'huntable' 
                        ? 'bg-blue-100 dark:bg-blue-900 border-blue-300 dark:border-blue-700 text-blue-800 dark:text-blue-200' 
                        : 'bg-red-100 dark:bg-red-900 border-red-300 dark:border-red-700 text-red-800 dark:text-red-200';
                    
                    const highlightSpan = document.createElement('span');
                    highlightSpan.className = `px-1 py-0.5 rounded text-xs font-medium border ${cssClass}`;
                    highlightSpan.title = `${classification === 'huntable' ? 'Huntable' : 'Not Huntable'}: ${text.substring(0, 50)}...`;
                    highlightSpan.textContent = text;
                    
                    // Replace the range content with our highlight span
                    range.deleteContents();
                    range.insertNode(highlightSpan);
                    
                    console.log('Position-based highlighting successful');
                    
                    // Save state for undo
                    this.saveState();
                    
                } catch (error) {
                    console.error('Error in position-based highlighting:', error);
                    // Fallback: just add a visual indicator
                    this.addVisualIndicator(start, end, classification, text);
                }
            } else {
                console.error('Could not find text nodes for position-based highlighting');
                this.addVisualIndicator(start, end, classification, text);
            }
        }
        
        addVisualIndicator(start, end, classification, text) {
            console.log('Adding visual indicator as last resort');
            
            // Create a simple visual indicator at the top of the content
            const indicator = document.createElement('div');
            indicator.className = `p-2 mb-2 rounded border-l-4 ${classification === 'huntable' ? 'bg-blue-50 border-blue-400' : 'bg-red-50 border-red-400'}`;
            indicator.innerHTML = `
                <div class="text-sm font-medium ${classification === 'huntable' ? 'text-blue-800' : 'text-red-800'}">
                    ${classification === 'huntable' ? '‚úì Huntable' : '‚úó Not Huntable'} Text Annotated
                </div>
                <div class="text-xs text-gray-600 mt-1">
                    "${text.substring(0, 100)}${text.length > 100 ? '...' : ''}"
                </div>
            `;
            
            // Insert at the beginning of the content
            this.contentElement.insertBefore(indicator, this.contentElement.firstChild);
            
            // Save state for undo
            this.saveState();
        }
        
        addLongTextClassification(start, end, classification, text) {
            // For very long text, try to highlight multiple parts of it
            const cssClass = classification === 'huntable' 
                ? 'bg-blue-100 dark:bg-blue-900 border-blue-300 dark:border-blue-700 text-blue-800 dark:text-blue-200' 
                : 'bg-red-100 dark:bg-red-900 border-red-300 dark:border-red-700 text-red-800 dark:text-red-200';
            
            // Get the current HTML content
            const content = this.contentElement.innerHTML;
            
            // Try to highlight the first 500 characters and add an indicator
            const shortText = text.substring(0, Math.min(500, text.length));
            const highlightSpan = `<span class="px-1 py-0.5 rounded text-xs font-medium border ${cssClass}" title="${classification === 'huntable' ? 'Huntable' : 'Not Huntable'}: Long selection (${text.length} chars)">${shortText}${text.length > 500 ? '...' : ''}</span>`;
            
            // Try to find and replace the text
            if (content.includes(shortText)) {
                let newContent = content.replace(shortText, highlightSpan);
                
                // Also try to highlight the end of the selection if it's very long
                if (text.length > 1000) {
                    const endText = text.substring(text.length - 100);
                    const endHighlightSpan = `<span class="px-1 py-0.5 rounded text-xs font-medium border ${cssClass}" title="End of long ${classification} selection">...${endText}</span>`;
                    
                    if (newContent.includes(endText) && !newContent.includes(endHighlightSpan)) {
                        newContent = newContent.replace(endText, endHighlightSpan);
                    }
                }
                
                this.contentElement.innerHTML = newContent;
                console.log(`Added ${classification} highlight for long text selection (${text.length} chars)`);
            } else {
                // Fallback to shorter text
                const veryShortText = text.substring(0, Math.min(100, text.length));
                if (content.includes(veryShortText)) {
                    const shortHighlightSpan = `<span class="px-1 py-0.5 rounded text-xs font-medium border ${cssClass}" title="${classification === 'huntable' ? 'Huntable' : 'Not Huntable'}: Long selection (${text.length} chars)">${veryShortText}...</span>`;
                    const newContent = content.replace(veryShortText, shortHighlightSpan);
                    this.contentElement.innerHTML = newContent;
                    console.log(`Added ${classification} highlight for part of long text selection`);
                } else {
                    console.log(`Could not find text for long selection highlighting`);
                }
            }
        }
        
        saveState() {
            // Save current HTML state for undo functionality
            this.previousStates.push(this.contentElement.innerHTML);
            
            // Keep only the last maxUndoStates
            if (this.previousStates.length > this.maxUndoStates) {
                this.previousStates.shift();
            }
        }
        
        async undo() {
            if (this.previousStates.length > 0) {
                const previousState = this.previousStates.pop();
                this.contentElement.innerHTML = previousState;
                
                // Delete the last annotation from database
                try {
                    const response = await fetch(`/api/articles/{{ article.id }}/annotations`, {
                        method: 'GET'
                    });
                    const data = await response.json();
                    
                    if (data.success && data.annotations.length > 0) {
                        // Get the most recent annotation (highest ID)
                        const lastAnnotation = data.annotations.reduce((prev, current) => 
                            (prev.id > current.id) ? prev : current
                        );
                        
                        // Delete it from database
                        const deleteResponse = await fetch(`/api/articles/{{ article.id }}/annotations/${lastAnnotation.id}`, {
                            method: 'DELETE'
                        });
                        
                        if (deleteResponse.ok) {
                            console.log(`Undid last classification and removed annotation ID ${lastAnnotation.id} from database`);
                        } else {
                            console.error('Failed to remove annotation from database');
                        }
                    }
                } catch (error) {
                    console.error('Error removing annotation from database:', error);
                }
                
                console.log('Undid last classification');
                return true;
            } else {
                console.log('No previous states to undo');
                return false;
            }
        }
        
        
        enableKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ctrl+Z for undo
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    this.undo();
                }
            });
        }
        
        enableAnnotationClicking() {
            // Use event delegation to handle clicks on annotation spans
            this.contentElement.addEventListener('click', (e) => {
                // Check if clicked element is an annotation span
                const clickedSpan = e.target.closest('span.px-1.py-0\\.5.rounded.text-xs.font-medium.border');
                
                if (clickedSpan) {
                    // Check if it's a user annotation (not a keyword discriminator)
                    const isHuntableAnnotation = clickedSpan.classList.contains('bg-blue-100') || clickedSpan.classList.contains('dark:bg-blue-900');
                    const isNotHuntableAnnotation = clickedSpan.classList.contains('bg-red-100') || clickedSpan.classList.contains('dark:bg-red-900');
                    
                    if (isHuntableAnnotation || isNotHuntableAnnotation) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const annotationType = isHuntableAnnotation ? 'huntable' : 'not_huntable';
                        const annotationText = clickedSpan.textContent;
                        
                        this.showRemoveAnnotationModal(clickedSpan, annotationType, annotationText);
                    }
                }
            });
        }
        
        enableUserSelection() {
            let isSelecting = false;
            let startPos = null;
            let endPos = null;
            
            this.contentElement.addEventListener('mousedown', (e) => {
                isSelecting = true;
                startPos = this.getTextPositionFromEvent(e);
            });
            
            this.contentElement.addEventListener('mousemove', (e) => {
                if (isSelecting) {
                    endPos = this.getTextPositionFromEvent(e);
                    this.showSelectionPreview(startPos, endPos);
                }
            });
            
            this.contentElement.addEventListener('mouseup', (e) => {
                if (isSelecting) {
                    isSelecting = false;
                    endPos = this.getTextPositionFromEvent(e);
                    this.showClassificationOptions(startPos, endPos);
                }
            });
            
            // Also listen for native text selection events (as backup)
            document.addEventListener('mouseup', (e) => {
                // Only handle if the click was within our content area
                if (this.contentElement.contains(e.target)) {
                    setTimeout(() => {
                        const selection = window.getSelection();
                        const selectedText = selection.toString().trim();
                        
                        if (selectedText.length > 0) {
                            console.log('Native selection detected:', {
                                text: selectedText.substring(0, 100),
                                fullLength: selectedText.length
                            });
                            
                            try {
                                const range = selection.getRangeAt(0);
                                const startPos = this.getTextPositionFromRange(range.startContainer, range.startOffset);
                                const endPos = this.getTextPositionFromRange(range.endContainer, range.endOffset);
                                
                                if (startPos !== endPos && endPos - startPos === selectedText.length) {
                                    console.log('Position calculation successful:', {
                                        start: startPos,
                                        end: endPos,
                                        calculatedLength: endPos - startPos,
                                        actualLength: selectedText.length
                                    });
                                    this.showClassificationOptions(startPos, endPos);
                                } else {
                                    console.log('Position calculation mismatch, using fallback');
                                    // Fallback: try to find the text in the content
                                    const contentText = this.contentElement.textContent;
                                    const textIndex = contentText.indexOf(selectedText);
                                    if (textIndex !== -1) {
                                        this.showClassificationOptions(textIndex, textIndex + selectedText.length);
                                    }
                                }
                            } catch (error) {
                                console.error('Error processing native selection:', error);
                                // Fallback: try to find the text in the content
                                const contentText = this.contentElement.textContent;
                                const textIndex = contentText.indexOf(selectedText);
                                if (textIndex !== -1) {
                                    this.showClassificationOptions(textIndex, textIndex + selectedText.length);
                                }
                            }
                        }
                    }, 50);
                }
            });
        }
        
        getTextPositionFromEvent(e) {
            const range = document.caretRangeFromPoint(e.clientX, e.clientY);
            if (!range) return 0;
            
            // Find the character position in the text content (ignoring HTML)
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(this.contentElement);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            
            return preCaretRange.toString().length;
        }
        
        getTextPositionFromRange(container, offset) {
            // Create a range from the start of the content to the given position
            const range = document.createRange();
            range.setStart(this.contentElement, 0);
            range.setEnd(container, offset);
            
            // Return the length of text content up to this point
            return range.toString().length;
        }
        
        showSelectionPreview(start, end) {
            // Clear previous preview
            this.clearSelectionPreview();
            
            if (start === end) return;
            
            const min = Math.min(start, end);
            const max = Math.max(start, end);
            
            const preview = document.createElement('div');
            preview.className = 'absolute bg-yellow-200 bg-opacity-50 border border-yellow-400';
            preview.id = 'selection-preview';
            
            try {
                // Create a range based on text content positions
                const range = document.createRange();
                const textContent = this.contentElement.textContent;
                
                // Find the text nodes that contain our selection
                const walker = document.createTreeWalker(
                    this.contentElement,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );
                
                let currentPos = 0;
                let startNode = null;
                let endNode = null;
                let startOffset = 0;
                let endOffset = 0;
                
                while (walker.nextNode()) {
                    const textNode = walker.currentNode;
                    const nodeLength = textNode.textContent.length;
                    
                    if (!startNode && currentPos + nodeLength >= min) {
                        startNode = textNode;
                        startOffset = min - currentPos;
                    }
                    
                    if (!endNode && currentPos + nodeLength >= max) {
                        endNode = textNode;
                        endOffset = max - currentPos;
                        break;
                    }
                    
                    currentPos += nodeLength;
                }
                
                if (startNode && endNode) {
                    range.setStart(startNode, startOffset);
                    range.setEnd(endNode, endOffset);
                    
                    const rect = range.getBoundingClientRect();
                    const containerRect = this.contentElement.getBoundingClientRect();
                    
                    preview.style.left = `${rect.left - containerRect.left}px`;
                    preview.style.top = `${rect.top - containerRect.top}px`;
                    preview.style.width = `${rect.width}px`;
                    preview.style.height = `${rect.height}px`;
                    
                    this.contentElement.appendChild(preview);
                }
            } catch (error) {
                console.error('Error showing selection preview:', error);
            }
        }
        
        clearSelectionPreview() {
            const preview = document.getElementById('selection-preview');
            if (preview) {
                preview.remove();
            }
        }
        
        showClassificationOptions(start, end) {
            this.clearSelectionPreview();
            
            if (start === end) return;
            
            const min = Math.min(start, end);
            const max = Math.max(start, end);
            const selectedText = this.contentElement.textContent.substring(min, max);
            
            console.log('Showing classification options:', {
                start: min,
                end: max,
                textLength: selectedText.length,
                textPreview: selectedText.substring(0, 100)
            });
            
            // Show classification modal
            this.showClassificationModal(selectedText, min, max);
        }
        
        showClassificationModal(text, start, end) {
            // Create modal for classification
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 z-50 flex items-center justify-center';
            
            // Add click outside to close
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    this.closeModal();
                }
            }.bind(this));
            
            // Add ESC key to close
            const handleEsc = function(e) {
                if (e.key === 'Escape') {
                    this.closeModal();
                    document.removeEventListener('keydown', handleEsc);
                }
            }.bind(this);
            document.addEventListener('keydown', handleEsc);
            
            modal.innerHTML = `
                <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                    <h3 class="text-lg font-semibold mb-4">Classify Selected Text</h3>
                    <p class="text-sm text-gray-600 mb-4">"${text.substring(0, 100)}${text.length > 100 ? '...' : ''}"</p>
                    <div class="flex space-x-3">
                        <button onclick="event.stopPropagation(); simpleTextManager.classifySelection(${start}, ${end}, 'huntable'); simpleTextManager.closeModal();" 
                                class="flex-1 bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700">
                            Huntable
                        </button>
                        <button onclick="event.stopPropagation(); simpleTextManager.classifySelection(${start}, ${end}, 'not_huntable'); simpleTextManager.closeModal();" 
                                class="flex-1 bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700">
                            Not Huntable
                        </button>
                        <button onclick="simpleTextManager.closeModal()" 
                                class="px-4 py-2 border border-gray-300 rounded hover:bg-gray-50">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        async classifySelection(start, end, classification) {
            // Prevent duplicate submissions - check immediately
            if (this.isSubmitting) {
                console.log('Preventing duplicate submission - already submitting');
                return;
            }
            this.isSubmitting = true;
            
            try {
                const text = this.contentElement.textContent.substring(start, end);
                
                console.log('Classifying selection:', {
                    start: start,
                    end: end,
                    textLength: text.length,
                    textPreview: text.substring(0, 100),
                    classification: classification
                });
                
                // Close modal immediately to provide visual feedback
                this.closeModal();
                
                // Add the classification highlight
                this.addUserClassification(start, end, classification, text);
                
                // Save to server
                await this.saveClassification(start, end, text, classification);
                
                // Show success message
                this.showSuccessMessage('Text classified as ' + (classification === 'huntable' ? 'Huntable' : 'Not Huntable'));
                
            } finally {
                // Reset submission state after a short delay to prevent rapid clicking
                setTimeout(() => {
                    this.isSubmitting = false;
                }, 500);
            }
        }
        
        showRemoveAnnotationModal(spanElement, annotationType, annotationText) {
            // Store reference to the span element for removal
            this.pendingRemovalSpan = spanElement;
            this.pendingRemovalText = annotationText;
            
            // Create modal for removing annotation
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 z-50 flex items-center justify-center';
            
            // Add click outside to close
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    this.closeModal();
                }
            }.bind(this));
            
            // Add ESC key to close
            const handleEsc = function(e) {
                if (e.key === 'Escape') {
                    this.closeModal();
                    document.removeEventListener('keydown', handleEsc);
                }
            }.bind(this);
            document.addEventListener('keydown', handleEsc);
            
            modal.innerHTML = `
                <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                    <h3 class="text-lg font-semibold mb-4">Remove Annotation</h3>
                    <p class="text-sm text-gray-600 mb-2">
                        <strong>Type:</strong> ${annotationType === 'huntable' ? 'Huntable' : 'Not Huntable'}
                    </p>
                    <p class="text-sm text-gray-600 mb-4">
                        <strong>Text:</strong> "${annotationText.substring(0, 100)}${annotationText.length > 100 ? '...' : ''}"
                    </p>
                    <p class="text-sm text-gray-700 mb-4">
                        Do you want to remove this annotation?
                    </p>
                    <div class="flex space-x-3">
                        <button onclick="simpleTextManager.confirmRemoveAnnotation()" 
                                class="flex-1 bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700">
                            Remove
                        </button>
                        <button onclick="simpleTextManager.closeModal()" 
                                class="flex-1 px-4 py-2 border border-gray-300 rounded hover:bg-gray-50">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        async confirmRemoveAnnotation() {
            if (!this.pendingRemovalSpan || !this.pendingRemovalText) {
                console.error('No pending annotation removal');
                return;
            }
            
            try {
                // Save state for undo
                this.saveState();
                
                // Remove the span from the DOM (replace with original text)
                const originalText = this.pendingRemovalText;
                const parent = this.pendingRemovalSpan.parentNode;
                const textNode = document.createTextNode(originalText);
                parent.replaceChild(textNode, this.pendingRemovalSpan);
                
                // Find and delete the annotation from the database
                const response = await fetch(`/api/articles/{{ article.id }}/annotations`, {
                    method: 'GET'
                });
                const data = await response.json();
                
                if (data.success && data.annotations.length > 0) {
                    // Find the annotation that matches our text
                    const matchingAnnotation = data.annotations.find(annotation => 
                        annotation.selected_text === originalText
                    );
                    
                    if (matchingAnnotation) {
                        // Delete it from database
                        const deleteResponse = await fetch(`/api/articles/{{ article.id }}/annotations/${matchingAnnotation.id}`, {
                            method: 'DELETE'
                        });
                        
                        if (deleteResponse.ok) {
                            console.log(`Removed annotation ID ${matchingAnnotation.id} from database`);
                        } else {
                            console.error('Failed to remove annotation from database');
                        }
                    } else {
                        console.log('Could not find matching annotation in database');
                    }
                }
                
                // Clear pending removal references
                this.pendingRemovalSpan = null;
                this.pendingRemovalText = null;
                
                console.log('Annotation removed successfully');
                
            } catch (error) {
                console.error('Error removing annotation:', error);
            }
            
            this.closeModal();
        }
        
        closeModal() {
            const modal = document.querySelector('.fixed.inset-0.bg-gray-600.bg-opacity-50');
            if (modal) {
                modal.remove();
            }
        }
        
        showSuccessMessage(message) {
            // Create a temporary success message
            const successDiv = document.createElement('div');
            successDiv.className = 'fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded shadow-lg z-50';
            successDiv.textContent = message;
            document.body.appendChild(successDiv);
            
            // Remove after 2 seconds
            setTimeout(() => {
                if (successDiv.parentNode) {
                    successDiv.parentNode.removeChild(successDiv);
                }
            }, 2000);
        }
        
        async saveClassification(start, end, text, classification) {
            try {
                console.log('Saving classification:', {
                    start: start,
                    end: end,
                    textLength: text.length,
                    textPreview: text.substring(0, 100),
                    classification: classification
                });
                
                const response = await fetch(`/api/articles/{{ article.id }}/annotations`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        selected_text: text,
                        start_position: start,
                        end_position: end,
                        annotation_type: classification
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API Error Response:', errorText);
                    throw new Error(`Failed to save classification: ${response.status} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log('Classification saved successfully:', result);
                
                // Show success notification
                showNotification(`Annotation saved successfully!`, 'success');
                
            } catch (error) {
                console.error('Error saving classification:', error);
                showNotification(`Failed to save annotation: ${error.message}`, 'error');
            }
        }
    }
    
    // Initialize the simple text manager
    let simpleTextManager;
    document.addEventListener('DOMContentLoaded', function() {
        simpleTextManager = new SimpleTextManager();
    });
    
    // Classification functions
    async function classifyArticle(category) {
        const articleId = {{ article.id }};
        
        // Check if comment prompts are enabled
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const commentPromptsEnabled = settings.commentPromptsEnabled === true; // Default to false
        
        let reason = null;
        if (commentPromptsEnabled && (category === 'chosen' || category === 'rejected')) {
            reason = prompt(`Reason for marking as ${category} (optional):`);
        }
        
        try {
            const response = await fetch(`/api/articles/${articleId}/classify`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    category: category,
                    reason: reason || null
                })
            });
            
            if (response.ok) {
                // Show success message
                showNotification(`Article marked as ${category} successfully!`, 'success');
                
                // Update the current status display
                updateClassificationStatus(category);
                
                // Auto-advance to next unclassified only if marked as rejected
                if (category === 'rejected') {
                    setTimeout(() => {
                        navigateToNextUnclassified();
                    }, 2000); // Increased delay to ensure database is updated
                }
            } else {
                const error = await response.json();
                showNotification(`Error: ${error.detail}`, 'error');
            }
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        }
    }
    
    function updateClassificationStatus(category) {
        const statusElement = document.querySelector('.inline-flex.items-center.px-3.py-1.rounded-full');
        if (statusElement) {
            statusElement.className = 'inline-flex items-center px-3 py-1 rounded-full text-sm font-medium';
            
            if (category === 'chosen') {
                statusElement.className += ' bg-green-100 text-green-800';
                statusElement.textContent = '‚úÖ Chosen';
            } else if (category === 'rejected') {
                statusElement.className += ' bg-red-100 text-red-800';
                statusElement.textContent = '‚ùå Rejected';
            } else {
                statusElement.className += ' bg-gray-100 text-gray-800';
                statusElement.textContent = '‚è≥ Unclassified';
            }
        }
        
        // Store the current classification in localStorage for the AI Assistant modal
        localStorage.setItem('currentArticleClassification', category);
    }
    
    function showNotification(message, type) {
        // Create notification element
        const notification = document.createElement('div');
        notification.className = `fixed top-4 right-4 z-50 p-4 rounded-md shadow-lg max-w-sm ${
            type === 'success' ? 'bg-green-500 text-white' : 
            type === 'error' ? 'bg-red-500 text-white' : 
            type === 'info' ? 'bg-blue-500 text-white' : 'bg-gray-500 text-white'
        }`;
        notification.textContent = message;
        
        // Add to page
        document.body.appendChild(notification);
        
        // Remove after 3 seconds
        setTimeout(() => {
            notification.remove();
        }, 3000);
    }
    
    function markOperationComplete(operationId, status = 'completed') {
        console.log('markOperationComplete called with:', operationId, status);
        
        // Update operation status in localStorage
        const ongoingOps = JSON.parse(localStorage.getItem('ongoingAIOperations') || '[]');
        const operationIndex = ongoingOps.findIndex(op => op.id === operationId);
        
        console.log('Found operation at index:', operationIndex, 'Operations:', ongoingOps);
        
        if (operationIndex !== -1) {
            ongoingOps[operationIndex].status = status;
            ongoingOps[operationIndex].completedAt = Date.now();
            localStorage.setItem('ongoingAIOperations', JSON.stringify(ongoingOps));
            
            // Store completion notification for cross-page display
            if (status === 'completed') {
                const completionNotification = {
                    id: `completion_${Date.now()}`,
                    operationId: operationId,
                    type: ongoingOps[operationIndex].type,
                    typeText: ongoingOps[operationIndex].typeText,
                    typeIcon: ongoingOps[operationIndex].typeIcon,
                    articleId: ongoingOps[operationIndex].articleId,
                    articleTitle: ongoingOps[operationIndex].articleTitle,
                    completedAt: Date.now()
                };
                
                console.log('Creating completion notification:', completionNotification);
                
                const completions = JSON.parse(localStorage.getItem('pendingCompletions') || '[]');
                completions.push(completionNotification);
                localStorage.setItem('pendingCompletions', JSON.stringify(completions));
                
                console.log('Stored pending completions:', completions);
            }
        }
    }
    
    function showCompletionBanner(type, typeText, typeIcon, articleId = null, articleTitle = null) {
        console.log('showCompletionBanner called with:', type, typeText, typeIcon, articleId, articleTitle);
        
        // Create completion banner
        const banner = document.createElement('div');
        banner.id = 'completionBanner';
        banner.className = 'fixed top-4 right-4 z-50 p-4 rounded-md shadow-lg max-w-sm bg-green-500 text-white';
        
        const bannerArticleTitle = articleTitle || '{{ article.title }}';
        const bannerArticleId = articleId || {{ article.id }};
        
        banner.innerHTML = `
            <div class="flex items-center space-x-2">
                <span class="text-lg">${typeIcon}</span>
                <div class="flex-1">
                    <div class="font-medium">${typeText} Complete!</div>
                    <div class="text-sm opacity-90">Article: ${bannerArticleTitle.length > 30 ? bannerArticleTitle.substring(0, 30) + '...' : bannerArticleTitle}</div>
                    <a href="#" onclick="event.preventDefault(); window.location.hash = '${type}'; setTimeout(() => window.location.reload(), 100);" class="text-sm underline hover:no-underline">View Results ‚Üí</a>
                </div>
                <button onclick="this.parentElement.parentElement.remove()" class="text-white hover:text-gray-200">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
        `;
        
        // Add to page
        document.body.appendChild(banner);
        console.log('Banner added to DOM:', banner);
        
        // Remove after 10 seconds
        setTimeout(() => {
            const bannerElement = document.getElementById('completionBanner');
            if (bannerElement) {
                console.log('Removing banner after 10 seconds');
                bannerElement.remove();
            }
        }, 10000);
    }
    
    // Navigation functions
    async function navigateToNextUnclassified(retryCount = 0) {
        try {
            const response = await fetch(`/api/articles/next-unclassified?current_article_id={{ article.id }}`);
            const data = await response.json();
            
            if (data.article_id) {
                window.location.href = `/articles/${data.article_id}`;
            } else {
                // If no article found and we haven't retried yet, wait and retry once
                if (retryCount === 0) {
                    console.log('No unclassified article found, retrying in 1 second...');
                    setTimeout(() => {
                        navigateToNextUnclassified(1);
                    }, 1000);
            } else {
                showNotification('No more unclassified articles found!', 'info');
                }
            }
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        }
    }
    
    async function navigateToPrevious() {
        try {
            const currentId = {{ article.id }};
            const response = await fetch(`/api/articles/previous?current_article_id=${currentId}`);
            const data = await response.json();
            
            if (data.article_id) {
                window.location.href = `/articles/${data.article_id}`;
            } else {
                showNotification('No previous article found', 'info');
            }
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        }
    }
    
    async function navigateToNext() {
        try {
            const currentId = {{ article.id }};
            const response = await fetch(`/api/articles/next?current_article_id=${currentId}`);
            const data = await response.json();
            
            if (data.article_id) {
                window.location.href = `/articles/${data.article_id}`;
            } else {
                showNotification('No next article found', 'info');
            }
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        }
    }
    
    // AI Assistant Functions
    async function showAIAssistant() {
        // Get AI model from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const aiModel = settings.aiModel || 'chatgpt';
        
        // Check content size limits
        const contentLength = {{ article.content|length if article.content else 0 }};
        const contentLimit = aiModel === 'chatgpt' ? {{ chatgpt_content_limit }} : 
                           aiModel === 'anthropic' ? {{ anthropic_content_limit }} : {{ ollama_content_limit }};
        
        if (contentLength > contentLimit) {
            const modelName = aiModel === 'chatgpt' ? 'ChatGPT' : 
                            aiModel === 'anthropic' ? 'Claude' : 'Llama';
            showNotification(`Article too large for ${modelName}. Content: ${contentLength.toLocaleString()} chars, limit: ${contentLimit.toLocaleString()} chars.`, 'warning');
            return;
        }
        
        // Get current article classification
        const currentClassification = localStorage.getItem('currentArticleClassification') || '{{ article.article_metadata.get("training_category", "") }}';
        const isChosen = currentClassification === 'chosen';
        
        // Get threat hunting score for SIGMA warning
        const threatHuntingScore = {{ article.article_metadata.get('threat_hunting_score', 0) if article.article_metadata and article.article_metadata.get('threat_hunting_score') is not none else 0 }};
        const showSigmaWarning = isChosen && threatHuntingScore < 65;
        
        // Fetch fresh data from API to get current state
        let hasSummary = {{ 'true' if article.article_metadata and article.article_metadata.get('chatgpt_summary') else 'false' }};
        let hasSigmaRules = {{ 'true' if article.article_metadata and article.article_metadata.get('sigma_rules') else 'false' }};
        let hasIOCs = {{ 'true' if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'false' }};
        let hasRanking = {{ 'true' if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'false' }};
        
        try {
            const response = await fetch(`/api/articles/{{ article.id }}`);
            if (response.ok) {
                const data = await response.json();
                if (data.article_metadata) {
                    hasSummary = data.article_metadata.chatgpt_summary ? true : false;
                    hasSigmaRules = data.article_metadata.sigma_rules ? true : false;
                    hasIOCs = data.article_metadata.extracted_iocs ? true : false;
                    hasRanking = data.article_metadata.gpt4o_ranking ? true : false;
                }
            }
        } catch (error) {
            console.log('Failed to fetch fresh data, using template data:', error);
        }
        
        const modal = document.createElement('div');
        modal.id = 'aiAssistantModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeAIAssistantModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeAIAssistantModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        // Get AI model from settings to determine button text
        const rankingButtonText = hasRanking ? 
            (aiModel === 'chatgpt' ? 'Display GPT4o Rank' : 
             aiModel === 'anthropic' ? 'Display Claude Rank' : 'Display LLM Rank') :
            (aiModel === 'chatgpt' ? 'Rank with GPT4o' : 
             aiModel === 'anthropic' ? 'Rank with Claude' : 'Rank with Local LLM');
        
        modal.innerHTML = `
            <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <h3 class="text-lg font-medium text-gray-900 mb-4">ü§ñ AI Assistant</h3>
                    <p class="text-sm text-gray-500 mb-6">Choose what you'd like to ${hasSummary || hasSigmaRules || hasIOCs || hasRanking ? 'view or regenerate' : 'generate'}:</p>
                    
                    <div class="space-y-3">
                        <button onclick="generateAIAnalysis('summary')" 
                                class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors">
                            <span class="mr-2">üìù</span>
                            ${hasSummary ? 'Display Summary' : 'Generate Summary'}
                        </button>
                        
                        <button onclick="generateAIAnalysis('sigma')" 
                                class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md transition-colors ${isChosen ? 'text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500' : 'text-gray-400 bg-gray-300 cursor-not-allowed'}"
                                ${!isChosen ? 'disabled' : ''}
                                title="${isChosen ? (hasSigmaRules ? 'Display existing SIGMA detection rules' : 'Generate SIGMA detection rules for this article') : 'SIGMA rules can only be generated for articles marked as "Chosen". Please classify this article first.'}">
                            <span class="mr-2">üîç</span>
                            ${hasSigmaRules ? 'Display SIGMA Rules' : 'Generate SIGMA Rules'}
                            ${showSigmaWarning ? '<span class="ml-2 text-yellow-300">‚ö†Ô∏è</span>' : ''}
                        </button>
                        ${!isChosen ? '<div class="text-xs text-gray-500 text-center mt-1">‚ö†Ô∏è Only available for articles marked as "Chosen"</div>' : ''}
                        ${showSigmaWarning ? '<div class="text-xs text-yellow-600 text-center mt-1">‚ö†Ô∏è Low threat hunting score (' + threatHuntingScore + '/100) - SIGMA rules may lack technical depth</div>' : ''}
                        
                        <button onclick="generateAIAnalysis('iocs')" 
                                class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-orange-600 hover:bg-orange-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500 transition-colors">
                            <span class="mr-2">üîç</span>
                            ${hasIOCs ? 'Display IOCs' : 'Extract IOCs'}
                        </button>
                        
                        <button onclick="generateAIAnalysis('ranking')" 
                                class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors">
                            <span class="mr-2">üìä</span>
                            ${rankingButtonText}
                        </button>
                        
                        <button onclick="showCustomPromptModal()" 
                                class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-purple-600 hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                            <span class="mr-2">üí¨</span>
                            Custom Prompt
                        </button>
                        
                        <button onclick="showChunkDebugModal()" 
                                class="w-full inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                            <span class="mr-2">üîç</span>
                            Chunk Debug Mode
                        </button>
                        
                        <button onclick="closeAIAssistantModal()" 
                                class="w-full inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                            Cancel
                        </button>
                    </div>
                    
                    <div class="mt-4 p-2 bg-gray-50 rounded text-xs text-gray-600">
                        Using: ${aiModel === 'chatgpt' ? 'ChatGPT (OpenAI)' : 
                               aiModel === 'anthropic' ? 'Claude (Anthropic)' : 'Llama (Local)'}
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }
    
    function closeAIAssistantModal() {
        const modal = document.getElementById('aiAssistantModal');
        if (modal) {
            modal.remove();
        }
    }
    
    async function generateAIAnalysis(type, forceRegenerate = false, useLLMValidation = false) {
        closeAIAssistantModal();
        
        // Check for existing content first (unless force regenerate)
        if (!forceRegenerate) {
            if (type === 'summary' && {{ 'true' if article.article_metadata and article.article_metadata.get('chatgpt_summary') else 'false' }}) {
                const summaryData = {{ article.article_metadata.get('chatgpt_summary') | tojson if article.article_metadata and article.article_metadata.get('chatgpt_summary') else 'null' }};
                showChatGPTSummaryModal(summaryData.summary, summaryData);
                return;
            }
            
            if (type === 'sigma' && {{ 'true' if article.article_metadata and article.article_metadata.get('sigma_rules') else 'false' }}) {
                const sigmaData = {{ article.article_metadata.get('sigma_rules') | tojson if article.article_metadata and article.article_metadata.get('sigma_rules') else 'null' }};
                showSigmaRulesModal(sigmaData.rules, sigmaData);
                return;
            }
            
            if (type === 'iocs' && {{ 'true' if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'false' }}) {
                const iocData = {{ article.article_metadata.get('extracted_iocs') | tojson if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'null' }};
                showIOCsModal(JSON.stringify(iocData.iocs, null, 2), iocData);
                return;
            }
            
            if (type === 'ranking' && {{ 'true' if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'false' }}) {
                const rankingData = {{ article.article_metadata.get('gpt4o_ranking') | tojson if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'null' }};
                showGPT4oRankingModal(rankingData.analysis, rankingData);
                return;
            }
        }
        
        // Check if SIGMA rules are allowed for this article
        if (type === 'sigma') {
            const currentClassification = localStorage.getItem('currentArticleClassification') || '{{ article.article_metadata.get("training_category", "") }}';
            const isChosen = currentClassification === 'chosen';
            if (!isChosen) {
                showNotification('SIGMA rules can only be generated for articles marked as "Chosen". Please classify this article first.', 'error');
                return;
            }
            
            // Check threat hunting score for SIGMA rules
            const threatHuntingScore = {{ article.article_metadata.get('threat_hunting_score', 0) if article.article_metadata and article.article_metadata.get('threat_hunting_score') is not none else 0 }};
            if (threatHuntingScore < 65) {
                const confirmed = confirm(`‚ö†Ô∏è Warning: This article has a low threat hunting score (${threatHuntingScore}/100).\n\nSIGMA rules are not recommended for articles with scores below 65 as they may lack sufficient technical depth for effective detection rules.\n\nDo you want to proceed anyway?`);
                if (!confirmed) {
                    return;
                }
            }
        }
        
        // Get AI model from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const aiModel = settings.aiModel || 'chatgpt';
        const apiKey = aiModel === 'anthropic' ? settings.anthropicApiKey : settings.openaiApiKey;
        
        if ((aiModel === 'chatgpt' || aiModel === 'anthropic') && !apiKey) {
            const keyType = aiModel === 'anthropic' ? 'Anthropic' : 'OpenAI';
            showNotification(`Please configure your ${keyType} API key in Settings first`, 'error');
            return;
        }
        
        // Store ongoing AI operation in localStorage for cross-page tracking
        const articleId = {{ article.id }};
        const operationId = `ai_${type}_${articleId}_${Date.now()}`;
        const operationData = {
            id: operationId,
            type: type,
            typeText: type === 'summary' ? 'Summary' : type === 'sigma' ? 'SIGMA Rules' : type === 'ranking' ? (aiModel === 'chatgpt' ? 'GPT4o Ranking' : 'Local AI Ranking') : 'IOCs',
            typeIcon: type === 'summary' ? 'üìù' : type === 'sigma' ? 'üîç' : type === 'ranking' ? 'üìä' : 'üîç',
            articleId: articleId,
            articleTitle: '{{ article.title }}',
            startedAt: Date.now(),
            status: 'running'
        };
        
        // Store in localStorage
        const ongoingOps = JSON.parse(localStorage.getItem('ongoingAIOperations') || '[]');
        ongoingOps.push(operationData);
        localStorage.setItem('ongoingAIOperations', JSON.stringify(ongoingOps));
        
        // Show loading modal
        const loadingModal = document.createElement('div');
        loadingModal.id = 'loadingModal';
        loadingModal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        const typeText = operationData.typeText;
        const typeIcon = operationData.typeIcon;
        
        // Debug logging
        console.log('generateAIAnalysis called with type:', type);
        console.log('typeText:', typeText);
        console.log('typeIcon:', typeIcon);
        
        // Track if request has started
        let requestStarted = false;
        
        // Add ESC key handler to close loading modal
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('loadingModal');
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleEsc);
                
                // Only show background message if request actually started
                if (requestStarted) {
                    showNotification('AI generation continues in the background. You can return to this article later to view the results.', 'info');
                }
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        loadingModal.innerHTML = `
            <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-purple-100">
                        <svg class="animate-spin h-6 w-6 text-purple-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <h3 class="text-lg font-medium text-gray-900 mt-4">${typeIcon} ${type === 'summary' ? 'Generating' : type === 'sigma' ? 'Generating' : type === 'ranking' ? 'Generating' : 'Extracting'} ${typeText}...</h3>
                    <p class="text-sm text-gray-500 mt-2">${type === 'summary' ? 'Creating a comprehensive summary' : type === 'sigma' ? 'Creating detection rules' : type === 'ranking' ? (aiModel === 'chatgpt' ? 'Analyzing content with GPT-4o' : 'Analyzing content with local AI') : 'Extracting indicators of compromise'} - this may take a few moments.</p>
                    <p class="text-xs text-gray-400 mt-3">üí° Press <kbd class="px-1 py-0.5 bg-gray-200 rounded text-xs">ESC</kbd> to leave while generation continues</p>
                </div>
            </div>
        `;
        document.body.appendChild(loadingModal);
        
        try {
            // Create a timeout promise - longer for LLM operations
            const timeoutPromise = new Promise((_, reject) => {
                const timeoutMs = aiModel === 'chatgpt' ? 180000 : 600000; // 180s for ChatGPT, 600s for LLM
                setTimeout(() => reject(new Error(`Request timed out after ${timeoutMs/1000} seconds`)), timeoutMs);
            });
            
            // Create the fetch promise
            const endpoint = type === 'summary' ? 'chatgpt-summary' : type === 'sigma' ? 'generate-sigma' : type === 'ranking' ? 'rank-with-gpt4o' : 'extract-iocs';
            
            // Prepare request body
            const requestBody = {
                include_content: true,
                api_key: apiKey,
                force_regenerate: forceRegenerate,
                ai_model: aiModel,
                temperature: parseFloat(settings.aiTemperature || '0.3')
            };
            
            // Add LLM validation setting for IOC extraction
            if (type === 'iocs') {
                requestBody.use_llm_validation = useLLMValidation;
                
                // Add optimization options for IOC extraction when LLM validation is enabled
                if (useLLMValidation && requestBody.optimization_options) {
                    requestBody.use_filtering = requestBody.optimization_options.useFiltering;
                    requestBody.min_confidence = requestBody.optimization_options.minConfidence;
                }
            }
            
            // Add author name for SIGMA rules
            if (type === 'sigma') {
                const sigmaAuthor = settings.sigmaAuthor || 'CTIScraper User';
                requestBody.author_name = sigmaAuthor;
            }
            
            // Add optimization options for ranking, summary, sigma, and IOC extraction with LLM validation
            if (type === 'ranking' || type === 'summary' || type === 'sigma' || (type === 'iocs' && useLLMValidation)) {
                const optimizationOptions = await showOptimizationDialog();
                if (!optimizationOptions) {
                    // User cancelled - clean up and return
                    const loadingModal = document.getElementById('loadingModal');
                    if (loadingModal && loadingModal.parentNode) {
                        loadingModal.remove();
                    }
                    document.removeEventListener('keydown', handleEsc);
                    return;
                }
                requestBody.optimization_options = optimizationOptions;
            }
            
            const fetchPromise = fetch(`/api/articles/{{ article.id }}/${endpoint}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody)
            });
            
            // Mark request as started
            requestStarted = true;
            
            // Race between fetch and timeout
            const response = await Promise.race([fetchPromise, timeoutPromise]);
            
            if (response.ok) {
                const data = await response.json();
                
                console.log('AI generation completed successfully:', data);
                
                // Mark operation as complete and show banner
                markOperationComplete(operationId);
                showCompletionBanner(type, typeText, typeIcon);
                
                console.log('Completion banner should be showing now');
                
                // Don't automatically show results - let user choose when to view them
            } else {
                const error = await response.json();
                console.log('API Error:', error);
                markOperationComplete(operationId, 'failed');
                showNotification(`${typeText} ${type === 'summary' ? 'generation' : type === 'sigma' ? 'generation' : type === 'ranking' ? 'generation' : 'extraction'} failed: ${error.detail}`, 'error');
            }
        } catch (error) {
            console.log('Caught error:', error);
            markOperationComplete(operationId, 'failed');
            if (error.message.includes('timed out')) {
                const timeoutMsg = aiModel === 'chatgpt' ? '60 seconds' : '200 seconds';
                showNotification(`${typeText} ${type === 'summary' ? 'generation' : type === 'sigma' ? 'generation' : type === 'ranking' ? 'generation' : 'extraction'} timed out after ${timeoutMsg}. Try using a different model or check your settings.`, 'error');
            } else {
                showNotification(`Error: ${error.message}`, 'error');
            }
        } finally {
            // Remove loading modal and clean up ESC handler
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.parentNode) {
                loadingModal.remove();
            }
            // Clean up the ESC key handler
            document.removeEventListener('keydown', handleEsc);
        }
    }
    
    // Enhanced GPT4o Ranking Function with Content Filtering
    async function rankWithGPT4o() {
        const articleId = {{ article.id }};
        
        // Get API key from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const aiModel = settings.aiModel || 'chatgpt';
        const apiKey = aiModel === 'anthropic' ? settings.anthropicApiKey : settings.openaiApiKey;
        
        if (!apiKey) {
            const keyType = aiModel === 'anthropic' ? 'Anthropic' : 'OpenAI';
            showNotification(`Please configure your ${keyType} API key in Settings first`, 'error');
            return;
        }
        
        // Show optimization options dialog
        const optimizationOptions = await showOptimizationDialog();
        if (!optimizationOptions) {
            return; // User cancelled
        }
        
        // Estimate cost before proceeding
        const articleContent = `{{ article.content[:1000] }}`; // Get first 1000 chars for estimation
        const estimatedTokens = Math.ceil(articleContent.length / 4); // Rough estimate: 1 token ‚âà 4 chars
        const promptTokens = 1508; // Updated prompt length (6,033 chars ‚âà 1,508 tokens)
        const totalTokens = estimatedTokens + promptTokens;
        
        // GPT4o pricing: $5.00 per 1M input tokens, $15.00 per 1M output tokens
        const inputCost = (totalTokens / 1000000) * 5.00;
        const outputCost = (2000 / 1000000) * 15.00; // Assume 2000 output tokens
        const totalCost = inputCost + outputCost;
        
        // Estimate cost savings if filtering is enabled
        let costSavings = 0;
        let costMessage = `Estimated cost: $${totalCost.toFixed(4)} (${totalTokens.toLocaleString()} input tokens + ~2,000 output tokens)`;
        
        if (optimizationOptions.useFiltering) {
            // Dynamic cost reduction based on confidence threshold
            // Lower confidence = more aggressive filtering = higher savings
            let savingsPercent = 0;
            if (optimizationOptions.minConfidence <= 0.5) {
                savingsPercent = 0.6; // 60% savings for aggressive filtering
            } else if (optimizationOptions.minConfidence <= 0.7) {
                savingsPercent = 0.4; // 40% savings for balanced filtering
            } else {
                savingsPercent = 0.25; // 25% savings for conservative filtering
            }
            
            costSavings = totalCost * savingsPercent;
            const optimizedCost = totalCost - costSavings;
            costMessage = `Estimated cost: $${optimizedCost.toFixed(4)} (${(savingsPercent*100).toFixed(0)}% savings from content filtering)`;
        }
        
        const confirmed = confirm(`GPT4o Analysis Cost Estimate:\n\n${costMessage}\n\nOptimization: ${optimizationOptions.useFiltering ? 'Enabled' : 'Disabled'}\nConfidence Threshold: ${optimizationOptions.minConfidence}\n\nDo you want to proceed with the analysis?`);
        if (!confirmed) {
            return;
        }
        
        // Show loading state
        const button = document.querySelector('button[onclick="rankWithGPT4o()"]');
        const originalText = button.innerHTML;
        button.innerHTML = '<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Analyzing...';
        button.disabled = true;
        button.classList.add('opacity-75', 'cursor-not-allowed');
        
        try {
            const response = await fetch(`/api/articles/${articleId}/gpt4o-rank-optimized`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    api_key: apiKey,
                    use_filtering: optimizationOptions.useFiltering,
                    min_confidence: optimizationOptions.minConfidence
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                showGPT4oRankingModal(data.analysis, data);
                
                // Show optimization results if available
                if (data.optimization && data.optimization.enabled) {
                    const opt = data.optimization;
                    showNotification(
                        `GPT4o analysis completed! Cost savings: $${opt.cost_savings.toFixed(4)} (${opt.tokens_saved.toLocaleString()} tokens saved, ${opt.chunks_removed} chunks removed)`, 
                        'success'
                    );
                    
                    // Show debug info if available
                    if (data.debug_info && data.debug_info.removed_chunks.length > 0) {
                        showRemovedChunksDialog(data.debug_info);
                    }
                } else {
                    showNotification('GPT4o analysis completed successfully!', 'success');
                }
            } else {
                const error = await response.json();
                showNotification(`GPT4o analysis failed: ${error.detail}`, 'error');
            }
        } catch (error) {
            showNotification(`Error: ${error.message}`, 'error');
        } finally {
            // Restore button state
            button.innerHTML = originalText;
            button.disabled = false;
            button.classList.remove('opacity-75', 'cursor-not-allowed');
        }
    }
    

    // Show optimization options dialog
    async function showOptimizationDialog() {
        return new Promise((resolve) => {
            // Get AI model from settings to determine modal title
            const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
            const aiModel = settings.aiModel || 'chatgpt';
            const modelDisplayName = aiModel === 'chatgpt' ? 'GPT-4o' : 
                                    aiModel === 'anthropic' ? 'Claude' : 'LLM';
            
            // Create modal dialog
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4">${modelDisplayName} Content Optimization</h3>
                    
                    <div class="space-y-4">
                        <div class="flex items-center">
                            <input type="checkbox" id="useFiltering" checked class="mr-3">
                            <label for="useFiltering" class="text-sm text-gray-700">
                                Enable content filtering to reduce costs
                            </label>
                        </div>
                        
                        <div id="confidenceSection" class="ml-6">
                            <label for="minConfidence" class="block text-sm text-gray-700 mb-2">
                                Confidence threshold:
                            </label>
                            <select id="minConfidence" class="w-full border border-gray-300 rounded px-3 py-2">
                                <option value="0.5">0.5 - Aggressive filtering (~60% cost savings)</option>
                                <option value="0.7" selected>0.7 - Balanced filtering (~40% cost savings)</option>
                                <option value="0.8">0.8 - Conservative filtering (~25% cost savings)</option>
                            </select>
                            <p class="text-xs text-gray-500 mt-1">
                                Higher values keep more content but reduce cost savings
                            </p>
                        </div>
                        
                        <div class="bg-blue-50 p-3 rounded">
                            <h4 class="text-sm font-medium text-blue-900 mb-2">How it works:</h4>
                            <ul class="text-xs text-blue-800 space-y-1">
                                <li>‚Ä¢ Analyzes content chunks for huntability</li>
                                <li>‚Ä¢ Removes acknowledgments, marketing content</li>
                                <li>‚Ä¢ Keeps technical details, commands, IOCs</li>
                                <li>‚Ä¢ Typically saves 20-40% on costs</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="flex justify-end space-x-3 mt-6">
                        <button id="cancelBtn" class="px-4 py-2 text-gray-600 hover:text-gray-800">
                            Cancel
                        </button>
                        <button id="confirmBtn" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
                            Analyze
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Handle checkbox change
            const useFilteringCheckbox = modal.querySelector('#useFiltering');
            const confidenceSection = modal.querySelector('#confidenceSection');
            
            useFilteringCheckbox.addEventListener('change', (e) => {
                confidenceSection.style.display = e.target.checked ? 'block' : 'none';
            });
            
            // Handle button clicks
            modal.querySelector('#cancelBtn').addEventListener('click', () => {
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                resolve(null);
            });
            
            modal.querySelector('#confirmBtn').addEventListener('click', () => {
                const useFiltering = useFilteringCheckbox.checked;
                const minConfidence = parseFloat(modal.querySelector('#minConfidence').value);
                
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                resolve({
                    useFiltering,
                    minConfidence
                });
            });
            
            // Handle escape key
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    if (modal && modal.parentNode) {
                        modal.remove();
                    }
                    document.removeEventListener('keydown', handleEscape);
                    resolve(null);
                }
            };
            document.addEventListener('keydown', handleEscape);
        });
    }

    // Show removed chunks dialog for debugging
    function showRemovedChunksDialog(debugInfo) {
        const modal = document.createElement('div');
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        
        const chunksHtml = debugInfo.removed_chunks.map((chunk, index) => `
            <div class="mb-4 p-3 bg-red-50 border border-red-200 rounded">
                <div class="flex justify-between items-center mb-2">
                    <h4 class="text-sm font-medium text-red-900">Chunk ${chunk.chunk_id}</h4>
                    <span class="text-xs text-red-600">${chunk.text.length} chars</span>
                </div>
                <div class="text-xs text-red-800 bg-white p-2 rounded border max-h-32 overflow-y-auto">
                    ${chunk.text.replace(/\n/g, '<br>')}
                </div>
                <div class="text-xs text-red-600 mt-1">
                    Reason: ${chunk.reason || 'Not huntable'} | Confidence: ${chunk.confidence ? chunk.confidence.toFixed(2) : 'N/A'}
                </div>
            </div>
        `).join('');
        
        modal.innerHTML = `
            <div class="bg-white rounded-lg p-6 max-w-4xl w-full mx-4 max-h-[80vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold text-gray-900">üóëÔ∏è Removed Content Chunks</h3>
                    <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded">
                    <div class="text-sm text-blue-800">
                        <strong>Summary:</strong> ${debugInfo.chunks_removed} chunks removed 
                        (${debugInfo.reduction_percent}% content reduction)
                        <br>
                        <strong>Original:</strong> ${debugInfo.original_length.toLocaleString()} chars ‚Üí 
                        <strong>Filtered:</strong> ${debugInfo.filtered_length.toLocaleString()} chars
                    </div>
                </div>
                
                <div class="space-y-2">
                    ${chunksHtml}
                </div>
                
                <div class="mt-6 flex justify-end">
                    <button onclick="this.closest('.fixed').remove()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Handle escape key
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);
    }
    
    function showCustomPromptModal() {
        closeAIAssistantModal();
        
        // Get AI model from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const aiModel = settings.aiModel || 'chatgpt';
        const modelDisplayName = aiModel === 'chatgpt' ? 'ChatGPT (OpenAI)' : 
                                aiModel === 'anthropic' ? 'Claude (Anthropic)' : 'Llama (Local Ollama)';
        
        const modal = document.createElement('div');
        modal.id = 'customPromptModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeCustomPromptModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeCustomPromptModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-2xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gray-900">üí¨ Custom AI Prompt</h3>
                    <button onclick="closeCustomPromptModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-4 p-3 bg-gray-50 border border-gray-200 rounded-md">
                    <div class="text-sm text-gray-700">
                        <p class="font-medium mb-1">ü§ñ AI Model:</p>
                        <p class="text-gray-600">${modelDisplayName}</p>
                    </div>
                </div>
                
                <div class="mb-4">
                    <label for="customPrompt" class="block text-sm font-medium text-gray-700 mb-2">
                        Your Question or Request
                    </label>
                    <textarea id="customPrompt" 
                              rows="4" 
                              class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                              placeholder="Ask anything about this article. For example:&#10;- What are the main attack vectors mentioned?&#10;- How would I detect this threat in my network?&#10;- What are the key IOCs to monitor?&#10;- Explain the technical details in simple terms"></textarea>
                </div>
                
                <div class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
                    <div class="text-sm text-blue-800">
                        <p class="font-medium mb-1">üí° Tips:</p>
                        <ul class="list-disc list-inside space-y-1">
                            <li>Be specific about what you want to know</li>
                            <li>Ask for technical details, IOCs, or analysis</li>
                            <li>Request detection rules or threat hunting queries</li>
                            <li>Ask for explanations in different detail levels</li>
                        </ul>
                    </div>
                </div>
                
                <div class="flex justify-between">
                    <button onclick="showCustomPromptHistory()" 
                            class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                        <span class="mr-2">üìö</span>
                        View Previous Prompts
                    </button>
                    <div class="flex space-x-3">
                        <button onclick="closeCustomPromptModal()" 
                                class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                            Cancel
                        </button>
                        <button onclick="generateCustomPrompt()" 
                                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-purple-600 hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                            <span class="mr-2">ü§ñ</span>
                            Generate Response
                        </button>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        // Add Enter key handler to textarea
        const textarea = document.getElementById('customPrompt');
        if (textarea) {
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    generateCustomPrompt();
                }
            });
            // Focus the textarea
            textarea.focus();
        }
    }
    
    function closeCustomPromptModal() {
        const modal = document.getElementById('customPromptModal');
        if (modal) {
            modal.remove();
        }
    }
    
    async function generateCustomPrompt() {
        const customPrompt = document.getElementById('customPrompt').value.trim();
        
        if (!customPrompt) {
            showNotification('Please enter a question or request', 'error');
            return;
        }
        
        closeCustomPromptModal();
        
        // Get AI model from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const aiModel = settings.aiModel || 'chatgpt';
        const apiKey = aiModel === 'anthropic' ? settings.anthropicApiKey : settings.openaiApiKey;
        
        if ((aiModel === 'chatgpt' || aiModel === 'anthropic') && !apiKey) {
            const keyType = aiModel === 'anthropic' ? 'Anthropic' : 'OpenAI';
            showNotification(`Please configure your ${keyType} API key in Settings first`, 'error');
            return;
        }
        
        // Show loading modal
        const loadingModal = document.createElement('div');
        loadingModal.id = 'loadingModal';
        loadingModal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Track if request has started
        let requestStarted = false;
        
        // Add ESC key handler to close loading modal
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('loadingModal');
                if (modal && modal.parentNode) {
                    modal.remove();
                }
                document.removeEventListener('keydown', handleEsc);
                
                // Only show background message if request actually started
                if (requestStarted) {
                    showNotification('Custom prompt generation continues in the background. You can return to this article later to view the results.', 'info');
                }
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        loadingModal.innerHTML = `
            <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-purple-100">
                        <svg class="animate-spin h-6 w-6 text-purple-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <h3 class="text-lg font-medium text-gray-900 mt-4">ü§ñ Processing Custom Request...</h3>
                    <p class="text-sm text-gray-500 mt-2">This may take a few moments.</p>
                    <p class="text-xs text-gray-400 mt-3">üí° Press <kbd class="px-1 py-0.5 bg-gray-200 rounded text-xs">ESC</kbd> to leave while generation continues</p>
                </div>
            </div>
        `;
        document.body.appendChild(loadingModal);
        
        try {
            // Create a timeout promise - longer for LLM operations
            const timeoutPromise = new Promise((_, reject) => {
                const timeoutMs = aiModel === 'chatgpt' ? 180000 : 600000; // 180s for ChatGPT, 600s for LLM
                setTimeout(() => reject(new Error(`Request timed out after ${timeoutMs/1000} seconds`)), timeoutMs);
            });
            
            // Create the fetch promise
            const fetchPromise = fetch(`/api/articles/{{ article.id }}/custom-prompt`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    prompt: customPrompt,
                    api_key: apiKey,
                    ai_model: aiModel
                })
            });
            
            // Mark request as started
            requestStarted = true;
            
            // Race between fetch and timeout
            const response = await Promise.race([fetchPromise, timeoutPromise]);
            
            if (response.ok) {
                const data = await response.json();
                showCustomResponseModal(data.response, customPrompt, data);
            } else {
                const error = await response.json();
                showNotification(`Custom prompt failed: ${error.detail}`, 'error');
            }
        } catch (error) {
            if (error.message.includes('timed out')) {
                const timeoutMsg = aiModel === 'chatgpt' ? '60 seconds' : '200 seconds';
                showNotification(`Custom prompt timed out after ${timeoutMsg}. Try using a different model or check your settings.`, 'error');
            } else {
                showNotification(`Error: ${error.message}`, 'error');
            }
        } finally {
            // Remove loading modal and clean up ESC handler
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.parentNode) {
                loadingModal.remove();
            }
            // Clean up the ESC key handler
            document.removeEventListener('keydown', handleEsc);
        }
    }
    
    function showCustomResponseModal(response, originalPrompt, data = null) {
        const modal = document.createElement('div');
        modal.id = 'customResponseModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeCustomResponseModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeCustomResponseModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        const modelUsed = data?.model_name || 'Unknown';
        const respondedAt = data?.responded_at ? new Date(data.responded_at).toLocaleString() : 'Unknown';
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gray-900">üí¨ Custom AI Response</h3>
                    <button onclick="closeCustomResponseModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-4 p-3 bg-gray-50 rounded-md">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                        <div>
                            <span class="font-medium text-gray-700">Your Question:</span>
                            <p class="text-gray-900 mt-1">${originalPrompt}</p>
                        </div>
                        <div>
                            <span class="font-medium text-gray-700">Model Used:</span>
                            <span class="text-gray-900">${modelUsed}</span>
                        </div>
                        <div>
                            <span class="font-medium text-gray-700">Responded At:</span>
                            <span class="text-gray-900">${respondedAt}</span>
                        </div>
                    </div>
                </div>
                
                <div class="bg-gray-50 rounded-lg p-4 max-h-96 overflow-y-auto">
                    <div class="prose max-w-none">
                        <pre class="whitespace-pre-wrap text-sm text-gray-800 font-mono">${response}</pre>
                    </div>
                </div>
                
                <div class="mt-4 flex justify-end space-x-3">
                    <button onclick="showCustomPromptModal()" 
                            class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-purple-600 hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                        <span class="mr-2">üí¨</span>
                        Ask a new question
                    </button>
                    <button onclick="closeCustomResponseModal()" 
                            class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }
    
    function closeCustomResponseModal() {
        const modal = document.getElementById('customResponseModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function showCustomPromptHistory() {
        closeCustomPromptModal();
        
        const modal = document.createElement('div');
        modal.id = 'customPromptHistoryModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeCustomPromptHistoryModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeCustomPromptHistoryModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        // Get stored custom prompts from article metadata
        const customPrompts = {{ article.article_metadata.get('custom_prompts', []) | tojson }};
        console.log('Custom prompts data:', customPrompts);
        console.log('Custom prompts length:', customPrompts ? customPrompts.length : 'null');
        
        let historyContent = '';
        if (customPrompts && customPrompts.length > 0) {
            console.log('Processing custom prompts...');
            historyContent = customPrompts.map((prompt, index) => {
                const respondedAt = new Date(prompt.responded_at).toLocaleString();
                const responsePreview = prompt.response.substring(0, 200) + (prompt.response.length > 200 ? '...' : '');
                
                return `
                    <div class="border border-gray-200 rounded-lg p-4 mb-4 bg-white">
                        <div class="flex justify-between items-start mb-3">
                            <div class="flex-1">
                                <h4 class="font-semibold text-gray-900 mb-2">${prompt.prompt}</h4>
                                <div class="text-sm text-gray-600 mb-2">
                                    <span class="font-medium">Model:</span> ${prompt.model_name || prompt.model_used || 'Unknown'} ‚Ä¢ 
                                    <span class="font-medium">Date:</span> ${respondedAt}
                                </div>
                            </div>
                            <button onclick="showFullPromptResponse(${index})" 
                                    class="ml-4 px-3 py-1 text-sm bg-purple-100 text-purple-700 rounded hover:bg-purple-200 transition-colors">
                                View Full
                            </button>
                        </div>
                        <div class="bg-gray-50 rounded p-3">
                            <div class="text-sm text-gray-700 font-mono whitespace-pre-wrap">${responsePreview}</div>
                        </div>
                    </div>
                `;
            }).join('');
            console.log('Generated history content:', historyContent);
        } else {
            console.log('No custom prompts found, showing empty state');
            historyContent = `
                <div class="text-center py-8 text-gray-500">
                    <div class="text-4xl mb-4">üìù</div>
                    <p class="text-lg font-medium mb-2">No Previous Prompts</p>
                    <p class="text-sm">You haven't asked any custom questions about this article yet.</p>
                </div>
            `;
        }
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-6">
                    <h3 class="text-xl font-bold text-gray-900">üìö Custom Prompt History</h3>
                    <div class="flex space-x-3">
                        <button onclick="showCustomPromptModal()" 
                                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-purple-600 hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-colors">
                            <span class="mr-2">üí¨</span>
                            Ask New Question
                        </button>
                        <button onclick="closeCustomPromptHistoryModal()" class="text-gray-400 hover:text-gray-600">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="max-h-96 overflow-y-auto">
                    ${historyContent}
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }
    
    function closeCustomPromptHistoryModal() {
        const modal = document.getElementById('customPromptHistoryModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function showFullPromptResponse(index) {
        const customPrompts = {{ article.article_metadata.get('custom_prompts', []) | tojson }};
        if (!customPrompts || !customPrompts[index]) {
            showNotification('Prompt not found', 'error');
            return;
        }
        
        const prompt = customPrompts[index];
        closeCustomPromptHistoryModal();
        showCustomResponseModal(prompt.response, prompt.prompt, {
            model_name: prompt.model_name || prompt.model_used,
            responded_at: prompt.responded_at
        });
    }
    
    
    // ChatGPT Summary Functions
    async function generateChatGPTSummary() {
        console.log('ChatGPT Summary button clicked!'); // Debug log
        
        // Check if we already have a summary
        const existingSummary = {{ article.article_metadata.get('chatgpt_summary', {}).get('summary', 'null') | tojson }};
        const existingModelName = {{ article.article_metadata.get('chatgpt_summary', {}).get('model_name', 'null') | tojson }};
        const existingSummarizedAt = {{ article.article_metadata.get('chatgpt_summary', {}).get('summarized_at', 'null') | tojson }};
        
        if (existingSummary && existingSummary !== 'null') {
            // Show existing summary
            console.log('Found existing summary, showing it...'); // Debug log
            showChatGPTSummaryModal(existingSummary, {
                model_name: existingModelName !== 'null' ? existingModelName : 'llama3.2:1b',
                model_used: 'ollama',
                summarized_at: existingSummarizedAt !== 'null' ? existingSummarizedAt : null,
                content_type: 'full content'
            });
            return;
        }
        
        // Get API key from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const aiModel = settings.aiModel || 'chatgpt';
        const apiKey = aiModel === 'anthropic' ? settings.anthropicApiKey : settings.openaiApiKey;
        
        if ((aiModel === 'chatgpt' || aiModel === 'anthropic') && !apiKey) {
            const keyType = aiModel === 'anthropic' ? 'Anthropic' : 'OpenAI';
            showNotification(`Please configure your ${keyType} API key in Settings first`, 'error');
            return;
        }
        
        // Show loading modal
        const loadingModal = document.createElement('div');
        loadingModal.id = 'loadingModal';
        loadingModal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        loadingModal.innerHTML = `
            <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-blue-100">
                        <svg class="h-6 w-6 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                    </div>
                    <h3 class="text-lg font-medium text-gray-900 mt-4">Generating ChatGPT Summary</h3>
                    <p class="text-sm text-gray-500 mt-2">This may take a few moments.</p>
                </div>
            </div>
        `;
        document.body.appendChild(loadingModal);
        
        try {
            console.log('Making API request to ChatGPT summary endpoint...'); // Debug log
            
            // Create a timeout promise - longer for LLM operations
            const timeoutPromise = new Promise((_, reject) => {
                const timeoutMs = aiModel === 'chatgpt' ? 180000 : 600000; // 180s for ChatGPT, 600s for LLM
                setTimeout(() => reject(new Error(`Request timed out after ${timeoutMs/1000} seconds`)), timeoutMs);
            });
            
            // Create the fetch promise
            const fetchPromise = fetch(`/api/articles/{{ article.id }}/chatgpt-summary`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    include_content: true,  // Set to false to send only URL
                    api_key: apiKey,  // Send API key from settings
                    ai_model: aiModel  // Send AI model setting
                })
            });
            
            // Race between fetch and timeout
            const response = await Promise.race([fetchPromise, timeoutPromise]);
            
            console.log('Response status:', response.status); // Debug log
            
            if (response.ok) {
                const data = await response.json();
                console.log('Success! Showing summary modal...'); // Debug log
                showChatGPTSummaryModal(data.summary, data);
            } else {
                const error = await response.json();
                console.error('API error:', error); // Debug log
                showNotification(`ChatGPT Summary failed: ${error.detail}`, 'error');
            }
        } catch (error) {
            console.error('JavaScript error:', error); // Debug log
            if (error.message.includes('timed out')) {
                const timeoutMsg = aiModel === 'chatgpt' ? '60 seconds' : '200 seconds';
                showNotification(`Summary timed out after ${timeoutMsg}. Try using metadata-only analysis or configure OpenAI API key for faster results.`, 'error');
            } else {
                showNotification(`Error: ${error.message}`, 'error');
            }
        } finally {
            // Remove loading modal
            const loadingModal = document.getElementById('loadingModal');
            if (loadingModal && loadingModal.parentNode) {
                loadingModal.remove();
            }
        }
    }
    
    function showChatGPTSummaryModal(summary, data = null) {
        console.log('showChatGPTSummaryModal called with:', summary, data);
        
        const modal = document.createElement('div');
        modal.id = 'chatGPTSummaryModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeChatGPTSummaryModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeChatGPTSummaryModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        const modelUsed = data?.model_name || 'gpt-4';
        const summarizedAt = data?.summarized_at ? new Date(data.summarized_at).toLocaleString() : 'Unknown';
        const contentType = data?.content_type || 'full content';
        
        // Determine modal title based on model used
        const isChatGPT = modelUsed.includes('gpt') || modelUsed.includes('chatgpt');
        const modalTitle = isChatGPT ? 'üìù ChatGPT Summary' : 'üìù AI Summary';
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gray-900">${modalTitle}</h3>
                    <button onclick="closeChatGPTSummaryModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-4 p-3 bg-gray-50 rounded-md">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                        <div>
                            <span class="font-medium text-gray-700">Model Used:</span>
                            <span class="text-gray-900">${modelUsed}</span>
                        </div>
                        <div>
                            <span class="font-medium text-gray-700">Summarized At:</span>
                            <span class="text-gray-900">${summarizedAt}</span>
                        </div>
                        <div>
                            <span class="font-medium text-gray-700">Content Type:</span>
                            <span class="text-gray-900">${contentType}</span>
                        </div>
                        <div>
                            <span class="font-medium text-gray-700">Status:</span>
                            <span class="text-gray-900">${data?.cached ? '<span class="text-blue-600 font-medium">(Cached)</span>' : '<span class="text-green-600 font-medium">(Fresh)</span>'}</span>
                        </div>
                        <div>
                            <span class="font-medium text-gray-700">Temperature:</span>
                            <span class="text-gray-900">${data?.temperature || '0.3'}</span>
                        </div>
                    </div>
                    
                    ${data?.optimization ? `
                    <div class="mt-3 p-3 bg-green-50 border border-green-200 rounded-md">
                        <div class="flex items-center mb-2">
                            <span class="text-green-600 font-medium">üöÄ Content Optimization Applied</span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-2 text-xs">
                            ${isChatGPT ? `
                            <div>
                                <span class="font-medium text-gray-700">Cost Savings:</span>
                                <span class="text-green-600 font-medium">$${data.optimization.cost_savings.toFixed(4)}</span>
                            </div>
                            ` : ''}
                            <div>
                                <span class="font-medium text-gray-700">Tokens Saved:</span>
                                <span class="text-green-600 font-medium">${data.optimization.tokens_saved.toLocaleString()}</span>
                            </div>
                            <div>
                                <span class="font-medium text-gray-700">Chunks Removed:</span>
                                <span class="text-green-600 font-medium">${data.optimization.chunks_removed}</span>
                            </div>
                        </div>
                    </div>
                    ` : ''}
                </div>
                
                <div class="bg-gray-50 rounded-lg p-4 max-h-96 overflow-y-auto">
                    <div class="prose max-w-none">
                        <pre class="whitespace-pre-wrap text-sm text-gray-800 font-mono">${summary}</pre>
                    </div>
                </div>
                
                <div class="mt-4 flex justify-end space-x-3">
                    <button onclick="regenerateChatGPTSummary()" 
                            class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors">
                        <span class="mr-2">üîÑ</span>
                        ${data?.cached ? 'Regenerate Summary' : 'Generate New Summary'}
                    </button>
                    <button onclick="closeChatGPTSummaryModal()" 
                            class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        console.log('ChatGPT Summary modal added to DOM:', modal);
    }
    
    function closeChatGPTSummaryModal() {
        const modal = document.getElementById('chatGPTSummaryModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function showSigmaRulesModal(sigmaRules, data) {
        // Remove any existing modal
        closeSigmaRulesModal();
        
        const modal = document.createElement('div');
        modal.id = 'sigmaRulesModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeSigmaRulesModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeSigmaRulesModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        const modelUsed = data?.model_name || 'gpt-4';
        const generatedAt = data?.generated_at ? new Date(data.generated_at).toLocaleString() : 'Unknown';
        const validationResults = data?.validation_results || [];
        const failureError = data?.error || null;
        const hasFailure = (sigmaRules === null || sigmaRules === 'null') && failureError;
        
        // Build error banner if there was a failure
        let errorBannerHtml = '';
        if (hasFailure) {
            errorBannerHtml = `
                <div class="mb-4 p-4 bg-red-50 border-2 border-red-300 rounded-lg">
                    <div class="flex items-start">
                        <span class="text-2xl mr-3">‚ö†Ô∏è</span>
                        <div class="flex-1">
                            <h4 class="font-bold text-red-900 mb-2">SIGMA Generation Failed</h4>
                            <p class="text-sm text-red-800 mb-2">${failureError}</p>
                            <p class="text-xs text-red-700">The conversation log below shows what was attempted before the failure. Click "Regenerate" to try again.</p>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Build validation status display
        let validationStatusHtml = '';
        if (validationResults.length > 0) {
            validationStatusHtml = '<div class="mb-4 p-3 bg-gray-50 rounded-lg">';
            validationStatusHtml += '<h4 class="font-medium text-gray-900 mb-2">üîç Validation Results</h4>';
            
            validationResults.forEach((result, index) => {
                const statusIcon = result.is_valid ? '‚úÖ' : '‚ùå';
                const statusColor = result.is_valid ? 'text-green-600' : 'text-red-600';
                const statusText = result.is_valid ? 'Valid' : 'Invalid';
                
                validationStatusHtml += `<div class="mb-2 p-2 border rounded ${result.is_valid ? 'border-green-200 bg-green-50' : 'border-red-200 bg-red-50'}">`;
                validationStatusHtml += `<div class="flex items-center mb-1">`;
                validationStatusHtml += `<span class="mr-2">${statusIcon}</span>`;
                validationStatusHtml += `<span class="font-medium ${statusColor}">Rule ${result.rule_index}: ${statusText}</span>`;
                validationStatusHtml += `</div>`;
                
                if (result.errors && result.errors.length > 0) {
                    validationStatusHtml += `<div class="text-sm text-red-600 mb-1">`;
                    validationStatusHtml += `<strong>Errors:</strong><ul class="list-disc list-inside ml-2">`;
                    result.errors.forEach(error => {
                        validationStatusHtml += `<li>${error}</li>`;
                    });
                    validationStatusHtml += `</ul></div>`;
                }
                
                if (result.warnings && result.warnings.length > 0) {
                    validationStatusHtml += `<div class="text-sm text-yellow-600 mb-1">`;
                    validationStatusHtml += `<strong>Warnings:</strong><ul class="list-disc list-inside ml-2">`;
                    result.warnings.forEach(warning => {
                        validationStatusHtml += `<li>${warning}</li>`;
                    });
                    validationStatusHtml += `</ul></div>`;
                }
                
                if (result.rule_info) {
                    validationStatusHtml += `<div class="text-sm text-gray-600">`;
                    validationStatusHtml += `<strong>Rule Info:</strong> ${result.rule_info.title || 'Untitled'} `;
                    if (result.rule_info.level) {
                        validationStatusHtml += `(${result.rule_info.level})`;
                    }
                    validationStatusHtml += `</div>`;
                }
                
                validationStatusHtml += `</div>`;
            });
            
            validationStatusHtml += '</div>';
        }
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-6xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium text-gray-900">üîç SIGMA Detection Rules</h3>
                    <button onclick="closeSigmaRulesModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-4 text-sm text-gray-600">
                    <span class="font-medium">Generated by:</span> ${modelUsed} | 
                    <span class="font-medium">Generated at:</span> ${generatedAt} |
                    <span class="font-medium">Temperature:</span> ${data?.temperature || '0.2'}
                    ${data?.cached ? ' | <span class="font-medium text-blue-600">(Cached)</span>' : ''}
                </div>
                
                ${data?.optimization ? `
                <div class="mb-4 p-3 bg-green-50 border border-green-200 rounded-md">
                    <div class="flex items-center mb-2">
                        <span class="text-green-600 font-medium">üöÄ Content Optimization Applied</span>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-2 text-xs">
                        ${modelUsed.includes('gpt') || modelUsed.includes('chatgpt') ? `
                        <div>
                            <span class="font-medium text-gray-700">Cost Savings:</span>
                            <span class="text-green-600 font-medium">$${data.optimization.cost_savings.toFixed(4)}</span>
                        </div>
                        ` : ''}
                        <div>
                            <span class="font-medium text-gray-700">Tokens Saved:</span>
                            <span class="text-green-600 font-medium">${data.optimization.tokens_saved.toLocaleString()}</span>
                        </div>
                        <div>
                            <span class="font-medium text-gray-700">Chunks Removed:</span>
                            <span class="text-green-600 font-medium">${data.optimization.chunks_removed}</span>
                        </div>
                    </div>
                </div>
                ` : ''}
                
                ${errorBannerHtml}
                ${validationStatusHtml}

                <div class="mt-4">
                    <h4 class="text-md font-medium text-gray-900 mb-2">üîÑ LLM ‚Üî pySigma Conversation Log</h4>
                    <div class="text-xs text-gray-600 mb-2">Shows the iterative validation process between the LLM and pySigma validator</div>
                    <div id="sigmaConversation" class="space-y-4 max-h-96 overflow-y-auto p-4 bg-gray-50 rounded border">
                        <!-- Filled by script below -->
                    </div>
                </div>

                ${hasFailure ? '' : '<div class="bg-gray-50 p-4 rounded-lg max-h-96 overflow-y-auto"><pre class="text-sm font-mono whitespace-pre-wrap text-gray-800">' + sigmaRules + '</pre></div>'}
                
                <div class="mt-4 flex justify-between">
                    <button onclick="regenerateSigmaRules()" 
                            class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors">
                        üîÑ Regenerate
                    </button>
                    <button onclick="closeSigmaRulesModal()" 
                            class="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);

        // Render conversation entries if present
        try {
            const convo = (data && data.conversation) ? data.conversation : [];
            const container = document.getElementById('sigmaConversation');
            if (container) {
                if (!convo.length) {
                    container.innerHTML = '<div class="text-sm text-gray-600 text-center py-4">‚ö†Ô∏è No conversation log available. This might be cached data from an older version.</div>';
                } else {
                    container.innerHTML = convo.map((entry, idx) => {
                        const attempt = entry.attempt || 0;
                        const attemptBadgeColor = idx === convo.length - 1 ? 'bg-green-500' : 'bg-blue-500';
                        const attemptIcon = idx === convo.length - 1 ? '‚úÖ' : 'üîÑ';
                        
                        // Format messages (system + user prompts)
                        const msgHtml = (entry.messages || []).map((m, i) => {
                            const role = m.role || 'user';
                            const content = (m.content || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            const roleIcon = role === 'system' ? '‚öôÔ∏è' : 'üë§';
                            const roleColor = role === 'system' ? 'text-purple-700' : 'text-blue-700';
                            const preview = content.substring(0, 100) + (content.length > 100 ? '...' : '');
                            const collapsibleId = 'msg-' + idx + '-' + i;
                            
                            return '<div class="mb-2">' +
                                '<div class="flex items-center mb-1">' +
                                    '<span class="mr-2">' + roleIcon + '</span>' +
                                    '<span class="font-semibold ' + roleColor + ' text-sm uppercase">' + role + '</span>' +
                                    '<button onclick="toggleCollapse(\'' + collapsibleId + '\')" class="ml-2 text-xs text-blue-600 hover:text-blue-800 underline">' +
                                        '[toggle full content]' +
                                    '</button>' +
                                '</div>' +
                                '<div class="bg-gray-100 p-2 rounded border border-gray-300">' +
                                    '<div id="' + collapsibleId + '-preview" class="text-xs text-gray-700">' + preview + '</div>' +
                                    '<pre id="' + collapsibleId + '-full" class="text-xs whitespace-pre-wrap text-gray-800 hidden">' + content + '</pre>' +
                                '</div>' +
                            '</div>';
                        }).join('');
                        
                        // Format LLM response
                        const llm = (entry.llm_response || 'No response').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        const llmPreview = llm.substring(0, 200) + (llm.length > 200 ? '...' : '');
                        const llmCollapsibleId = 'llm-' + idx;
                        
                        // Format validation results
                        const val = entry.validation || [];
                        const hasErrors = val.some(v => !v.is_valid);
                        const validationIcon = hasErrors ? '‚ùå' : '‚úÖ';
                        const validationColor = hasErrors ? 'text-red-700' : 'text-green-700';
                        
                        const valHtml = val.length > 0 ? val.map(v => {
                            const errs = (v.errors || []).map(e => '<li class="text-red-700 text-xs">' + e.replace(/</g,'&lt;').replace(/>/g,'&gt;') + '</li>').join('');
                            const warns = (v.warnings || []).map(w => '<li class="text-yellow-700 text-xs">' + w.replace(/</g,'&lt;').replace(/>/g,'&gt;') + '</li>').join('');
                            const statusBadge = v.is_valid 
                                ? '<span class="px-2 py-1 text-xs bg-green-100 text-green-800 rounded">‚úÖ VALID</span>'
                                : '<span class="px-2 py-1 text-xs bg-red-100 text-red-800 rounded">‚ùå INVALID</span>';
                            const borderClass = v.is_valid ? 'border-green-300' : 'border-red-300';
                            const ruleIndex = v.rule_index || '?';
                            const ruleInfoHtml = (v.rule_info && v.rule_info.title) ? '<div class="text-xs text-gray-600 mt-2">Rule: ' + v.rule_info.title + '</div>' : '';
                            const errsHtml = errs ? '<div class="mt-2"><strong class="text-sm text-red-800">Errors:</strong><ul class="list-disc ml-5 mt-1">' + errs + '</ul></div>' : '';
                            const warnsHtml = warns ? '<div class="mt-2"><strong class="text-sm text-yellow-800">Warnings:</strong><ul class="list-disc ml-5 mt-1">' + warns + '</ul></div>' : '';
                            
                            return '<div class="mb-3 p-3 bg-white border ' + borderClass + ' rounded">' +
                                '<div class="flex items-center justify-between mb-2">' +
                                    '<span class="font-semibold text-sm">Rule #' + ruleIndex + '</span>' +
                                    statusBadge +
                                '</div>' +
                                errsHtml +
                                warnsHtml +
                                ruleInfoHtml +
                            '</div>';
                        }).join('') : '<div class="text-sm text-gray-600 italic">No validation performed</div>';
                        
                        // Build attempt card
                        const borderClass = (hasErrors && idx < convo.length - 1) ? 'border-red-300' : 'border-green-300';
                        const bgGradient = (hasErrors && idx < convo.length - 1) ? 'from-red-50 to-red-100' : 'from-green-50 to-green-100';
                        const attemptBadgeText = (idx === convo.length - 1) ? 'FINAL' : 'RETRY';
                        const validationBorderClass = hasErrors ? 'border-red-500' : 'border-green-500';
                        const errorHtml = entry.error ? 
                            '<div class="border-l-4 border-red-500 pl-3 mt-3">' +
                                '<div class="text-sm text-red-700">' +
                                    '<strong>‚ö†Ô∏è Error:</strong> ' + entry.error.replace(/</g,'&lt;').replace(/>/g,'&gt;') +
                                '</div>' +
                            '</div>' : '';
                        
                        return '<div class="bg-white border-2 ' + borderClass + ' rounded-lg shadow-sm">' +
                            '<div class="bg-gradient-to-r ' + bgGradient + ' p-3 rounded-t-lg border-b">' +
                                '<div class="flex items-center justify-between">' +
                                    '<div class="flex items-center">' +
                                        '<span class="text-xl mr-2">' + attemptIcon + '</span>' +
                                        '<span class="font-bold text-gray-900">Attempt #' + attempt + '</span>' +
                                    '</div>' +
                                    '<span class="' + attemptBadgeColor + ' text-white px-3 py-1 rounded-full text-xs font-bold">' +
                                        attemptBadgeText +
                                    '</span>' +
                                '</div>' +
                            '</div>' +
                            '<div class="p-4 space-y-4">' +
                                '<!-- Prompts Section -->' +
                                '<div class="border-l-4 border-blue-500 pl-3">' +
                                    '<div class="font-semibold text-sm text-gray-700 mb-2">üìù Prompts Sent to LLM</div>' +
                                    msgHtml +
                                '</div>' +
                                '' +
                                '<!-- LLM Response Section -->' +
                                '<div class="border-l-4 border-purple-500 pl-3">' +
                                    '<div class="flex items-center mb-2">' +
                                        '<span class="mr-2">ü§ñ</span>' +
                                        '<span class="font-semibold text-sm text-gray-700">LLM Response</span>' +
                                        '<button onclick="toggleCollapse(\'' + llmCollapsibleId + '\')" class="ml-2 text-xs text-blue-600 hover:text-blue-800 underline">' +
                                            '[toggle full response]' +
                                        '</button>' +
                                    '</div>' +
                                    '<div class="bg-purple-50 p-3 rounded border border-purple-200">' +
                                        '<div id="' + llmCollapsibleId + '-preview" class="text-xs text-gray-700">' + llmPreview + '</div>' +
                                        '<pre id="' + llmCollapsibleId + '-full" class="text-xs whitespace-pre-wrap text-gray-800 hidden">' + llm + '</pre>' +
                                    '</div>' +
                                '</div>' +
                                '' +
                                '<!-- Validation Section -->' +
                                '<div class="border-l-4 ' + validationBorderClass + ' pl-3">' +
                                    '<div class="flex items-center mb-2">' +
                                        '<span class="mr-2">' + validationIcon + '</span>' +
                                        '<span class="font-semibold text-sm ' + validationColor + '">pySigma Validation</span>' +
                                    '</div>' +
                                    '<div class="space-y-2">' +
                                        valHtml +
                                    '</div>' +
                                '</div>' +
                                '' +
                                errorHtml +
                            '</div>' +
                        '</div>';
                    }).join('');
                }
            }
        } catch (e) {
            console.error('Failed to render sigma conversation', e);
            container.innerHTML = '<div class="text-sm text-red-600">Error rendering conversation log. Check console for details.</div>';
        }
    }
    
    // Helper function to toggle collapsible sections
    function toggleCollapse(id) {
        const preview = document.getElementById(id + '-preview');
        const full = document.getElementById(id + '-full');
        if (preview && full) {
            preview.classList.toggle('hidden');
            full.classList.toggle('hidden');
        }
    }
    
    function closeSigmaRulesModal() {
        const modal = document.getElementById('sigmaRulesModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function showIOCsModal(iocsJson, data) {
        // Remove any existing modal
        closeIOCsModal();
        
        const modal = document.createElement('div');
        modal.id = 'iocsModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeIOCsModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeIOCsModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        const modelUsed = data?.model_name || 'gpt-4';
        const extractedAt = data?.extracted_at ? new Date(data.extracted_at).toLocaleString() : 'Unknown';
        
        // Try to parse the JSON for better display
        let iocsData = {};
        let jsonError = null;
        try {
            // If iocsJson is already an array, use it directly
            if (Array.isArray(iocsJson)) {
                iocsData = iocsJson;
            } else {
                // Try to extract JSON from the response if it contains text before JSON
                let jsonText = iocsJson.trim();
                
                // If the response starts with text, try to find JSON within it
                if (!jsonText.startsWith('{') && !jsonText.startsWith('[')) {
                    const jsonMatch = jsonText.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
                    if (jsonMatch) {
                        jsonText = jsonMatch[0];
                    }
                }
                
                iocsData = JSON.parse(jsonText);
            }
        } catch (e) {
            jsonError = e.message;
        }
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-6xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium text-gray-900">üîç Extracted IOCs</h3>
                    <button onclick="closeIOCsModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-4 text-sm text-gray-600">
                    <span class="font-medium">Generated by:</span> ${modelUsed}${data?.llm_validation_used ? ' (LLM Validated)' : ''} | 
                    <span class="font-medium">Extracted at:</span> ${extractedAt}
                    ${data?.cached ? ' | <span class="font-medium text-blue-600">(Cached)</span>' : ''}
                </div>
                
                ${jsonError ? `
                <div class="bg-red-50 p-4 rounded-lg mb-4">
                    <div class="text-red-800">
                        <strong>JSON Parse Error:</strong> ${jsonError}
                    </div>
                    <div class="mt-2">
                        <strong>Raw Response:</strong>
                        <pre class="text-sm mt-1 bg-gray-100 p-2 rounded overflow-x-auto">${iocsJson}</pre>
                    </div>
                </div>
                ` : `
                <div class="bg-gray-50 p-4 rounded-lg max-h-96 overflow-y-auto">
                    ${Array.isArray(iocsData) ? `
                    <div class="space-y-3">
                        <div class="text-sm text-gray-600 mb-2">
                            <strong>Total IOCs found:</strong> ${iocsData.length}
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            ${iocsData.map(ioc => `
                            <div class="bg-white p-3 rounded border">
                                <div class="flex justify-between items-start mb-2">
                                    <span class="inline-block px-2 py-1 text-xs font-medium bg-blue-100 text-blue-800 rounded capitalize">${ioc.type}</span>
                                    <span class="text-xs text-gray-500">${(ioc.confidence * 100).toFixed(0)}%</span>
                                </div>
                                <div class="font-mono text-sm text-gray-900 break-all">${ioc.value}</div>
                                ${ioc.context ? `<div class="text-xs text-gray-600 mt-1 italic">${ioc.context.substring(0, 100)}${ioc.context.length > 100 ? '...' : ''}</div>` : ''}
                            </div>
                            `).join('')}
                        </div>
                    </div>
                    ` : `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        ${Object.entries(iocsData).map(([category, items]) => `
                        <div class="bg-white p-3 rounded border">
                            <h4 class="font-medium text-gray-900 mb-2 capitalize">${category.replace(/_/g, ' ')}</h4>
                            ${items && items.length > 0 ? `
                            <ul class="text-sm text-gray-700 space-y-1">
                                ${items.map(item => `<li class="font-mono text-xs bg-gray-50 px-2 py-1 rounded">${item}</li>`).join('')}
                            </ul>
                            ` : '<p class="text-gray-500 text-sm">No items found</p>'}
                        </div>
                        `).join('')}
                    </div>
                    `}
                </div>
                `}
                
                <div class="mt-4 flex justify-between items-center">
                    <div class="flex items-center space-x-4">
                        <label class="flex items-center">
                            <input type="checkbox" id="llmValidationToggle" class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50" ${data?.llm_validation_used ? 'checked' : ''}>
                            <span class="ml-2 text-sm text-gray-700">Use LLM Validation</span>
                            <div class="relative group ml-1">
                                <svg class="w-4 h-4 text-gray-400 hover:text-gray-600 cursor-help" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                                <div class="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 text-white text-xs rounded-lg opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-50" style="width: 280px; white-space: normal;">
                                    <div>
                                        <strong>LLM Validation:</strong> Uses AI to validate and categorize IOCs, removing false positives and improving accuracy. Requires API key.
                                    </div>
                                    <div class="absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-gray-900"></div>
                                </div>
                            </div>
                        </label>
                        <button onclick="regenerateIOCs()" 
                                class="px-4 py-2 bg-orange-600 text-white rounded-md hover:bg-orange-700 transition-colors">
                            üîÑ Regenerate
                        </button>
                    </div>
                    <button onclick="closeIOCsModal()" 
                            class="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
    }
    
    function closeIOCsModal() {
        const modal = document.getElementById('iocsModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function showGPT4oRankingModal(analysis, data) {
        // Remove any existing modal
        closeGPT4oRankingModal();
        
        const modal = document.createElement('div');
        modal.id = 'gpt4oRankingModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeGPT4oRankingModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeGPT4oRankingModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        // Format the analysis for display
        const formattedAnalysis = analysis.replace(/\n/g, '<br>');
        
        modal.innerHTML = `
            <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-6xl shadow-lg rounded-md bg-white">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium text-gray-900">üìä ${data && (data.model_name || data.model) ? (() => {
                        const model = data.model_name || data.model;
                        if (model.includes('claude')) return 'CLAUDE';
                        if (model.includes('gpt')) return 'GPT-4O';
                        return model.toUpperCase();
                    })() : 'GPT-4O'} SIGMA Huntability Analysis</h3>
                    <button onclick="closeGPT4oRankingModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="mb-4">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <div class="text-sm text-blue-800 whitespace-pre-wrap">${formattedAnalysis}</div>
                    </div>
                </div>
                
                ${data ? `
                <div class="mt-4 text-xs text-gray-500">
                    <div class="flex justify-between">
                        <span>Generated: ${data.analyzed_at ? new Date(data.analyzed_at).toLocaleString() : 'Unknown'}</span>
                        <span>Model: ${data.model_name || data.model || 'gpt-4o'}</span>
                    </div>
                </div>
                ` : ''}
                
                <div class="mt-6 flex justify-between">
                    <button onclick="regenerateGPT4oRanking()" 
                            class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
                        üîÑ Regenerate Analysis
                    </button>
                    <button onclick="closeGPT4oRankingModal()" 
                            class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
    }
    
    function closeGPT4oRankingModal() {
        const modal = document.getElementById('gpt4oRankingModal');
        if (modal) {
            modal.remove();
        }
    }
    
    function regenerateSigmaRules() {
        // Close current modal
        closeSigmaRulesModal();
        
        // Call generateAIAnalysis with force regeneration
        generateAIAnalysis('sigma', true);
    }
    
    function regenerateChatGPTSummary() {
        // Close current modal
        closeChatGPTSummaryModal();
        
        // Call generateAIAnalysis with force regeneration
        generateAIAnalysis('summary', true);
    }
    
    function regenerateIOCs() {
        // Get LLM validation setting from checkbox
        const llmValidationToggle = document.getElementById('llmValidationToggle');
        const useLLMValidation = llmValidationToggle ? llmValidationToggle.checked : false;
        
        // Close current modal
        closeIOCsModal();
        
        // Call generateAIAnalysis with force regeneration and LLM validation setting
        generateAIAnalysis('iocs', true, useLLMValidation);
    }
    
    function regenerateGPT4oRanking() {
        // Close current modal
        closeGPT4oRankingModal();
        
        // Call generateAIAnalysis with force regeneration
        generateAIAnalysis('ranking', true);
    }
    
    // Text annotation system now handled by LayeredTextManager
    
    // Delete article function
    function deleteArticle(articleId) {
        if (confirm('Are you sure you want to delete this article? This action cannot be undone and will also delete all annotations for this article.')) {
            fetch(`/api/articles/${articleId}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Article deleted successfully!');
                    // Redirect to articles page
                    window.location.href = '/articles';
                } else {
                    alert('Failed to delete article: ' + (data.message || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Failed to delete article: ' + error.message);
            });
        }
    }
    
    // Check for pending completion notifications from other pages
    function checkPendingCompletions() {
        const pendingCompletions = JSON.parse(localStorage.getItem('pendingCompletions') || '[]');
        
        pendingCompletions.forEach(completion => {
            // Show completion banner
            showCompletionBanner(completion.type, completion.typeText, completion.typeIcon, completion.articleId, completion.articleTitle);
        });
        
        // Clear pending completions after showing them
        localStorage.removeItem('pendingCompletions');
    }
    
    // Handle URL fragments to auto-open results
    console.log('Setting up URL fragment handler...');
    
    function processUrlHash() {
        console.log('Processing URL hash...');
        
        const hash = window.location.hash.substring(1); // Remove the #
        console.log('URL hash:', hash);
        
        if (hash === 'summary') {
            console.log('Processing summary hash...');
            // Check if summary exists and show it
            const hasSummary = {{ 'true' if article.article_metadata and article.article_metadata.get('chatgpt_summary') else 'false' }};
            console.log('Has summary:', hasSummary);
            if (hasSummary) {
                const summaryData = {{ article.article_metadata.get('chatgpt_summary') | tojson if article.article_metadata and article.article_metadata.get('chatgpt_summary') else 'null' }};
                console.log('Summary data:', summaryData);
                if (summaryData) {
                    console.log('Auto-opening summary modal from URL fragment');
                    setTimeout(() => {
                        console.log('About to call showChatGPTSummaryModal');
                        showChatGPTSummaryModal(summaryData.summary, summaryData);
                    }, 500);
                }
            } else {
                console.log('No summary found for this article');
            }
        } else if (hash === 'sigma') {
            console.log('Processing sigma hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasSigmaRules = {{ 'true' if article.article_metadata and article.article_metadata.get('sigma_rules') else 'false' }};
                console.log('Has sigma rules (template):', hasSigmaRules);
                
                if (hasSigmaRules) {
                    const sigmaData = {{ article.article_metadata.get('sigma_rules') | tojson if article.article_metadata and article.article_metadata.get('sigma_rules') else 'null' }};
                    console.log('Sigma data (template):', sigmaData);
                    
                    if (sigmaData) {
                        console.log('Auto-opening SIGMA modal from URL fragment (template)');
                        setTimeout(() => showSigmaRulesModal(sigmaData.rules, sigmaData), 500);
                    }
                } else {
                    console.log('No SIGMA rules found in template data');
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching SIGMA data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for SIGMA:', data);
                        if (data.article_metadata && data.article_metadata.sigma_rules) {
                            console.log('Auto-opening SIGMA modal from URL fragment (API)');
                            setTimeout(() => showSigmaRulesModal(data.article_metadata.sigma_rules.rules, data.article_metadata.sigma_rules), 500);
                        } else {
                            console.log('No SIGMA rules found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for sigma:', error);
                    });
            }
        } else if (hash === 'iocs') {
            console.log('Processing iocs hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasIOCs = {{ 'true' if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'false' }};
                console.log('Has iocs (template):', hasIOCs);
                
                if (hasIOCs) {
                    const iocData = {{ article.article_metadata.get('extracted_iocs') | tojson if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'null' }};
                    console.log('IOCs data (template):', iocData);
                    
                    if (iocData) {
                        console.log('Auto-opening IOCs modal from URL fragment (template)');
                        setTimeout(() => showIOCsModal(JSON.stringify(iocData.iocs, null, 2), iocData), 500);
                    }
                } else {
                    console.log('No IOCs found in template data');
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching IOCs data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for IOCs:', data);
                        if (data.article_metadata && data.article_metadata.extracted_iocs) {
                            console.log('Auto-opening IOCs modal from URL fragment (API)');
                            setTimeout(() => showIOCsModal(JSON.stringify(data.article_metadata.extracted_iocs.iocs, null, 2), data.article_metadata.extracted_iocs), 500);
                        } else {
                            console.log('No IOCs found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for IOCs:', error);
                    });
            }
        } else if (hash === 'ranking') {
            console.log('Processing ranking hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasRanking = {{ 'true' if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'false' }};
                console.log('Has ranking (template):', hasRanking);
                
                if (hasRanking) {
                    const rankingData = {{ article.article_metadata.get('gpt4o_ranking') | tojson if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'null' }};
                    console.log('Ranking data (template):', rankingData);
                    
                    if (rankingData && rankingData.analysis) {
                        console.log('Auto-opening GPT4o ranking from URL fragment (template)');
                        setTimeout(() => {
                            showGPT4oRankingModal(rankingData.analysis, rankingData);
                        }, 500);
                    }
                } else {
                    console.log('No ranking found in template data');
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching ranking data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for ranking:', data);
                        if (data.article_metadata && data.article_metadata.gpt4o_ranking && data.article_metadata.gpt4o_ranking.analysis) {
                            console.log('Auto-opening GPT4o ranking from URL fragment (API)');
                            setTimeout(() => {
                                showGPT4oRankingModal(data.article_metadata.gpt4o_ranking.analysis, data.article_metadata.gpt4o_ranking);
                            }, 500);
                        } else {
                            console.log('No ranking found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for ranking:', error);
                    });
            }
        }
        
        // Clear the hash from URL after handling (with delay to allow modal to open)
        if (hash) {
            console.log('Clearing URL hash:', hash);
            setTimeout(() => {
                window.history.replaceState(null, null, window.location.pathname);
            }, 1000);
        }
    }
    
    // Set up event listeners for URL hash changes
    window.addEventListener('load', function() {
        console.log('Page loaded, checking URL fragments...');
        checkPendingCompletions();
        processUrlHash();
    });
    
    window.addEventListener('hashchange', function() {
        console.log('URL hash changed');
        processUrlHash();
    });

    // Handle URL fragments to auto-open results
    console.log('Setting up URL fragment handler...');
    window.addEventListener('load', function() {
        console.log('Page loaded, checking URL fragments...');
        
        // Check for pending completions first
        checkPendingCompletions();
        
        const hash = window.location.hash.substring(1); // Remove the #
        console.log('URL hash:', hash);
        
        if (hash === 'summary') {
            console.log('Processing summary hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            console.log('Current article ID:', currentArticleId);
            
            // Check if this is the same article as the template context
            const templateArticleId = {{ article.id }};
            console.log('Template article ID:', templateArticleId);
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasSummary = {{ 'true' if article.article_metadata and article.article_metadata.get('chatgpt_summary') else 'false' }};
                console.log('Has summary (template):', hasSummary);
                
                if (hasSummary) {
                    const summaryData = {{ article.article_metadata.get('chatgpt_summary') | tojson if article.article_metadata and article.article_metadata.get('chatgpt_summary') else 'null' }};
                    console.log('Summary data (template):', summaryData);
                    
                    if (summaryData) {
                        console.log('Auto-opening summary modal from URL fragment (template)');
                        setTimeout(() => showChatGPTSummaryModal(summaryData.summary, summaryData), 500);
                    }
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching summary data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data:', data);
                        if (data.metadata && data.metadata.chatgpt_summary) {
                            console.log('Auto-opening summary modal from URL fragment (API)');
                            setTimeout(() => showChatGPTSummaryModal(data.metadata.chatgpt_summary.summary, data.metadata.chatgpt_summary), 500);
                        } else {
                            console.log('No summary data found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data:', error);
                    });
            }
        } else if (hash === 'sigma') {
            console.log('Processing sigma hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasSigma = {{ 'true' if article.article_metadata and article.article_metadata.get('sigma_rules') else 'false' }};
                console.log('Has sigma (template):', hasSigma);
                
                if (hasSigma) {
                    const sigmaData = {{ article.article_metadata.get('sigma_rules') | tojson if article.article_metadata and article.article_metadata.get('sigma_rules') else 'null' }};
                    console.log('Sigma data (template):', sigmaData);
                    
                    if (sigmaData) {
                        console.log('Auto-opening sigma modal from URL fragment (template)');
                        setTimeout(() => showSigmaModal(sigmaData.rules, sigmaData), 500);
                    }
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching sigma data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for sigma:', data);
                        if (data.metadata && data.metadata.sigma_rules) {
                            console.log('Auto-opening sigma modal from URL fragment (API)');
                            setTimeout(() => showSigmaModal(data.metadata.sigma_rules.rules, data.metadata.sigma_rules), 500);
                        } else {
                            console.log('No sigma data found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for sigma:', error);
                    });
            }
        } else if (hash === 'iocs') {
            console.log('Processing iocs hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasIOCs = {{ 'true' if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'false' }};
                console.log('Has iocs (template):', hasIOCs);
                
                if (hasIOCs) {
                    const iocData = {{ article.article_metadata.get('extracted_iocs') | tojson if article.article_metadata and article.article_metadata.get('extracted_iocs') else 'null' }};
                    console.log('IOCs data (template):', iocData);
                    
                    if (iocData) {
                        console.log('Auto-opening IOCs modal from URL fragment (template)');
                        setTimeout(() => showIOCsModal(JSON.stringify(iocData.iocs, null, 2), iocData), 500);
                    }
                } else {
                    console.log('No IOCs found in template data');
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching IOCs data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for IOCs:', data);
                        if (data.article_metadata && data.article_metadata.extracted_iocs) {
                            console.log('Auto-opening IOCs modal from URL fragment (API)');
                            setTimeout(() => showIOCsModal(JSON.stringify(data.article_metadata.extracted_iocs.iocs, null, 2), data.article_metadata.extracted_iocs), 500);
                        } else {
                            console.log('No IOCs found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for IOCs:', error);
                    });
            }
        } else if (hash === 'ranking') {
            console.log('Processing ranking hash...');
            
            // Get current article ID from URL
            const currentArticleId = window.location.pathname.split('/').pop();
            const templateArticleId = {{ article.id }};
            
            if (currentArticleId == templateArticleId) {
                // Same article - use template data
                const hasRanking = {{ 'true' if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'false' }};
                console.log('Has ranking (template):', hasRanking);
                
                if (hasRanking) {
                    const rankingData = {{ article.article_metadata.get('gpt4o_ranking') | tojson if article.article_metadata and article.article_metadata.get('gpt4o_ranking') else 'null' }};
                    console.log('Ranking data (template):', rankingData);
                    
                    if (rankingData && rankingData.analysis) {
                        console.log('Auto-opening GPT4o ranking from URL fragment (template)');
                        setTimeout(() => {
                            showGPT4oRankingModal(rankingData.analysis, rankingData);
                        }, 500);
                    }
                } else {
                    console.log('No ranking found in template data');
                }
            } else {
                // Different article - fetch data via API
                console.log('Different article, fetching ranking data via API...');
                fetch(`/api/articles/${currentArticleId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Fetched article data for ranking:', data);
                        if (data.article_metadata && data.article_metadata.gpt4o_ranking && data.article_metadata.gpt4o_ranking.analysis) {
                            console.log('Auto-opening GPT4o ranking from URL fragment (API)');
                            setTimeout(() => {
                                showGPT4oRankingModal(data.article_metadata.gpt4o_ranking.analysis, data.article_metadata.gpt4o_ranking);
                            }, 500);
                        } else {
                            console.log('No ranking found for this article');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching article data for ranking:', error);
                    });
            }
        }
        
        // Clear the hash from URL after handling (with delay to allow modal to open)
        if (hash) {
            console.log('Clearing URL hash:', hash);
            setTimeout(() => {
                window.history.replaceState(null, null, window.location.pathname);
            }, 1000);
        }
    });
    
    // Chunk Debug Modal Functions
    async function showChunkDebugModal() {
        closeAIAssistantModal();
        
        // Show loading modal
        const loadingModal = document.createElement('div');
        loadingModal.id = 'chunkDebugLoadingModal';
        loadingModal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        loadingModal.innerHTML = `
            <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-blue-100">
                        <svg class="animate-spin h-6 w-6 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <h3 class="text-lg font-medium text-gray-900 mt-4">Analyzing Chunks</h3>
                    <p class="text-sm text-gray-500 mt-2">Processing article content and analyzing chunking decisions...</p>
                </div>
            </div>
        `;
        document.body.appendChild(loadingModal);
        
        try {
            // Get chunk debug data with current threshold
            const currentThreshold = window.chunkDebugThreshold || 0.7;
            const response = await fetch(`/api/articles/{{ article.id }}/chunk-debug?chunk_size=1000&overlap=200&min_confidence=${currentThreshold}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const debugData = await response.json();
            
            // Remove loading modal
            if (loadingModal && loadingModal.parentNode) {
                loadingModal.remove();
            }
            
            // Show chunk debug modal
            showChunkDebugResults(debugData);
            
        } catch (error) {
            console.error('Chunk debug error:', error);
            loadingModal.remove();
            showNotification('Failed to load chunk debug data: ' + error.message, 'error');
        }
    }
    
    function showChunkDebugResults(data) {
        // Create modal
        const modal = document.createElement('div');
        modal.id = 'chunkDebugModal';
        modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
        
        // Add click outside to close
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeChunkDebugModal();
            }
        });
        
        // Add ESC key to close
        const handleEsc = function(e) {
            if (e.key === 'Escape') {
                closeChunkDebugModal();
                document.removeEventListener('keydown', handleEsc);
            }
        };
        document.addEventListener('keydown', handleEsc);
        
        // Generate chunk visualization
        const chunkVisualization = generateChunkVisualization(data);
        
        modal.innerHTML = `
            <div class="relative top-4 mx-auto p-6 border w-11/12 max-w-7xl shadow-lg rounded-md bg-white max-h-[90vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-6">
                    <h3 class="text-2xl font-bold text-gray-900">üîç Chunk Debug Analysis</h3>
                    <button onclick="closeChunkDebugModal()" class="text-gray-400 hover:text-gray-600">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <!-- Threshold Selector -->
                <div class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                    <div class="flex items-center justify-between">
                        <div>
                            <h4 class="text-lg font-semibold text-blue-900 mb-2">üéØ Confidence Threshold</h4>
                            <p class="text-sm text-blue-700">Adjust the minimum confidence required to keep chunks</p>
                        </div>
                        <div class="flex items-center space-x-4">
                            <label for="thresholdSlider" class="text-sm font-medium text-blue-900">Threshold:</label>
                            <input type="range" id="thresholdSlider" min="0" max="2" step="1" value="1" 
                                   class="w-32 h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer"
                                   onchange="updateThresholdFromSlider(this.value)">
                            <span id="thresholdValue" class="text-lg font-bold text-blue-900">0.7</span>
                        </div>
                    </div>
                    <div class="mt-3 grid grid-cols-3 gap-2 text-xs">
                        <div class="text-center p-2 bg-white rounded border">
                            <div class="font-semibold text-green-600">0.5 (Aggressive)</div>
                            <div class="text-gray-600">Keeps more chunks</div>
                        </div>
                        <div class="text-center p-2 bg-white rounded border">
                            <div class="font-semibold text-blue-600">0.7 (Balanced)</div>
                            <div class="text-gray-600">Current setting</div>
                        </div>
                        <div class="text-center p-2 bg-white rounded border">
                            <div class="font-semibold text-red-600">0.8 (Conservative)</div>
                            <div class="text-gray-600">Removes more chunks</div>
                        </div>
                    </div>
                </div>

                <!-- Statistics Overview -->
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <div id="totalChunksCount" class="text-2xl font-bold text-blue-600">${data.total_chunks}</div>
                        <div class="text-sm text-blue-800">Total Chunks</div>
                    </div>
                    <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                        <div id="keptChunksCount" class="text-2xl font-bold text-green-600">${data.kept_chunks}</div>
                        <div class="text-sm text-green-800">Kept for LLM</div>
                    </div>
                    <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                        <div id="removedChunksCount" class="text-2xl font-bold text-red-600">${data.removed_chunks}</div>
                        <div class="text-sm text-red-800">Filtered Out</div>
                    </div>
                    <div class="bg-purple-50 border border-purple-200 rounded-lg p-4">
                        <div id="contentReductionPercent" class="text-2xl font-bold text-purple-600">${data.filtering_stats.reduction_percent.toFixed(1)}%</div>
                        <div class="text-sm text-purple-800">Content Reduction</div>
                    </div>
                </div>
                
                <!-- Cost Analysis -->
                <div class="bg-gray-50 border border-gray-200 rounded-lg p-4 mb-6">
                    <h4 class="text-lg font-semibold text-gray-900 mb-3">üí∞ Cost Analysis</h4>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div>
                            <div class="text-sm text-gray-600">Original Content</div>
                            <div class="text-lg font-semibold">${data.content_length.toLocaleString()} chars</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Estimated Cost Savings</div>
                            <div class="text-lg font-semibold text-green-600">$${data.filtering_stats.cost_savings.toFixed(4)}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Tokens Saved</div>
                            <div class="text-lg font-semibold text-blue-600">${data.filtering_stats.tokens_saved.toLocaleString()}</div>
                        </div>
                    </div>
                </div>
                
                <!-- Chunk Visualization -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-gray-900 mb-3">üìä Chunk Visualization</h4>
                    <div class="bg-white border border-gray-200 rounded-lg p-4">
                        <div id="chunkVisualizationContainer">
                            ${chunkVisualization}
                        </div>
                    </div>
                </div>
                
                <!-- Filter Controls -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-gray-900 mb-3">üéõÔ∏è Filter Controls</h4>
                    <div class="flex flex-wrap gap-4">
                        <button onclick="filterChunks('all')" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors">
                            Show All Chunks
                        </button>
                        <button onclick="filterChunks('kept')" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors">
                            Show Kept Only
                        </button>
                        <button onclick="filterChunks('removed')" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors">
                            Show Removed Only
                        </button>
                        <button onclick="filterChunks('threat')" class="px-4 py-2 bg-orange-600 text-white rounded-md hover:bg-orange-700 transition-colors">
                            Show Threat Keywords
                        </button>
                        <button onclick="filterChunks('perfect')" class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition-colors">
                            Show Perfect Discriminators
                        </button>
                        <button onclick="filterChunks('ml')" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors">
                            Show ML Predictions
                        </button>
                    </div>
                </div>
                
                <!-- Chunk Details -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-gray-900 mb-3">üìù Chunk Details</h4>
                    <div id="chunkDetails" class="space-y-4">
                        ${generateChunkDetails(data.chunk_analysis)}
                    </div>
                </div>
                
                <div class="flex justify-between">
                    <button onclick="triggerModelRetraining()" 
                            class="px-6 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
                        ü§ñ Retrain Model with Feedback
                    </button>
                    <button onclick="closeChunkDebugModal()" 
                            class="px-6 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 transition-colors">
                        Close
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Store debug data globally for filtering
        window.chunkDebugData = data;
        
        // Initialize slider position based on current threshold
        const thresholdSlider = document.getElementById('thresholdSlider');
        if (thresholdSlider) {
            thresholdSlider.value = getSliderFromThreshold(data.min_confidence);
        }
    }
    
    function generateChunkVisualization(data) {
        const totalLength = data.content_length;
        const chunks = data.chunk_analysis;
        
        let html = '<div class="relative bg-gray-100 rounded-lg p-2 mb-4" style="height: 60px;">';
        
        chunks.forEach((chunk, index) => {
            const width = (chunk.length / totalLength) * 100;
            const left = (chunk.start / totalLength) * 100;
            const color = chunk.is_kept ? 'bg-green-500' : 'bg-red-500';
            const opacity = chunk.is_kept ? 'opacity-80' : 'opacity-60';
            
            html += `
                <div class="absolute ${color} ${opacity} rounded cursor-pointer hover:opacity-100 transition-opacity"
                     style="left: ${left}%; width: ${width}%; height: 100%;"
                     title="Chunk ${chunk.chunk_id}: ${chunk.length} chars (${chunk.is_kept ? 'KEPT' : 'REMOVED'})"
                     onclick="highlightChunk(${index})">
                </div>
            `;
        });
        
        html += '</div>';
        
        // Add legend
        html += `
            <div class="flex items-center space-x-4 text-sm">
                <div class="flex items-center">
                    <div class="w-4 h-4 bg-green-500 rounded mr-2"></div>
                    <span>Kept for LLM</span>
                </div>
                <div class="flex items-center">
                    <div class="w-4 h-4 bg-red-500 rounded mr-2"></div>
                    <span>Filtered Out</span>
                </div>
            </div>
        `;
        
        return html;
    }
    
    function generateChunkDetails(chunks) {
        return chunks.map((chunk, index) => `
            <div class="chunk-detail border rounded-lg p-4 ${chunk.is_kept ? 'bg-green-50 border-green-200' : 'bg-red-50 border-red-200'}" data-chunk-id="${index}">
                <div class="flex justify-between items-start mb-2">
                    <div class="flex items-center space-x-2">
                        <span class="font-semibold text-gray-900">Chunk ${chunk.chunk_id}</span>
                        <span class="px-2 py-1 text-xs rounded-full ${chunk.is_kept ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">
                            ${chunk.is_kept ? 'KEPT' : 'REMOVED'}
                        </span>
                        ${chunk.has_threat_keywords ? '<span class="px-2 py-1 text-xs rounded-full bg-orange-100 text-orange-800">THREAT</span>' : ''}
                        ${chunk.has_command_patterns ? '<span class="px-2 py-1 text-xs rounded-full bg-blue-100 text-blue-800">COMMAND</span>' : ''}
                        ${chunk.has_perfect_discriminators ? '<span class="px-2 py-1 text-xs rounded-full bg-purple-100 text-purple-800">PERFECT</span>' : ''}
                    </div>
                    <div class="text-sm text-gray-500">
                        ${chunk.length} chars (${chunk.start}-${chunk.end})
                    </div>
                </div>
                
                <!-- ML Prediction Details -->
                ${chunk.ml_details && !chunk.ml_details.error ? `
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-3">
                        <div class="flex items-center justify-between mb-2">
                            <h5 class="font-semibold text-blue-900">ü§ñ Random Forest Prediction</h5>
                            <span class="px-2 py-1 text-xs rounded-full ${chunk.ml_details.prediction_label === 'Huntable' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">
                                ${chunk.ml_details.prediction_label}
                            </span>
                        </div>
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <div>
                                <div class="text-gray-600">Confidence:</div>
                                <div class="font-semibold">${(chunk.ml_details.confidence * 100).toFixed(1)}%</div>
                            </div>
                            <div>
                                <div class="text-gray-600">Probabilities:</div>
                                <div class="font-semibold">
                                    Huntable: ${(chunk.ml_details.probabilities.huntable * 100).toFixed(1)}% | 
                                    Not Huntable: ${(chunk.ml_details.probabilities.not_huntable * 100).toFixed(1)}%
                                </div>
                            </div>
                        </div>
                        
                        <!-- Top Features -->
                        ${chunk.ml_details.top_features ? `
                            <div class="mt-3">
                                <div class="text-gray-600 text-sm mb-1">Top Contributing Features:</div>
                                <div class="flex flex-wrap gap-1">
                                    ${Object.entries(chunk.ml_details.top_features).slice(0, 5).map(([feature, importance]) => `
                                        <span class="px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded" title="Contribution: ${importance.toFixed(3)}">
                                            ${feature}: ${importance.toFixed(3)}
                                        </span>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                ` : chunk.ml_details && chunk.ml_details.error ? `
                    <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-3 mb-3">
                        <div class="text-yellow-800 text-sm">
                            <strong>ML Error:</strong> ${chunk.ml_details.error}
                        </div>
                    </div>
                ` : `
                    <div class="bg-gray-50 border border-gray-200 rounded-lg p-3 mb-3">
                        <div class="text-gray-600 text-sm">
                            <strong>Pattern-based Classification</strong> (ML model not available)
                        </div>
                    </div>
                `}
                
                <div class="text-sm text-gray-700 mb-2">
                    <strong>Reason:</strong> ${chunk.reason}
                    ${chunk.confidence > 0 ? ` | <strong>Confidence:</strong> ${(chunk.confidence * 100).toFixed(1)}%` : ''}
                </div>
                
                <!-- Feedback Section -->
                <div class="mb-3 p-3 bg-gray-50 rounded-lg border">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm font-medium text-gray-700">Was this classification correct?</span>
                        <div class="flex gap-2">
                            <button onclick="submitChunkFeedback(${index}, true)" 
                                    class="px-3 py-1 text-xs bg-green-100 text-green-800 rounded hover:bg-green-200 transition-colors">
                                ‚úÖ Correct
                            </button>
                            <button onclick="submitChunkFeedback(${index}, false)" 
                                    class="px-3 py-1 text-xs bg-red-100 text-red-800 rounded hover:bg-red-200 transition-colors">
                                ‚ùå Incorrect
                            </button>
                        </div>
                    </div>
                    <div id="feedbackForm${index}" class="hidden">
                        <textarea id="feedbackComment${index}" 
                                  placeholder="Optional: Explain why this classification is incorrect..."
                                  class="w-full p-2 text-xs border rounded resize-none" 
                                  rows="2"></textarea>
                        <div class="flex justify-end gap-2 mt-2">
                            <button onclick="cancelFeedback(${index})" 
                                    class="px-3 py-1 text-xs bg-gray-100 text-gray-600 rounded hover:bg-gray-200">
                                Cancel
                            </button>
                            <button onclick="submitDetailedFeedback(${index})" 
                                    class="px-3 py-1 text-xs bg-blue-100 text-blue-800 rounded hover:bg-blue-200">
                                Submit Feedback
                            </button>
                        </div>
                    </div>
                    <div id="feedbackSubmitted${index}" class="hidden text-xs text-green-600">
                        ‚úÖ Feedback submitted - Thank you!
                    </div>
                </div>
                
                <!-- Feature Details -->
                <div class="mb-3">
                    <button onclick="toggleFeatureDetails(${index})" class="text-sm text-blue-600 hover:text-blue-800 font-medium">
                        üìä Show Feature Details
                    </button>
                    <div id="featureDetails${index}" class="hidden mt-2 bg-gray-50 rounded p-3 text-xs">
                        <div class="grid grid-cols-2 gap-2">
                            ${Object.entries(chunk.features).map(([key, value]) => `
                                <div class="flex justify-between">
                                    <span class="text-gray-600">${key}:</span>
                                    <span class="font-mono">${typeof value === 'number' ? value.toFixed(3) : value}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
                
                <div class="text-sm text-gray-600 bg-white rounded p-2 border">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-xs text-gray-500">Chunk Content (${chunk.length} chars)</span>
                        <button onclick="toggleChunkContent(${index})" class="text-xs text-blue-600 hover:text-blue-800 font-medium">
                            üìÑ ${chunk.text.length > 200 ? 'Show Full Text' : 'View Text'}
                        </button>
                    </div>
                    <div id="chunkContent${index}" class="max-h-32 overflow-y-auto">
                        ${chunk.text.substring(0, 200)}${chunk.text.length > 200 ? '...' : ''}
                    </div>
                    <div id="chunkContentFull${index}" class="hidden max-h-96 overflow-y-auto text-xs font-mono whitespace-pre-wrap">
                        ${chunk.text}
                    </div>
                </div>
            </div>
        `).join('');
    }
    
    function filterChunks(filter) {
        const chunkDetails = document.getElementById('chunkDetails');
        const chunks = chunkDetails.querySelectorAll('.chunk-detail');
        
        chunks.forEach(chunk => {
            const chunkId = parseInt(chunk.dataset.chunkId);
            const chunkData = window.chunkDebugData.chunk_analysis[chunkId];
            
            let show = false;
            
            switch(filter) {
                case 'all':
                    show = true;
                    break;
                case 'kept':
                    show = chunkData.is_kept;
                    break;
                case 'removed':
                    show = !chunkData.is_kept;
                    break;
                case 'threat':
                    show = chunkData.has_threat_keywords || chunkData.has_command_patterns;
                    break;
                case 'perfect':
                    show = chunkData.has_perfect_discriminators;
                    break;
                case 'ml':
                    show = chunkData.ml_details && !chunkData.ml_details.error;
                    break;
            }
            
            chunk.style.display = show ? 'block' : 'none';
        });
    }
    
    function highlightChunk(chunkIndex) {
        // Scroll to chunk detail
        const chunkDetail = document.querySelector(`[data-chunk-id="${chunkIndex}"]`);
        if (chunkDetail) {
            chunkDetail.scrollIntoView({ behavior: 'smooth', block: 'center' });
            chunkDetail.classList.add('ring-2', 'ring-blue-500');
            setTimeout(() => {
                chunkDetail.classList.remove('ring-2', 'ring-blue-500');
            }, 2000);
        }
    }
    
    function closeChunkDebugModal() {
        const modal = document.getElementById('chunkDebugModal');
        if (modal) {
            modal.remove();
        }
        // Clear global data
        window.chunkDebugData = null;
    }
    
    // Threshold mapping function
    function getThresholdFromSlider(sliderValue) {
        const thresholds = [0.5, 0.7, 0.8];
        return thresholds[parseInt(sliderValue)];
    }
    
    function getSliderFromThreshold(threshold) {
        const thresholds = [0.5, 0.7, 0.8];
        return thresholds.indexOf(threshold);
    }
    
    // Update threshold from slider position
    async function updateThresholdFromSlider(sliderValue) {
        const threshold = getThresholdFromSlider(sliderValue);
        await updateThreshold(threshold);
    }
    
    // Threshold update function
    async function updateThreshold(newThreshold) {
        try {
            // Update the display value
            const thresholdValueEl = document.getElementById('thresholdValue');
            if (thresholdValueEl) {
                thresholdValueEl.textContent = newThreshold;
            }
            
            // Update slider position
            const thresholdSlider = document.getElementById('thresholdSlider');
            if (thresholdSlider) {
                thresholdSlider.value = getSliderFromThreshold(parseFloat(newThreshold));
                thresholdSlider.disabled = true; // Show loading state
            }
            
            // Store the threshold globally
            window.chunkDebugThreshold = parseFloat(newThreshold);
            
            // Reload chunk debug data with new threshold
            const response = await fetch(`/api/articles/{{ article.id }}/chunk-debug?chunk_size=1000&overlap=200&min_confidence=${newThreshold}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const debugData = await response.json();
            
            // Update the modal with new data
            updateChunkDebugResults(debugData);
            
        } catch (error) {
            console.error('Threshold update error:', error);
            showNotification('Failed to update threshold: ' + error.message, 'error');
        } finally {
            // Re-enable slider
            const thresholdSlider = document.getElementById('thresholdSlider');
            if (thresholdSlider) {
                thresholdSlider.disabled = false;
            }
        }
    }
    
    function updateChunkDebugResults(data) {
        // Update statistics cards using IDs
        const totalChunksEl = document.getElementById('totalChunksCount');
        const keptChunksEl = document.getElementById('keptChunksCount');
        const removedChunksEl = document.getElementById('removedChunksCount');
        const reductionEl = document.getElementById('contentReductionPercent');
        
        if (totalChunksEl) totalChunksEl.textContent = data.total_chunks;
        if (keptChunksEl) keptChunksEl.textContent = data.kept_chunks;
        if (removedChunksEl) removedChunksEl.textContent = data.removed_chunks;
        if (reductionEl) reductionEl.textContent = `${data.filtering_stats.reduction_percent.toFixed(1)}%`;
        
        // Update chunk details
        const chunkDetails = document.getElementById('chunkDetails');
        if (chunkDetails) {
            chunkDetails.innerHTML = generateChunkDetails(data.chunk_analysis);
        }
        
        // Update chunk visualization
        const chunkVisualizationContainer = document.getElementById('chunkVisualizationContainer');
        if (chunkVisualizationContainer) {
            chunkVisualizationContainer.innerHTML = generateChunkVisualization(data);
        }
        
        // Update global data
        window.chunkDebugData = data;
        
        // Show notification
        showNotification(`Threshold updated to ${window.chunkDebugThreshold}. ${data.kept_chunks} chunks kept, ${data.removed_chunks} removed.`, 'success');
    }
    
    // Feedback Functions
    async function submitChunkFeedback(chunkIndex, isCorrect) {
        const chunkData = window.chunkDebugData.chunk_analysis[chunkIndex];
        
        if (isCorrect) {
            // Submit positive feedback immediately
            await submitFeedback(chunkIndex, {
                is_correct: true,
                user_classification: chunkData.is_kept ? 'Huntable' : 'Not Huntable',
                comment: 'User confirmed classification is correct'
            });
        } else {
            // Show feedback form for incorrect classification
            const feedbackForm = document.getElementById(`feedbackForm${chunkIndex}`);
            feedbackForm.classList.remove('hidden');
        }
    }
    
    async function submitDetailedFeedback(chunkIndex) {
        const chunkData = window.chunkDebugData.chunk_analysis[chunkIndex];
        const comment = document.getElementById(`feedbackComment${chunkIndex}`).value;
        
        await submitFeedback(chunkIndex, {
            is_correct: false,
            user_classification: chunkData.is_kept ? 'Not Huntable' : 'Huntable',
            comment: comment || 'User marked classification as incorrect'
        });
    }
    
    function cancelFeedback(chunkIndex) {
        const feedbackForm = document.getElementById(`feedbackForm${chunkIndex}`);
        feedbackForm.classList.add('hidden');
        document.getElementById(`feedbackComment${chunkIndex}`).value = '';
    }
    
    async function submitFeedback(chunkIndex, feedbackData) {
        try {
            const chunkData = window.chunkDebugData.chunk_analysis[chunkIndex];
            
            const payload = {
                article_id: window.chunkDebugData.article_id,
                chunk_id: chunkIndex,
                chunk_text: chunkData.text,
                model_classification: chunkData.is_kept ? 'Huntable' : 'Not Huntable',
                model_confidence: chunkData.confidence,
                model_reason: chunkData.reason,
                ...feedbackData,
                timestamp: new Date().toISOString()
            };
            
            const response = await fetch('/api/feedback/chunk-classification', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });
            
            if (response.ok) {
                // Hide feedback form and show success message
                document.getElementById(`feedbackForm${chunkIndex}`).classList.add('hidden');
                document.getElementById(`feedbackSubmitted${chunkIndex}`).classList.remove('hidden');
                
                showNotification('Feedback submitted successfully!', 'success');
            } else {
                throw new Error('Failed to submit feedback');
            }
            
        } catch (error) {
            console.error('Feedback submission error:', error);
            showNotification('Failed to submit feedback: ' + error.message, 'error');
        }
    }
    
    async function triggerModelRetraining() {
        try {
            // Show confirmation dialog
            const confirmed = confirm('This will retrain the ML model using collected user feedback. This may take a few minutes. Continue?');
            if (!confirmed) {
                return;
            }
            
            // Show loading state
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'üîÑ Retraining...';
            button.disabled = true;
            
            const response = await fetch('/api/model/retrain', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            const result = await response.json();
            
            if (response.ok) {
                showNotification('Model retraining completed successfully!', 'success');
                
                // Ask if user wants to reload the page to see updated model
                const reload = confirm('Model retraining complete! Reload the page to see the updated model in action?');
                if (reload) {
                    window.location.reload();
                }
            } else {
                throw new Error(result.detail || 'Retraining failed');
            }
            
        } catch (error) {
            console.error('Retraining error:', error);
            showNotification('Failed to retrain model: ' + error.message, 'error');
        } finally {
            // Restore button state
            button.textContent = originalText;
            button.disabled = false;
        }
    }
    
    function toggleFeatureDetails(chunkIndex) {
        const featureDetails = document.getElementById(`featureDetails${chunkIndex}`);
        if (featureDetails) {
            featureDetails.classList.toggle('hidden');
        }
    }
    
    function toggleChunkContent(chunkIndex) {
        const preview = document.getElementById(`chunkContent${chunkIndex}`);
        const full = document.getElementById(`chunkContentFull${chunkIndex}`);
        const button = preview.parentElement.querySelector('button');
        
        if (preview && full && button) {
            const isHidden = full.classList.contains('hidden');
            
            if (isHidden) {
                // Show full content
                preview.classList.add('hidden');
                full.classList.remove('hidden');
                button.textContent = 'üìÑ Hide Text';
            } else {
                // Show preview
                preview.classList.remove('hidden');
                full.classList.add('hidden');
                button.textContent = 'üìÑ Show Full Text';
            }
        }
    }

    // Check AI Assistant button state on page load
    document.addEventListener('DOMContentLoaded', function() {
        checkAIAssistantButtonState();
    });
    
    function checkAIAssistantButtonState() {
        const button = document.getElementById('aiAssistantBtn');
        if (!button) return;
        
        // Get AI model from settings
        const settings = JSON.parse(localStorage.getItem('ctiScraperSettings') || '{}');
        const aiModel = settings.aiModel || 'chatgpt';
        
        // Check content size limits
        const contentLength = {{ article.content|length if article.content else 0 }};
        const contentLimit = aiModel === 'chatgpt' ? {{ chatgpt_content_limit }} : 
                           aiModel === 'anthropic' ? {{ anthropic_content_limit }} : {{ ollama_content_limit }};
        
        if (contentLength > contentLimit) {
            // Disable button and add explanation
            button.disabled = true;
            button.className = button.className.replace('bg-purple-600 hover:bg-purple-700', 'bg-gray-400 cursor-not-allowed');
            button.removeAttribute('title'); // Remove tooltip to avoid grey box
            
            // Add warning icon
            const icon = button.querySelector('span');
            if (icon) {
                icon.textContent = '‚ö†Ô∏è';
            }
            
            // Update popover content
            const popover = document.getElementById('aiAssistantPopover');
            const popoverContent = document.getElementById('popoverContent');
            if (popover && popoverContent) {
                popoverContent.textContent = `${contentLength.toLocaleString()} characters (limit: ${contentLimit.toLocaleString()})`;
                
                // Add hover event listeners to wrapper
                const wrapper = document.getElementById('aiAssistantWrapper');
                if (wrapper) {
                    wrapper.addEventListener('mouseenter', function() {
                        popover.classList.remove('hidden');
                    });
                    
                    wrapper.addEventListener('mouseleave', function() {
                        popover.classList.add('hidden');
                    });
                }
            }
        }
    }
</script>
{% endblock %}
